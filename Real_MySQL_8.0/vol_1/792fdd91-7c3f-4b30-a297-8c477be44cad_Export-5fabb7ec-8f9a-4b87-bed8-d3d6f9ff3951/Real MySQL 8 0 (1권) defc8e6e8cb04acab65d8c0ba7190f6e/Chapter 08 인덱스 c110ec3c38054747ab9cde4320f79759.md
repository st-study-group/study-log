# Chapter 08 인덱스

## 함수 기반 인덱스

일반적인 인덱스는 컬럼의 값 일부 또는 전체에 대해서만 인덱스 생성이 허용

칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때가 있음 → **함수 기반의 인덱스**

MySQL 8.0 버전부터 함수 기반 인덱스를 지원

### 가상 컬럼을 이용한 인덱스

가상 컬럼을 추가하고 그 가상 컬럼에 인덱스를 생성

가상 컬럼이 VIRTUAL이나 STORED 중 어떤 옵션으로 생성됐든 관계없이 가상 컬럼에 인덱스 생성 가능

```sql
CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	PRIMARY KEY (user_id)
);

ALTER TABLE user
	ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
	ADD INDEX ix_fullname(full_name);
```

### 함수를 이용한 인덱스

MySQL 8.0 버전부터는 테이블의 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스 생성이 가능해짐

인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식 그대로 사용해야 함

인덱스에 명시된 표현식 그대로 사용하지 않으면 MySQL 옵티마이저가 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못하게 됨

```sql
CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	PRIMARY KEY (user_id),
	INDEX ix_fullname ((CONCAT(first_name, ' ', last_name)))
);
```

### 함수 기반 인덱스

두 개의 방법은 사용법과 SQL 문장의 문법에 조금 차이가 있지만 내부적으로 동일한 구현 방법을 사용함

어떤 방법을 사용하더라도 둘의 성능 차이는 발생하지 않음

## 멀티 밸류 인덱스

전문 검색 인덱스를 제외한 모든 인덱스는 인덱스 키와 데이터 레코드가 1:1 관계를 가짐

하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스 → 멀티 밸류 인덱스

일반적인 RDBMS를 기준으로 생각하면 정규화에 위배되는 형태

최근 JSON 데이터 타입을 지원하기 시작하면서 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생한 것

이전에는 멀티 밸류 인덱스에 대한 지원 없이 JSON 타입의 컬럼만 지원

MySQL 8.0 버전부터 JSON 관리 기능 업그레이드

```sql
CREATE TABLE user (
	user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	credit_info JSON,
	INDEX mx_creditscores ((CAST(credit_info -> '$.credit_scores' AS UNSIGNED ARRAY)))
);

INSERT INTO user VALUES(1, 'Matt', 'Lee', '{"credit_scores":[360, 353, 351]}');
```

일반적인 조건 방식을 사용하면 안 됨

[사용 가능한 함수](https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html)

- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

## 클러스터링 인덱스

### 클러스터링 인덱스

MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원

주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안

프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것

테이블의 프라이머리 키에 대해서만 적용되는 내용

프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미

프라이머리 키 값으로 컬러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 높기 때문에 신중하게 프라이머리 키를 결정해야 함

프라이머리 키 값에 의해 레코드 저장 위치가 결정되므로 테이블 레코드의 저장 방식이라고 볼 수 있음

클러스터링 인덱스 = 클러스터링 테이블: 동의어로 사용되기도 함

클러스터링의 기준이 되는 프라이머리 키는 클러스터링 키라고 표현

InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블

프라이머리 키 기반의 검색이 매우 빠름

레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느림

![Untitled](Chapter%2008%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20c110ec3c38054747ab9cde4320f79759/Untitled.png)

클러스터링 테이블의 구조 자체는 일반 B-Tree와 비슷

리프 노드에 레코드의 모든 컬럼이 같이 저장되어 있음

⇒ 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리

프라이머리 키를 변경할 경우

```sql
UPDATE tb_test SET emp_no = 100002 where emp_no = 100007;
```

100007인 레코드가 3번에 있었는데 100002로 변경되면서 2번 페이지로 이동함

프라이머리 키의 값이 변경되는 값은 거의 없음

프라이머리 키가 없는 InnoDB 테이블이 클러스터링 테이블로 구성되는 방법

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택

InnoDB 테이블에서 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시적으로 생성하는 것을 추천

### 세컨더리 인덱스에 미치는 영향

MyISAM이나 MEMORY 테이블 같은 클러스터링이되지 않은 테이블은 INSERT될 때 처음 저장된 공간에서 절대 이동하지 않음

MyISAM 테이블이나 MEMORY 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무 차이가 없음

InnoDB 테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면?

클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 함

⇒ 이런 오버헤드를 제거하기 위해 InnoDB 테이블의 모든 세컨더리 인덱스는 프라이머리 키 값을 저장하도록 구현

```sql
CREATE TABLE employees (
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY (emp_no),
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name = 'Aamer';
```

MyISAM: ix_firstname 인덱스를 검색해서 레코드의 주소를 확인한 후, 해당 레코드 주소로 최종 레코드를 가져옴

InnoDB: ix_firstname 인덱스를 검색해서 레코드의 프라이머리 키 값을 확인한 후, 해당 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴

InnoDB가 조금 더 복잡하게 처리

클러스터링 인덱스는 더 큰 장점을 제공하기 때문에 성능 저하에 대해 너무 걱정할 필요 없음

### 클러스터링 인덱스의 장점과 단점

장점

- 프라이머리 키로 조회할 때 처리 성능이 매우 빠름
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리 되는 경우가 많음(커버링 인덱스)

단점

- 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 키 값이 크면 전체적으로 인덱스의 크기가 커짐
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 한번 더 검색해야해서 성능이 느림
- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림

일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경에서는 쓰기와 읽기의 비율이 2:8 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이 매우 중요

### 클러스터링 테이블 사용시 주의사항

- 클러스터링 인덱스 키의 크기
    
    클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함
    
    프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커짐
    
- 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 컬럼으로 생성
    
    프라이머리 키로 검색하는 경우 클러스터링되지 않은 테이블에 비해 매우 빠르게 처리됨
    
    프라이머리 키는 그 의미만큼이나 중요한 역할을 하기 때문에 대부분 검색에서 상당히 비번하게 사용
    
    컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 프라이머리 키로 설정하는 것이 좋음
    
- 프라이머리 키는 반드시 명시할 것
    
    InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련번호 컬럼을 추가
    
    ⇒ 사용자가 전혀 접근(사용)할 수 없게 됨
    
    사용자가 사용할 수 있는 값을 프라이머리 키로 설정하는 것이 좋음
    
- AUTO_INCREMENT 컬럼을 인조 식별자로 사용할 경우
    
    세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 컬럼을 추가하고 이를 프라이머리 키로 설정하면 됨
    
    ⇒ 인조 식별자
    
    로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 큰 도움이 됨
    

## 유니크 인덱스

유니크는 인덱스라기보다 제약 조건에 더 가까움

테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미

MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음

NULL도 저장 가능하고, 특정 값이 아니기 때문에 2개 이상 저장될 수 있음

### 유니크 인덱스와 일반 세컨더리 인덱스 비교

유니크 인덱스와 일반 세컨더리 인덱스는 구조상 아무런 차이점이 없음

성능 관점에서는 있음

- 인덱스 읽기
    
    유니크 인덱스는 1건만 읽으면 되지만 유니크하지 않은 세컨더리 인덱스에서는 레코드를 한 건 더 읽어야 한다는 이유로 많은 사람들이 유니크 인덱스가 빠르다고 생각하는데 사실이 아님
    
    유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 컬럼값을 비교하는 작업
    
    ⇒ 성능상 영향이 거의 없음
    
    유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것
    
    인덱스 자체의 특성 때문에 느린 것이 아님
    
- 인덱스 쓰기
    
    새로운 레코드가 INSERT 되거나 인덱스 컬럼의 값이 변경되는 경우 인덱스 쓰기 작업 필요
    
    유니크 인덱스
    
    중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요
    
    ⇒ 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느림
    
    쓰기 잠금: 데드락이 빈번히 발생
    
    InnoDB 스토리지 엔진은 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼 사용하는데 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못함
    
    ⇒ 일반 세컨더리 인덱스보다 변경 작업이 느림
    

### 유니크 인덱스 사용 시 주의사항

더 성능이 좋아질 것으로 생각하고  불필요하게 유니크 인덱스를 생성하지는 않는 것이 좋음

하나의 테이블에서 같은 컬럼에 유니크 인덱스와 일반 인덱스를 중복해서 생성할 필요 없음

⇒ 유니크 인덱스와 일반 다른 인덱스와 같은 역할을 함

똑같은 컬럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 생성할 필요 없음

⇒ 불필요한 중복

유니크 인덱스는 쿼리의 실행 계획이나 테이블의 파티션에 영향을 미침

유일성이 꼭 보장돼야 하는 컬럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려

## 외래키

MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성 가능

외래키 제약이 설정되면 자동으로 연관되는 테이블 컬럼에 인덱스가 생성됨

외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없음

InnoDB 외래키 관리 중요한 특징

테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생

외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음

### 자식 테이블의 변경이 대기하는 경우

![KakaoTalk_Photo_2023-08-07-17-44-36 001.jpeg](Chapter%2008%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20c110ec3c38054747ab9cde4320f79759/KakaoTalk_Photo_2023-08-07-17-44-36_001.jpeg)

1. 1번 커넥션에서 먼저 트랜잭션을 시작
2. 부모 테이블에서 id가 2인 레코드에 UPDATE 실행
3. 1번 커넥션이 부모 테이블에서 id가 2인 레코드에 대해 쓰기 잠금을 획득
4. 2번 커넥션에서 자식 테이블의 외래키 컬럼인 pid를 2로 변경하는 쿼리 실행
5. 부모 테이블의 변경 작업이 완료될 때까지 대기
6. 1번 커넥션에서 COMMIT으로 트랜잭션 종료
7. 2번 커넥션의 대기 중이던 작업 즉시 처리

자식 테이블의 외래 키 컬럼의 변경은 부모 테이블의 확인이 필요

부모 테이블의 해당 레코드 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 대기

⇒ 첫 번째 특징

자식 테이블의 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음

⇒ 두번 째 특징

### 부모 테이블의 변경 작업이 대기하는 경우

![KakaoTalk_Photo_2023-08-07-17-44-36 002.jpeg](Chapter%2008%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20c110ec3c38054747ab9cde4320f79759/KakaoTalk_Photo_2023-08-07-17-44-36_002.jpeg)

1. 1번 커넥션에서 부모키 1을 참조하는 자식 테이블의 레코드를 변경
2. 자식 테이블의 레코드에 대해 쓰기 잠금 획득
3. 2번 커넥션에서 부모테이블의 id가 1인 레코드를 삭제
4. 자식 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 대기
    - 자식 테이블이 생성될 때 정의된 외래키의 특성 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문

데이터베이스에서 외래키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 모델링을 진행하는 것이 좋음
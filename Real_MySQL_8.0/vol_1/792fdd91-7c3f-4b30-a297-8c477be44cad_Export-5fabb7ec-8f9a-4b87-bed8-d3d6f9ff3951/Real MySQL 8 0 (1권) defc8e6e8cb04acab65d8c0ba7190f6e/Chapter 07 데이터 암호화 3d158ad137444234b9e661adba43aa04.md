# Chapter 07 데이터 암호화

MySQL 5.7 버전부터 지원되기 시작한 데이터 암호화 기능은
처음에 데이터 파일(테이블스페이스)에 대해서만 암호화 기능이 제공됐다.

그러다 MySQL 8.0 버전부터 데이터 파일뿐만 아니라
리두 로그나 언두 로그, 바이너리 로그 등도 모두 암호화 기능을 지원하기 시작했다.

### 7.1 MySQL 서버의 데이터 암호화

MySQL 서버의 암호화 기능은 아래 그림과 같이 데이터베이스 서버와
디스크 사이의 데이터를 읽고 쓰는 지점에서 암호화 / 복호화를 수행한다.

그래서 디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요하지 않다.
즉, InnoDB I/O 레이어에서만 데이터의 암호화 / 복호화 과정이 실행되는 것이다.

![그림 7.1 MySQL 서버의 디스크 입출력](Chapter%2007%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8B%E1%85%A1%E1%86%B7%E1%84%92%E1%85%A9%E1%84%92%E1%85%AA%203d158ad137444234b9e661adba43aa04/Untitled.png)

그림 7.1 MySQL 서버의 디스크 입출력

MySQL 서버에서 사용자의 쿼리를 처리하는 과정에서
테이블의 데이터가 암호화돼 있는지 여부를 식별할 필요가 없고
암호화된 테이블도 그렇지 않은 테이블과 동일한 처리 과정을 거친다.

데이터 암호화 기능이 활성화돼 있다고 해도 MySQL 내부와 사용자 입장에서는 아무런
차이가 없기 때문에 이런 암호화 방식을 가리켜 TDE(Transparent Data Encryption)이라고 한다.

또 다른 용어로 Data at Rest Encryption 이라고도 하는데
여기서의 Data at Rest 은 메모리나 네트워크 전송 단계가 아닌
디스크에 저장된 단계에서만 암호화된다는 의미로 사용되는 표현이다.

MySQL 에서는 둘 모두 거의 동일한 표현으로 사용되지만 주로 TDE 라는 표현을 사용한다.

### 2단계 키 관리

MySQL 서버의 TDE에서 암호화 키는 키링 플러그인에 의해 관리되고
8.0 버전에서 지원되는 키링 플러그인은 아래와 같다.

- keyring_file Fiole-Based 플러그인
- keyring_encrypted_file Keyring 플러그인
- keyring_okv KMIP 플러그인
- keyring_aws Amazon Web Services Keyring 플러그인

하지만 여기서 keyring_file 플러그인을 제외한 다른 플러그인은
엔터프라이즈 에디션에서만 사용이 가능하다.

위 처럼 다양한 플러그인이 제공되지만 마스터 키를 관리하는 방법만 다르고
MySQL 서버 내부적으로 작동하는 방식은 모두 동일하다.

키링 플러그인은 2단계 키 관리 방식을 사용하는데 아래 그림은 2단계 키 관리 아키텍처다.

![그림 7.2 2단계 암호화 아키텍처](Chapter%2007%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8B%E1%85%A1%E1%86%B7%E1%84%92%E1%85%A9%E1%84%92%E1%85%AA%203d158ad137444234b9e661adba43aa04/Untitled%201.png)

그림 7.2 2단계 암호화 아키텍처

MySQL 서버의 데이터 암호화는 마스터 키와 테이블스페이스 키라는
두 가지 종류의 키를 가지고 있는데 테이블스페이스 키는 프라이빗 키라고 불리기도 한다.

MySQL 서버의 TDE 에서 지원하는 암호화 알고리즘은 AES-256 뿐이고
테이블스페이스 키는 AES-256 ECB 알고리즘을
데이터 파일은 AES-256 CBC 알고리즘을 이용해 암호화 된다.

MySQL 서버는 HashiCorp Vault 같은 외부 키 관리 솔루션이나 디스크의 파일에서
마스터 키를 가져오고 암호화된 테이블이 생성될 때마다
해당 테이블을 위한 임의의 테이블스페이스 키를 발급한다.

MySQL 서버는 마스터 키를 이용해 테이블스페이스 키를
암호화해 각 테이블의 데이터 파일 헤더에 저장한다.

이렇게 생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않는다.

그리고 테이블스페이스 키는 절대 MySQL 서버 외부로
노출되지 않기 때문에 주기적으로 변경하지 않아도 되지만
마스터 키는 외부 파일을 이용하기 때문에 주기적으로 변경해야 한다.

```sql
mysql> ALTER INSTANCE ROTATE INNODB MASTER KEY;
```

MySQL이 이렇게 2단계 암호화 방식을 사용하는 이유는
암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위해서다.

만약 테이블스페이스 키가 변경된다면 데이터 파일의
모든 데이터를 다시 복호화 / 암호화 하는 작업을 해야하는데
키를 변경할 때마다 이런 작업을 해야 하고
사용자 쿼리를 처리하는 데도 상당한 영향을 미치게 된다.

### 암호화와 성능

MySQL 서버의 암호화는 TDE 방식이기 때문에 디스크로부터
한 번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재된다.

그래서 데이터 페이지가 한 번 메모리에 적재되면
암호화되지 않은 테이블과 동일한 성능을 보인다.

당연하게도 쿼리가 InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우엔
복호화 과정을 거치기 때문에 복호화 시간동안 쿼리 처리가 지연될 것이다.

그리고 암호화된 테이블이 변경되면 다시 디스크로 동기화될 때
암호화돼야 하기 때문에 디스크에 저장할 때도 추가로 시간이 더 걸린다.

AES 암호화 알고리즘은 암호화하고자 하는 평문의 길이가 짧은 경우
암호화 키의 크기에 따라 암호화된 결과의 용량이 더 커질 수도 있지만
이미 데이터 페이지가 암호화 키보다 훨씬 크기 때문에
암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환한다.

그래서 TDE를 적용한다 해도 데이터 파일의 크기는
암호화되지 않은 테이블과 동일한 크기를 가진다.

즉 암호화한다고 해서 InnoDB 버퍼 풀의 효율이 달라지거나
메모리 사용 효율이 떨어지는 현상은 발생하지 않는다.

같은 테이블에 대해 암호화와 압축이 동시에 적용되면
MySQL 서버는 압축을 먼저 실행하고 암호화를 적용한다.

암호화보다 압축이 먼저 실행되는 이유는 아래와 같다.

- 일반적으로 암호화된 결과문은 아주 랜덤한 바이트의 배열을 가지는데
이는 압축률을 떨어뜨리게 된다.
그래서 최대한 압축 효율을 높이기 위해 사용자의 데이터를
그대로 압축해 용량을 최소화하고 암호화를 적용한다.
- 암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만
압축된 데이터 페이지는 압축 / 해제의 모든 상태로 버퍼 풀에 존재할 수 있다.
그래서 암호화가 먼저 실행되고 압축이 적용된다면 MySQL 서버는
버퍼 풀에 존재하는 데이터 페이지에 대해서도 매번 암복호화 작업을 수행해야 한다.

### 암호화와 복제

MySQL 서버의 복제에서 레플리카 서버는 소스 서버의 모든 사용자 데이터를
동기화하기 때문에 실제 데이터 파일도 동일할 것이라 생각할 수 있지만
TDE 를 이용한 암호화 사용 시 마스터 키와 테이블스페이스 키는 동일하지 않다.

MySQL 서버에서 기본적으로 모든 노드는 각자의 마스터 키를 할당해야 한다.
소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 키를 관리하기 때문에
암호화 되기 전의 데이터 파일이 동일하더라도 암호화된 데이터 파일의 내용은 달라진다.

복제 소스 서버의 마스터 키를 변경하려면 [동일한 명령](Chapter%2007%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8B%E1%85%A1%E1%86%B7%E1%84%92%E1%85%A9%E1%84%92%E1%85%AA%203d158ad137444234b9e661adba43aa04.md)을 실행하면 되는데
이 때 소스 서버의 마스터 키가 레플리카 서버로 전달 되는 것이 아닌
명령만 전달됨을 유의해야 한다.

### 7.2 keyring_file 플러그인 설치

테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크의 파일로 관리하는데
이 때 마스터 키는 평문으로 디스크에 저장된다.

MySQL 서버의 다른 플러그인과 달리 TDE 플러그인의 경우
MySQL 서버가 시작되는 단계에서도 가장 빨리 초기화돼야 한다.

그래서 MySQL 설정 파일에서 `early-plugin-load` 시스템 변수에
keyring_file 플러그인을 위한 라이브러리를 명시해야 한다.

그리고 keyring_file 플러그인이 마스터 키를 저장할 키링 파일의 경로를
`keyring_file_data` 시스템 변수에 명시해야 하는데
이 때 MySQL 서버가 여러개라면 각각의 서버가 다른 키링 파일을 참조하도록 해야한다.

```sql
early-plugin-load = keyring_file.so
keyring_file_data = /very/secure/directory/tde_master.key
```

MySQL 서버의 설정 파일이 준비되면 재시작 후 자동으로 keyring_file 플러그인이 초기화된다.
이 초기화 여부는 `SHOW PLUGINS` 명령으로 확인 가능하다.

keyring_file 플러그인이 초기화되면 MySQL 서버는
`keyring_file_data` 시스템 변수의 경로에 빈 파일을 생성한다.

플러그인만 초기화된 상태일 뿐이라 마스터 키를 사용한 적이 없기 때문에
키링 파일의 내용은 비어있다.

이 때 데이터 암호화 기능을 사용하는 테이블을 생성하거나
[마스터 로테이션](Chapter%2007%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8B%E1%85%A1%E1%86%B7%E1%84%92%E1%85%A9%E1%84%92%E1%85%AA%203d158ad137444234b9e661adba43aa04.md)을 실행하면 키링 파일의 마스터 키가 초기화된다.

### 7.3 테이블 암호화

### 테이블 생성

TDE를 이용하는 테이블은 다음과 같이 생성이 가능하다.

```sql
mysql> CREATE TABLE tab_encrypted (
				id Int,
				data VARCHAR(100),
				PRIMARY KEY(id)
			) ENCRYPTION='Y';
```

일반적인 테이블 생성 구문과 동일하고 마지막에 `ENCRYPTION='Y'` 옵션만 추가로 넣으면 된다.
이제부터 이 테이블의 데이터가 디스크에 기록될 때는 데이터가 자동으로 암호화되어 저장되고
디스크에서 메모리로 읽어올 때 복호화된다.

MySQL 서버에서 암호화된 테이블만 검색할 때는 `information_schema`의 TABLES 뷰를 사용하면 된다.

```sql
mysql> SELECT table_schema, table_name, create_options
				FROM information_schema.tables
				WHERE table_name='tab_encrypted';
```

만약 MySQL 서버의 모든 테이블에 대해 암호화를 적용하고자 한다면 `defualt_table_encryption`
시스템 변수를 ON 으로 설정하면 옵션을 별도로 설정하지 않아도 암호화된 테이블로 생성된다.

### 응용 프로그램 암호화와의 비교

응용 프로그램에서 직접 암호화해 MySQL 서버에 저장하는 경우도 있는데
이 경우 저장되는 컬럼의 값이 암호화된 것인지 여부를 판단하지 못한다.

그렇기에 인덱스를 생성하더라도 인덱스의 기능을 100% 활용하지 못한다.

응용 프로그램의 암호화는 MySQL 서버에 접속해도 그 내용을 알 수 없고
MySQL 의 TDE 는 MySQL 서버에 접속하면 내용을 알 수 있으니
서비스의 요건과 성능을 고려해 선택해야 한다.

MySQL 서버의 암호화 기능을 혼합해 사용하면 더 안전한 서비스를 구축할 수 있을 것이다.

### 테이블스페이스 이동

테이블을 다른 서버로 복사해야 하는 경우나 특정 테이블의 데이터 파일만 덤프했다가 복구하는 경우라면
테이블스페이스 이동(Export & Import) 기능이 레코드를 덤프했다가 복구하는 방식보다 효율적이고 빠르다.

하지만 TDE 가 적용된 데이터 파일은 이 과정에서 신경써야 할 부분이 하나 생긴다.
MySQL 서버에서 다음과 같은 명령으로 테이블스페이스를 Export 할 수 있다.

```sql
mysql> FLUSH TABLE source_table FOR EXPORT;
```

이 명령을 실행하면 source_table 의 저장되지 않은 변경 사항을 모두 디스크로 기록하고
더이상 source_table 에 접근할 수 없게 잠금을 건다.
그와 동시에 source_table 의 구조를 source_table.cfg 파일로 기록해 둔다.

그러면 source_table.ibd 파일과 source_table.cfg 파일을 목적지 서버로 복사한다.
복사가 모두 완료되면 UNLOCK TABLES 명령을 사용해 source_table 을 사용할 수 있게 하면 된다.

TDE 로 암호화된 테이블은 여기서 추가로 MySQL 서버가 임시로 사용할 마스터 키를 발급한다.
이 마스터 키는 source_table.cfp라는 파일로 기록되고
암호화된 테이블의 테이블스페이스 키를 기존 마스터 키로 복호화한 후
임시로 발급한 마스터 키를 이용해 다시 암호화해 데이터 파일의 헤더 부분에 저장한다.

그래서 cfg 파일은 없어져도 경고만 뜨고 테이블스페이스를 복구할 수 있는 반면
cfp 파일은 없어지면 다신 복구하지 못한다.

### 7.4 언두 로그 및 리두 로그 암호화

테이블의 암호화를 적용해도 디스크로 저장되는 데이터만 암호화되고
서버의 메모리에 존재하는 데이터는 복호화된 평문으로 관리된다.

이 평문 데이터가 테이블의 데이터 파일 이외의 디스크 파일로
기록되는 경우 여전히 평문으로 저장된다.

그래서 테이블 암호화를 적용해도 리두 로그와 언두 로그 바이너리 로그에는
평문으로 저장되는 것이다.

물론 MySQL 8.0.16 버전부터는 `innodb_undo_log_encrypt` 시스템 변수와
`innodb_redo_log_encrypt` 시스템 변수를 이용해 암호화된 상태로 저장할 수 있게 해준다.

테이블의 암호화는 테이블 하나에 대해 암호화가 적용되면 해당 테이블의 모든 데이터가 암호화되어야 하지만
리두 로그나 언두 로그는 그렇게 적용할 수 없다.

그래서 MySQL 서버는 리두 로그와 언두 로그에 대해
암호화가 적용된 시점 이후로 생성되는 로그만 암호화해 저장한다.

반대로 리두 로그와 언두 로그가 암호화되는 상태에서
암호화를 비활성화하면 그때부터 저장되는 로그만 평문으로 저장된다.

그래서 암호화를 하던 안하던 암호화에 사용된 키가 불필요해지는 것은 아니다.

리두 로그와 언두 로그 데이터 모두 각각의 테이블스페이스 키로 암호화되고
테이블스페이스 키는 다시 마스터 키로 암호화된다.

리두 로그와 언두 로그가 암호화 되었는지는 아래 명령을 통해 확인 가능하다.

```sql
mysql> SHOW GLOBAL VARIABLES LIKE 'innodb_redo_log_encrypt';
mysql> SHOW GLOBAL VARIABLES LIKE 'innodb_undo_log_encrypt';
```

### 7.5 바이너리 로그 암호화

테이블 암호화가 적용돼도 바이너리 로그와 릴레이 로그 파일 또한 리두 로그 언두 로그처럼 평문을 저장한다.
일반적으로 언두 로그와 리두 로그는 길지 않은 시간 동안의 데이터만 가지기 때문에
크게 보안에 민감하지 않을 수 있지만 바이너리 로그는 의도적으로 긴 시간 동안 보관하는 서비스도 있고
때로 증분 백업을 위해 바이너리 로그를 보관하기도 한다.

바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고
MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의
네트워크 구간에서 로그 데이터를 암호화하지 않는다.

복제 멤버 간의 네트워크 구간에서도 바이너리 로그를 암호화하고자 한다면
MySQL 복제를 위한 계정이 SSL 을 사용하도록 설정하면 된다.

### 바이너리 로그 암호화 키 관리

바이너리 로그와 릴레이 로그 파일 데이터의 암호화를 위해서도
MySQL 서버는 2단계 암호화 키 관리 방식을 사용한다.

![그림 7.3 바이너리 로그 파일의 암호화 방식](Chapter%2007%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%8B%E1%85%A1%E1%86%B7%E1%84%92%E1%85%A9%E1%84%92%E1%85%AA%203d158ad137444234b9e661adba43aa04/Untitled%202.png)

그림 7.3 바이너리 로그 파일의 암호화 방식

바이너리 로그와 릴레이 로그 파일의 데이터는 파일 키로 암호화해 디스크로 저장하고
파일 키는 바이너리 로그 암호화 키로 암호화해서
각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장된다.

즉 바이너리 로그 암호화 키는 테이블 암호화의 마스터 키와 동일한 역할을 하고
파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동 생성되어 로그 파일의 데이터 암호화에만 사용된다.

### 바이너리 로그 암호화 키 변경

바이너리 로그 암호화 키는 다음과 같이 변경할 수 있다.

```sql
mysql> ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

바이너리 로그 암호화 키가 변경되면 다음의 과정을 거친다.

1. 증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고
파일 키는 바이너리 로그 파일 키로 암호화해 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어
새로운 바이너리 로그 파일 키로 암호화해서 다시 저장
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로
다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

여기서 4번 과정이 오래 걸릴 수 있는데
이를 위해 키링 파일에서 바이너리 로그 암호화 키는 내부적으로 버전 관리가 이뤄진다.

MySQL 에서 바이너리 로그 파일의 암호화 여부는 아래 명령을 통해 확인 가능하다.

```sql
mysql> SHOW BINARY LOGS;
```

### mysqlbinlog 도구 활용

MySQL 서버에서는 트랜잭션의 내용을 추적하거나 백업 복구를 위해
암호화된 바이너리 로그를 평문으로 복호화할 일이 자주 발생한다.

하지만 한 번 바이너리 로그 파일이 암호화되면 바이너리 로그 암호화 키가 없으면 복호화할 수 없다.
그러면 바이너리 로그 암호화 키는 MySQL 서버만 갖고 있기 때문에 복호화가 불가능하다.

mysqlbinlog 도구를 이용해 암호화된 바이너리 로그 파일의 내용을 SQL 문장으로 풀어보면
암호화된 바이너리 로그 파일은 직접 열 수 없다는 에러 메시지가 발생한다.

```bash
linux> mysqlbinlog -vvv mysql-bin.00011
Enter password:
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
**ERROR: Reading encrypted log files directly is not supported.**
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!5003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/
```

바이너리 로그 암호화 키는 그 바이너리 로그나 릴레이 로그 파일을 생성한 MySQL 서버만 가지고 있어
mysqlbinlog 도구만으로는 복호화할 방법이 없다.
그래서 예전처럼 다른 서버로 복사하거나 바이너리 로그 파일을 백업하는 것은 소용없어졌다.

그나마 바이너리 로그 파일의 내용을 볼 수 있는 방법은 MySQL 서버를 통해 가져오는 방법뿐인데
MySQL 서버가 mysql-bin.000011 로그 파일을 가지고 있다는 가정하에
`—read-from-remote-server` 파라미터와 함께 mysqlbinlog 명령을 실행하면 된다.

```bash
linux> mysqlbinlog --read-from-remote-server -uroot -p -vv mysql-bin.000011
Enter password:
....
### INSERT INTP `test`.`enc`
### SET
###   @1=2 /* INT meta=0 nullable=1 is_null=0 */
###   @2='encrypted_binary log' /* VARSTRING(400) meta=400 nullable=1 is_null0 */
```
# Chapter 09 옵티마이저와 힌트

### 9.1.1 쿼리 실행 절차

MySQL 서버에서 쿼리가 생행되는 과정

1. [SQL 파싱 (SQL 파서)] - MySQL 엔진
    
    SQL 문장을 파스트리 로 분리함.
    
2. [최적화 및 실행 계획 수립 (옵티마이져)] - MySQL 엔진  
    
    파스트리로 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 읽을지 선택함.
    
    - 불필요한 조건 제거 및 복잡한 연산 단순화
    - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
    - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
    - 가져온 레코드를 임시 테이블에 넣고 다시한번 가공해야하는지 결정
3. [작업 수행] - MySQL 엔진, 스토리지 엔진
    
    결정된 테이블 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
    
    - 스토리지 엔진에 레코드를 읽어오도록 요청
    - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 진행함

### 9.1.2 옵티마이저의 종류

옵티마이져 방법 2가지

1. 비용 기반 최적화
    - 대부분의 DBMS 가 선택하고있음
    - 쿼리를 처리하기 위한 여러가지 가능한 방법을 만듬
    - 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계정보를 이용해 실행계획별 비용을 산출함
    - 산출된 실행 방법별로 비용이 최소로 소요되는 처리방식을 선택해 최종적으로 쿼리를 실행함.
2. 규칙 기반 최적화
    - 예전 초기 버전의 오라클 DBMS에서 많이 사용 되었음
    - 통계정보를 조사하지 않고 실행계획이 수립됨. 거의 항상 같은 실행 방법을 만들어냄.
    - 사용자의 데이터의 분포도가 매우 다양하기 때문에 규칙기반의 최적화는 이미 오래전부터 많은 DBMS에서 거의 사용되지 않음
    

---

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔

인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업

- 테이블 레코드 건수가 너무 작아서 인덱스를 통해 읽는것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단 조건 일치 레코드가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사항 통계 정보 기준)

디스크로부터 페이지 스캔 방법 

- MyISAM 스토리지 엔진
    - 디스크로 부터 페이지를 하나씩 읽어옴
- InnoDB 스토리지 엔진
    - 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터 읽기 작업을 백그라운드 스레드로 넘김
    - 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어해드 작업이 자동으로 시작됨.
        
        ⇒ 리드 어헤드
        
        - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB의 버퍼풀에 가져다 두는 것을 의미함.
        - 4개 또는 8개 씩 페이지를 읽으면서 계속 그 수를 증가시킴 (최대 64)
        - 풀 테이블 스캔 뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용됨
        - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리됨

innodb_read_ahead_threshold

- 설정된 개수만큼 연속된 데이터페이지가 읽히면, 백그라운드 스레드를 이용해 대량으로 그다음 페이지를 읽어 버퍼풀로 적제함.

---

```sql
mysql > SELECT count(*) FROM employees;

=> 풀 인덱스 스캔을 하게될 가능성이 높음
   인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에 테이블 자체보다
   용량이 작아서 훨씬 빠른 처리가 가능함.

mysql > SELECT * FROM employees;

=> 풀 테이블 스캔을 함 
```

### 9.2.2 병렬 처리

innodb_parallel_read_threads 이용해 하나의 쿼리를 최대 몇개의 스레드를 이용해서 처리할지 변경 할 수있음.

- where 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있음
- cpu 의 코어 개수를 넘어서는 경우 오히려 성능을 떨어질 수 있음.

```sql
mysql > SET SESSION innodb_parallel_read_threads=1;
mysql > SELECT COUNT(*) FROM salaries;
1 row in set (0.32 sec)

mysql > SET SESSION innodb_parallel_read_threads=2;
mysql > SELECT COUNT(*) FROM salaries;
1 row in set (0.20 sec)

mysql > SET SESSION innodb_parallel_read_threads=4;
mysql > SELECT COUNT(*) FROM salaries;
1 row in set (0.18 sec)

mysql > SET SESSION innodb_parallel_read_threads=8;
mysql > SELECT COUNT(*) FROM salaries;
1 row in set (0.13 sec)
```

---

### 9.2.3 ORDER BY 처리(Using filesort)

정렬를 처리하는 방법

1. 인덱스를 이용하는 방법
2. Filesort 라는 별도의 처리방법

|  | 장점 | 단점 |
| --- | --- | --- |
| 인덱스 이용 | INSERT, UPDATE, DELETE 쿼리가 실행될때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되므로 매우 빠름. | INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림

인덱스 때문에 디스크 공간이 더 많이 필요함.

인덱스의 개수가 늘어날 수록 InnoDB 의 버퍼풀을 위한 메모리가 많이 필요함 |
| Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스를 이용할때의 단점이 장점으로 바뀜

정렬해야 할 레코드가 많지 않다면 메모리에서 Filesort 가 처리되므로 충분히 빠름.
 | 정렬 작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많을수록 쿼리의 응답속도가 느림 |

모든 정렬을 인덱스를 이용하도록 하도록 튜닝하기란 거의 불가능함

- 정렬 기준이 너무 많아 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

실행계획 Extra 칼럼의 “Using filesort” 메세지가 표시되는지 여부러 판단 가능함.

### 9.2.3.1 소트 버퍼

소트 버퍼

- 정렬을 수행하기위한 별도의 메모리 공간
    - 정렬이 필요한 경우에만 할당됨
    - 쿼리의 실행이 완료되면 즉시 시스템으로 반납됨
    - sort_buffer_size - 최대 사용 가능한 소트 버퍼의 공간

정렬해야할 레코드의 건수가 소트버퍼로 할당된 공간보다 크면??

- 여러 조각으로 나눠 처리하게됨
- 임시 저장을 위해 디스크를 사용
- (멀티 머지) 버퍼 크기만큼 정렬된 레코드를 병합하면서 정렬을 수행함
- 멀티 머지 횟수는 Sort_merge_passes 라는 상태 변수에 누적해서 집계됨

소트 버퍼를 크게해도 벤치마크 결과로는 큰차이가 보이지 않음.

![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled.png)

경험상 1MB 미만이 적절해보임

<aside>
💡 MySQL은 글로벌 메모리영역과 세션 메모리 영역으로 나뉨

정렬을 위해 할당하는 소트버퍼는 세션 메모리임
여러 클라이언트가 공유해서 사용할 수 있는 영역이 아님

10MB 이상으로 설정하면 쿼리가 여러 커넥션에서 동시에 발생할때 메모리 부족 현상을 겪을 수 있음.

운영체제의 OOM-Killer 가 여유 메모리 확보하기위해 프로세스를 강제로 종료시킴
OOM-Killer는 메모리를 가장 많이 사용하는 프로세스를 강제종료하기에 Mysql 이 강제종료 순위가 1위가 됨 

</aside>

### 9.2.3.2 정렬 알고리즘

레코드를 정렬할때 레코드를 어떻게 담을지에 따라 달라짐

1. 전체를 소트버퍼에 담음
    
    ⇒ 싱글 패스
    
2. 정렬 기준 칼럼만 소트버퍼에 담음
    
    ⇒ 투 패스
    

(싱글패스, 투패스 -  둘다 공식적인 명칭은 아님)

MySQL의 정렬방식은 3가지임

- <sort_key, rowid> : 정렬키와 레코드의 로우아이디만 가져와서 정렬하는 방식

⇒ “투 패스” 정렬 방식

- <sort_key, additional_fields>: 정렬키와 레코드 전체를 가져와 정렬하는 방식, 레코드의 칼럼은 고정 사이즈로 메모리 저장
- <sort_key, packed_additional_fields>: 정렬키와 레코드 전체를 가져와 정렬하는 방식, 레코드 칼럼들은 가변 사이즈로 메모리 저장

⇒ “싱글 패스” 정렬 방식

### 9.2.3.2.1 싱글 패스 정렬 방식

소트버퍼 정렬 기준 칼럼을 포함에 SELECT 대상이 되는 칼럼 전부를 담아 정렬을 수행하는 방식

```sql
mysql > select emp_no, first_name, last_name
				from employees
				order by first_name;
```

![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%201.png)

### 9.2.3.2.2 투 패스 정렬 방식

정렬 대상 칼럼과 프라이머리 키 값만 소트버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어 SELECT 할 칼럼을 가져오는 정렬방식

![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%202.png)

투 패스 정렬방식 128KB 기준 

- 7000 건 레코드 정렬 (싱글 패스 는 반정도 정렬함(3500 건))

일반적으로 싱글 패스 정렬 방식을 주로 사용함.

다음의 경우 투패스 정렬 방식을 사용함

- 레코드 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때

싱글패스 방식은 레코드 크기나 건수가 작은 경우 빠른 성능을 보임.

투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적임

### 9.2.3.3 정렬 처리 방법

쿼리에 ORDER BY 가 사용되면 다음 3가지 처리방법 중 하나로 처리됨

(일반적으로 아래쪽에 있는 정렬 방법으로 갈 수록 속도는 떨어짐)

| 정렬처리 방법 | 실행 계획의 Extra 칼럼 내용 |
| --- | --- |
| 인덱스를 사용한 정렬  | 별도 표기 없음 |
| 조인에서 드라이빙 테이블만 정렬 | “Using filesort” 메세지가 표시됨  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | “Using temporary; Using filesort” 메세지가 표시됨 |

### 드라이빙 테이블이란

### **DRIVING TABLE 이란?**

JOIN시 먼저 엑세스 되어 Access path(접근 경로)를 주도하는 테이블을 드라이빙 테이블(TRIVING TABLE, OUTER TABLE)이라고 한다.

### **DRIVEN TABLE 이란?**

DRIVEN TABLE 엑섹스 된 후 나중에 액세스 되는 테이블을 드리븐 테이블(DRIVEN TABLE, INNER TABLE)이라고 한다.

인덱스(INDEX)의 존재 및 우선순위 혹은 FROM절에서의 TABLE 지정 순서에 영향을 받으며, 어느 테이블이 먼저 엑세스 되느냐에 따라 속도의 차이가 크게 날 수 있으므로 많은 양의 데이터를 다룰 때, 드라이빙 테이블은 매우 중요하다.

예를 들어,

- 조건을 만족하는 5000만 건인 A 테이블
- 조건을 만족하는 1000건인 B 테이블
    - 조인 시 드라이빙 순서에 따라 속도의 확연한 차이가 있다.

5000만 건을 먼저 드라이빙 하면 **5000만 번을 반복**하여 B 테이블을 탐색하며

1000건인 B가 먼저 드라이빙 되면**최대 1000번** A 테이블 탐색이 반복된다.

즉, 작업 대상이 되는 행(rows)의 수가 적은 테이블부터 액세스 되어야 전체 탐색이 줄어든다.

[https://qingmi-53.tistory.com/231](https://qingmi-53.tistory.com/231)

인덱스를 사용하는 경우

- Filesort 과정 없이 인덱스를 순서대로 읽어거 결과를 반환

인덱스를 사용할 수 없는경우

Where 조건에 일치하는 레코드를 검색해 정렬버퍼에 저장하여 Filesort함

MySQL 옵티마이저는 정렬 대상 레코드를 최소화 하기 위해 2가지 중 하나를 선택함

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

일반적으로 조인을 수행하면 레코드건수와 크기가 늘어나기 때문에
가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적임

### 9.2.3.3.1 인덱스를 이용한 정렬

인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY 에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빌 테이블)에 속하고, ORDER BY 의 순서대로 생성된 인덱스가 있어야함.

또한 WHERE 절에 첫번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY 는 같은 인덱스를 사용할 수 있어야함.

```sql
mysql > SELECT *
			FROM employees e, salaries s
			WHERE s.emp_no=e.emp_no
				AND e.emp_no BETWEEN 100002 AND 100020
			ORDER BY e.emp_no;

--// emp_no 칼럼으로 정렬이 필요한데, 인덱스를 사용하면서 자용으로 정렬이 된다고
--// 일부러 ORDER BY emp_no 를 제거하는것은 좋지 않은 선택임.

mysql > SELECT *
			FROM employees e, salaries s
			WHERE s.emp_no=e.emp_no
				AND e.emp_no BETWEEN 100002 AND 100020
```

![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%203.png)

네스티드-루프 방식([https://coding-factory.tistory.com/756](https://coding-factory.tistory.com/756)) 으로 실행되기 때문에 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러 지지 않음

하지만 조인이 사용된 쿼리의 계획에 조인버퍼가 사용되면서 순서가 흐트러질 수 있기 때문에 주의해야함.

### 9.2.3.2 조인의 드라이빙 테이블만 정렬

조인에서 첫번째로 읽히는 테이블(드라이빙 테이블)의 컬럼만 ORDER BY 절로 작성 조인

```sql
mysql > SELECT *
				FROM employees e, salaries s
				WHERE s.emp_no=e.emp_no
			AND e.emp_no BETWEEN 100002 AND 100010
		ORDER BY e.last_name;
```

WHERE 절이 다음과 같이 2가지 조건을 갖추고 있기 때문에 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택한거임

- WHERE 절의 검색 조건(BETWEEN) 은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있음
- 드리븐 테이블의 조인 칼럼인 emp_no 칼럼에 인덱스가 있음.

---

다음과 같은 순서로 검색되었음

1. 인덱스를 이용해 emp_no BETWEEN 100001 AND 100010 조건을 만족하는 9건 검색
2. 검색결과를 last_name 칼럼으로 정렬을 수행
3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 86건의 최종결과를 가져옴

![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%204.png)

### 9.2.3.3.3 임시 테이블을 이용한 정렬

이 방법은 3가지 방법 가운데 정렬해야할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법임

```sql
mysql> SELECT *
			FROM employees e, salaries s
			WHERE s.emp_no=e.emp_no
				AND e,epm_no BETWEEN 100002 AND 100010
			ORDER BY s.salaray;
```

ORDER BY 의 기준이 드리븐 테이블에 있는 칼럼임

⇒ 정렬이 수행되기 전에 salaries 테이블을 읽어야 하므로 이 쿼리는 조인된 데이터를 가지고 정렬할 수 밖에 없음

실행계획 → Extra 칼럼에 “Using temporay; Using filesort” 라는 코멘트가 표시됨

![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%205.png)

### 9.2.3.3.4 정렬 처리 방법의 성능 비교

ORDER BY 나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수 만큼만 가져와서는 처리할 수 없음.

 조건을 만족하는 레코드를 **모두 가져와서 정렬을 수행**하거나 **그루핑 작업을 실행**해야만 비로소 LIMIT으로 건수를 제한 할 수 있음. WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생함.

쿼리에서 인덱스를 활용하지 못하거나 정렬이나 그루핑 작업이 왜 느리게 작동할 수 밖에 없는지 살펴볼 예정

쿼리가 처리되는 방식 2가지

- 스트리밍 처리
- 버퍼링 처리

### 9.2.3.3.4.1 스트리밍 방식

조건에 일치하는 레코드가 검색될때 마다 바로바로 클라이언트로 전송하는 방식임

스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답시간을 보장함

LIMIT 처럼 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줌

### 9.2.3.3.4.2 버퍼링 방식

ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과가 스트리밍 되는것을 불가능 하게함.

처리되는 쿼리는 먼저 결과를 모아서 MySQL서버에서 일괄 가공 해야 함.
모든 결과를 스토리지 엔진으로부터 가져올때까지 기다려야함.

LIMIT 처럼 결과 건수를 제한하는 조건이 있어도 성능향상에 별로 도움이 안됨,

MySQL 서버가 하는 작업량에는 그다지 변화가 없음

 

ORDER BY 의 3가지 처리방법

1. 인덱스 사용한 정렬 방식 ⇒ 스트리밍 형태의 처리
2. 조인테이블 드라이빙 테이블만 정렬, 임시테이블 이용한 정렬 ⇒ 버퍼링된 후 정렬

tb_test1 테이블 레코드 100건, tb_test2 테이블 레코드 1000건

(tb_test1 의 레코드 1건당 tb_test2 레코드 10건씩 존재한다고 가정)

(두 테이블 조인결과 1000 건의 건수 인경우)

```sql
mysql> SELECT * 
				FROM tb_test1 t1, tb_test t2
				WHERE t1.col1=t2.col1
				ORDER BY t1.col2
				LIMIT 10;
```

(tb_test1 이 드라이빙되는 경우)

| 정렬 방법 | 읽어야할 건수 | 조인 횟수 | 정렬해야할 대상 건수 |
| --- | --- | --- | --- |
| 인덱스 사용 | tb_test1: 1건
tb_test2: 10건 | 1번 | 0건 |
| 조인의 드라이빙 테이블만 정렬 | tb_test1: 100건
tb_test2: 10건 | 1번 | 100건
(tb_test1 테이블 레코드 건수 만큼 정렬 필요)
 |
| 임시 테이블 사용 후 정렬 | tb_test1: 100건
tb_test2: 1000건 | 100번
(tb_test1 테이블 레코드 건수 만큼 조인 발생) | 1000 건
(조인된 결과 레코드 건수를 전부 정렬해야함) |

(tb_test2 가 드라이빙되는 경우)

| 정렬 방법 | 읽어야할 건수 | 조인 횟수 | 정렬해야할 대상 건수 |
| --- | --- | --- | --- |
| 인덱스 사용 | tb_test2: 10건
tb_test1: 10건 | 10번 | 0건 |
| 조인의 드라이빙 테이블만 정렬 | tb_test2: 1000건
tb_test1: 10건 | 10번 | 1000건
(tb_test2 테이블 레코드 건수 만큼 정렬 필요)
 |
| 임시 테이블 사용 후 정렬 | tb_test2: 1000건
tb_test1: 100건 | 1000번
(tb_test2 테이블 레코드 건수 만큼 조인 발생) | 1000 건
(조인된 결과 레코드 건수를 전부 정렬해야함) |

가능하다면 인덱스를 사용한 정렬을 유도해야함.
그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법임

### 9.2.3.4 정렬 관련 상태 변수

정렬과 관련해서 지금가지 몇건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼간 병합 작업은 몇번 이나 발생했는지 등을 알수 있음

```sql
mysql > FLUSH STATUS;
mysql > SHOW STATUS LIKE 'Sort%';

--
Variable_name, Value
'Sort_merge_passes','0' 
'Sort_range','0'
'Sort_rows','696'
'Sort_scan','15'
```

- Sort_merge_pass : 멀티 머지 처리 횟수
- Sort_range : 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- Sort_scan : 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- Sort_rows : 지금까지 정렬한 전체 레코드 건수

### 9.2.4 GROUP BY 처리

GROUP BY 에 사용된 조건은 HAVING 절을 사용할 수 있으나 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요 없음.

GROUP BY 

- 인덱스 스캔
    
    인덱스를 이용하여 차례로 읽는 방법
    
- 루스 인덱스 스캔
    
    인덱스를 건너 뛰면서 읽는 방법
    
    인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용함.
    

### 9.2.4.1 인덱스 스캔을 이용한 GROUP BY (타이트 인덱스 스캔)

GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리함.

GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹함수(Aggregation function) 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있음.

쿼리 실행계획 Extra 칼럼에 GROUP BY 관련 코멘트 “Using index group-by” 나 임시테이블사용 또는 정렬 관련 코멘트 “Using temporary, Using filesort” 가 표시되지 **않음**

### 9.2.4.2 루스 인덱스 스캔을 이용한 GROUP BY

루스 인덱스 스캔

인덱스의 레코드를 건너 뛰면서 필요한 부분만 읽어서 가져오는것을 의미함

실행 계획 Extra 칼럼에 “Using index for group-by” 코멘트가 표시됨

---

예제)

salaries 테이블의 인덱스는 (emp_no, from_date) 로 생성되어 있음

```sql
mysql > EXPLAIN
			SELECT emp_no
			FROM salaries
			WHERE from_date='1985-03-01'
			GROUP BY emp_no;
```

레인지 인덱스를 사용할수 없는 쿼리이나, 실행계획은 레인지 스캔(range 타입) 을 이용하였음.

| id | table | type | key | Extra |
| --- | --- | --- | --- | --- |
| 1 | salaries | range | PRIMARY | Using where,
Using index for group-by |

쿼리가 실행된 순서

1. (emp_no, from_date) 인덱스를 차례대로 스캔 emp_no의 첫번째 유일한 값(그룹 키) “10001”을 찾아냄
2. (emp_no, from_date) 인덱스 에서 emp_no 가 ‘10001’ 인 것 중에서 from_date 값이 ‘1985-03-01’ 인 레코드만 가져옴 
    
    (emp_no = 10001 AND from_date=’1985-03-01’ 조건으로 (emp_no, from_date) 인덱스를 검색하는 것과 흡사함)
    
3. (emp_no, from_date) 인덱스 에서 emp_no의 그다음 유니크한(그룹키) 값을 가져옴
4. 3번 단계에서 결과가 더 없으면 처리를 종료, 결과가 있다면 2번 과정으로 돌아가서 반복 수행함

루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상됨
루스 인덱스 스캔으로 처리되는 쿼리에서 별도의 임시 테이블이 필요하지 않음

루스인덱스 스캔을 사용할 수 없는 쿼리 패턴

```sql
-- // MIN() 과 SUM() 이외의 집합함수가 사용됐기 때문에 루스 인덱스 스캔은 사용 불가
SELECT col1, SUM(col2) FROM tb_test GROUP BY col1;

-- // GROUP BY 에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않기 때문에 사용 불가
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

-- // SELECT 절의 칼럼이 GROUP BY 와 일치하지 않기 때문에 사용 불가
SELECt col1, col3 FROM tb_test GROUP BY col1, col2;
```

### 9.2.4.3 임시 테이블을 사용하는 GROUP BY

GROUP BY 의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 **인덱스를 전혀 사용하지 못할때**는 임시테이블을 사용함.

```sql
mysql > EXPLAIN
					SELECT e.last_name, AVG(s.salary)
					FROM employees e, salaries s
					WHERE s.emp_no=e.emp_no
					GROUP BY e.last_name;
```

| id | table | type | key | rows | Extra |
| --- | --- | --- | --- | --- | --- |
| 1 | e | ALL | NULL | 300584 | Using temporary |
| 1 | s | ref | PRIMARY | 10 | NULL |

8.0 이전에는 GROUP BY 사용된 쿼리는 묵시적인 정렬을 수행했지만 8.0 이후부터는 묵시적인 정렬이 더 이상 실행되지 않음 (Using filesort 가 없음)

GROUP BY 가 필요한 경우 내부적으로 GROUP BY 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블로 만들어서 중복 제거와 집합 함수 연산을 수행함.

즉, 위의 쿼리를 처리하기 위해 MySQL 서버는 다음과 같은 임시테이블을 생성함
조인 결과를 한건씩 가져와 임시 테이블에서 중복체크를 하면서 INSERT 또는 UPDATE 를 실행함.
별도의 정렬 작업 없이 GROUP BY 가 처리됨

```sql
CREATE TEMPORARY TABLE ... (
	last_name VARCHAR(16),
	salary INT,
	UNIQUE INDEX ux_lastname (last_name)
);
```

하지만, 동일한 쿼리에 ORDER BY 절을 추가한 경우 실행계획 Extra 칼럼에 “Using filesort” 표시됨을 확인할 수 있음

### 9.2.5 DISTINCT 처리

두 가지로 구분됨

- 집합 함수가 있는 경우 - MIN(), MAX(), COUNT()
- 집합 함수가 없는경우

구분하는이유?

DISTINCT 키워드가 영향을 미치는 범위가 달라지기 때문임.

집합 함수와 같이 DISTINCT 가 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할때는 임시테이블이 필요함.  하지만 실행계획 Extra 칼럼에는 “Using temporary” 메시지가 출력되지 않음

### 9.2.5.1 SELECT DISTINCT …

단순히 SELECT 되는 레코드 중에서 유니크한 레코드만 가져오고자 한다면 GROUP BY 와 동일한 방식으로 처리됨

```sql
mysql > SELECT DISTINCT emp_no FROM salaries;
mysql > SELECT emp_no FROM salaries GROUP BY emp_no;
```

SELECT 절에 사용된 DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미침

절대로 SELECT 하는 여러 칼럼중 일부 칼럼만 유니크하게 조회하는게 아님.

자주 하는 실수 및 오해

```sql
-- // (first, last_name) 조합 전체의 유니크한 레코드를 가져옴
mysql > SELECT DISTINCT first_name, lastname FROM employees;

-- // DISTINCT 는 뒤의 괄호를 그냥의미없이 사용될 괄호로 해석하고 제거해버림
mysql > SELECT DISTINCT (first_name), last_name FROM employees;
mysql > SELECT DISTINCT first_name, lastname FROM employees;
```

### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT

집합함수가 없는 SELECT 쿼리에서 DISTINCT 는 조회하는 **모든 칼럼의 조합**이 유니크한 것들만 가져옴

집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 **칼럼값이** 유니크한 것들을 가져옴

```sql
mysql > EXPLAIN SELECT COUNT(DISTINCT s.salary)
			FROM employees e, salaries s
			WHERE e.emp_no=s.emp_no
			AND e.emp_no BETWEEN 100001 AND 100100;
```

| id | table | type | key | rows | Extra |
| --- | --- | --- | --- | --- | --- |
| 1 | e | range | PRIMARY | 100 | Using where;
 Using index |
| 1 | s | ref | PRIMARY | 10  | NULL |

임시 테이블을 사용하나 메세지에 표시되지 않음

employees 테이블과 salaries 테이블을 조인한 결과에서
salary 칼럼의 값만 저장 하기 위한 임시 테이블을 만들어서 사용함

count 함수가 두번 사용된 쿼리

s.salary 칼럼의 값을 저장하는 임시테이블,  e.last_name 칼럼의 값을 저장하는 임시테이블 생성

2개의 임시테이블을 사용함.

```sql
mysql > EXPLAIN COUNT(DISTINCT s.salary),
							COUNT(DISTINCT e.last_name)
			FROM employees e, salaries s
			WHERE e.emp_no=s.emp_no
				AND e.emp_no BETWEEN 100001 AND 100100;
```

| id | table | type | key | rows  | Extra |
| --- | --- | --- | --- | --- | --- |
| 1 | dept_emp | index | PRIMARY | 331143 | Using index |

### 9.2.6 내부 임시 테이블 활용

**MySQL 엔진이 스토리지 엔진으로 부터 받아온 레코드를 정렬하거나 그루핑 할때는 내부적인 임시테이블을 사용함.**

임시테이블의 “CREATE TEMPOPRARY TABLE” 과는 다름

일반적으로 MySQL 엔진이 사용하는 (내부)임시 테이블은 처음에는 메모리에 생성됐다가 테이블 크기가 커지면 디스크로 옮겨짐, 특정 예외 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 함

MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며, 사용할 수 도 없음

**내부 임시 테이블**은 쿼리의 처리가 완료되면 자동적으로 삭제됨

### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

Mysql 8.0 

메모리는 TempTable 이라는 스토리지 엔진을 사용함. 

(MEMORY 스토리지 엔진은 트랜잭션을 지원하지 못하고, 가변길이 타입을 지원하지 못함)

디스크에 저장되는 임시 테이블은 innoDB 스토리지 엔진을 사용하도록 개선됨

internal_tmp_mem_storage_engin

- 메모리용 임시 테이블을 MEMORY 와 TempTable 중에서 선택할 수 있게 하고 있음(기본값 TempTable)

temptable_max_ram

- TempTable 이 최대한 사용 가능한 메모리 공간의 크기를 설정 (기본값 1GB)

디스크 저장방식 2가지 있음 (temptable_use_mmap 으로 설정 가능함)

- MMAP 파일로 디스크에 기록
- InnoDB 테이블로 기록

1GB 가 넘어가면 메모리 파일을 MMPAM 파일로 전환하여 디스크에 저장함

⇒ InnoDB 테이블로 전환하는 것보다 오버헤드가 적음

처음부터 디스크 테이블로 생성되는 경우는 InnoDB 에 저장됨

- internal_tmp_disk_strorage_engin 시스템 변수로 설정

### 9.2.6.2 임시 테이블이 필요한 쿼리

- ORDER BY 와 GROUP BY 에 명시된 칼럼이 다른 쿼리
- ORDER BY 나 GROUP BY 에 명시된 칼럼이 조인의 순서상 첫번째 테이블이 아닌 쿼리
- DISTINCT 와 ORDER BY 가 동시에 쿼리가 존재하는 경우 또는 DISTINCT 가 인덱스로 처리되지 못하는 쿼리
- UNION 이나 UNION DISTINCT가 사용된 쿼리
    
    ⇒ 1~4 유니크 인덱스를 가지는 내부 임시 테이블이 만들어짐
    
- 쿼리의 실행 계획에서 select_type 이 DERIVED 인 쿼리
    
    ⇒ 유니크 인덱스가 없는 내부 임시 테이블이 생성됨
    

실행계획 Extra 칼럼에 “Using temporay” 라는 메세지가 표시됨

### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

- UNION 이나 UNION ALL 에서 SELECT 되는 칼럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY 나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 (TempTable 스토리지 엔진) temptable_max_ram 시스템 변수보다 클경우
    
     (MEMORY 스토리지 엔진인경우) tmp_table_size 또는 max_heap_table_size 시스템 변수보다 큰경우
    

### 9.2.6.4 임시 테이블 관련 상태 변수

임시 테이블이 디스크에 생성됐는지 메모리에 생성 됐는지 확인하려면

MySQL 서버의 상태 변수 를 확인해 보면 됨

```sql
-- 현재 세션의 상태값을 초기화
mysql > FLUSH STATUS;

mysql > SELECT first_name, last_name
				FROM employees
				GROUP BY first_name, last_name;

mysql > SHOW SESSION STATUS LIKE 'Created_tmp%';

--//
Variable name, value
Created_tmp_disk_tables , 1
Created_tmp_tables, 1
```

Created_tmp_tables : 내부 임시 테이블의 개수의 누적값

Created_tmp_disk_tables : 디스크에 내부 임시 테이블이 만들어진 개수의 누적값

### 9.3 고급 최적화

MySQL 서버의 옵티마이저 옵션은 크게
`조인 관련된 옵티마이저 옵션`과`옵티마이저 스위치`로 구분할 수 있다.

조인 옵티마이저 옵션은 MySQL 서버 초기부터 제공되던 옵션이지만
많은 사용자가 신경 쓰지 않는 편이다.

하지만 조인이 많이 사용되는 서비스에서는 알아야 하는 옵션이기도 하다.

옵티마이저 스위치는 MySQL 5.5 버전부터 지원하기 시작했는데
이는 MySQL 서버의 고급 최적화 기능들을 활성화할지를 제어하는 용도로 사용된다.

### 9.3.1 옵티마이저 스위치 옵션

옵티마이저 스위치 옵션은 `optimizer_switch`시스템 변수를 이용해서 제어하고,
여러 개의 옵션을 세트로 묶어 설정하는 방식으로 사용한다.

![optimizer_switch 시스템 변수에 설정할 수 있는 최적화 옵션](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%206.png)

optimizer_switch 시스템 변수에 설정할 수 있는 최적화 옵션

옵티마이저 스위치 옵션은 글로벌과 세션 모두 설정할 수 있는 시스템 변수이므로
MySQL 서버 전체 또는 현재 커넥션에 대해서 아래와 같이 설정할 수 있다.

```sql
mysql> SET GLOBAL optimizer_switch='index_merge=on,index_merge_union=on,...';

mysql> SET SESSION optimizer_switch='index_merge=on,index_merge_union=on,...';
```

또한 아래와 같이 `SET_VAR`옵티마이저 힌트를 이용해 현재 쿼리에만 설정할 수도 있다.

```sql
mysql> SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */
			 ...
```

- 9.3.1.1 MRR과 배치 키 액세스(mrr & batched_key_access)
    
    MMR은 Multi-Range Read를 줄여 부르는 이름인데
    매뉴얼에서는 DS-MMR(Disk Sweep..)이라고도 한다.
    
    MySQL 서버에서 지금까지 지원하던 조인 방식은 드라이빙 테이블의 레코드를
    한 건 읽어 드리븐 테이블의 일치하는 레코드를 찾아 조인을 수행하는 것이었다.
    이를 **네스티드 루프 조인**(Nested Loop Join)이라고 한다.
    
    MySQL 서버의 내부 구조상 조인 처리는 MySQL 엔진이 처리하지만
    실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다.
    
    이 때 드라이빙 테이블의 레코드 건 별로 드리븐 테이블의 레코드를 찾으면
    스토리지 엔진에서는 아무런 최적화를 수행할 수 없다.
    
    이 같은 단점을 보완하기 위해 MySQL 서버는 조인 대상 테이블 중
    하나로부터 레코드를 읽어 조인 버퍼에 버퍼링한다.
    
    즉, 드라이빙 테이블의 레코드를 읽어 드리븐 테이블과의 조인을
    즉시 실행하지 않고 조인 대상을 버퍼링하는 것이다.
    
    조인 버퍼에 레코드가 가득 차면 MySQL 엔진은
    버퍼링된 레코드를 스토리지 엔진으로 한번에 요청한다.
    
    이렇게 함으로써 스토리지 엔진은 읽어야 할 레코드를 데이터 페이지에
    정렬된 순서로 접근해 디스크의 데이터 페이지 읽기를 최소화할 수 있는 것이다.
    
    물론 데이터 페이지가 메모리(InnoDB 버퍼 풀)에 있다고 해도
    버퍼 풀의 접근을 최소화할 수 있다는 것이다.
    
    이러한 읽기 방식을 **MMR**이라고 하며 MMR을 응용해 실행되는 조인 방식을 **BKA**(Batched Key Access) 조인이라고 한다.
    
    BKA 조인 최적화는 기본적으로 비활성화돼 있는데
    이는 BKA 조인의 단점이 존재하기 때문이다.
    
    쿼리의 특성에 따라 BKA 조인이 큰 도움이 되는 경우도 있지만 BKA 조인을 사용하면
    부가적인 정렬 작업이 필요해지면서 오히려 성능에 악영향을 끼칠 수도 있다.
    
- 9.3.1.2 블록 네스티드 루프 조인(block_nested_loop)
    
    MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인인데
    조인의 연결 조건이 되는 컬럼에 모두 인덱스가 존재하는 경우 사용되는 조인 방식이다.
    
    아래 예제 쿼리는 employees 테이블에서 first_name 조건에 일치하는 레코드 1건을 찾아 salaries 테이블의 일치하는 레코드를 찾는 형태의 조인을 실행한다.
    
    ```sql
    mysql> EXPLAIN
    				 SELECT *
    				 FROM employees e
    					 INNER JOIN salaries s ON s.emp_no=e.emp_no
    											AND s.from_date<=NOW()
    											AND s.to_date>=NOW()
    				 WHERE e.first_name='Amor';
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%207.png)
    
    이러한 형태의 조인은 아래와 같이 중첩된 반복 명령을 사용하는 것처럼
    작동한다고 해서 네스티드 루프 조인이라고 한다.
    
    아래를 보면 레코드를 읽고 버퍼 공간에 저장하지 않은 채로
    드리븐 테이블의 레코드를 찾아 반환한다는걸 알 수 있다.
    
    ```ruby
    for(row1 IN employees) {
    	for(row2 IN salaries) {
    		if(condition_matched) return (row1, row2);
    	}
    }
    ```
    
    네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼의
    사용여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되냐다.
    
    조인 알고리즘에서 보통 Block 이라는 단어가 사용되면
    조인용으로 별도의 버퍼가 사용됐다는 것을 의미하는데
    
    조인 쿼리의 실행 계획에서 Extra 컬럼에 `Using Join buffer` 라는 문구가 표시되면
    그 실행 계획은 조인 버퍼를 사용한다는 것을 의미한다.
    
    만약 조인에서 드리븐 테이블의 조인 조건이 인덱스를 사용할 수 없다면
    드리븐 테이블에서 연결되는 레코드를 찾기 위해
    1000번(드라이빙 테이블 레코드 건수)의 풀 테이블 스캔을 해야한다.
    
    그래서 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리가 상당히
    느려지고 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를
    사용할 수 있게 실행 계획을 수립한다.
    
    하지만 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을
    피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에(조인 버퍼) 캐시하고 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다.
    
    조인 버퍼는 `join_buffer_size`라는 시스템 변수로 크기를 제한할 수 있으며
    조인이 완료되면 조인 버퍼는 바로 해제된다.
    
    두 테이블이 조인되는 아래 예제에서 각 테이블에 대한 조건은 WHERE 절에 있지만
    두 테이블 간의 연결 고리 역할을 하는 조인 조건은 없다.
    
    그래서 dept_emp 테이블에서 from_date>’2000-01-01’ 인 레코드(10616건)와
    employees 테이블에서 emp_no<109004 조건을 만족하는 레코드(99003건)는
    카테시안 조인을 수행한다.
    
    ```sql
    mysql> SELECT *
    			 FROM dept_emp de, employees e
    			 WHERE de.from_date>'1995-01-01' ANMD e.emp_no<109004;
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%208.png)
    
    위 쿼리의 실행 계획을 살펴보면 dept_emp 테이블이 드라이빙 테이블이고
    employees 테이블을 읽을 때 조인 버퍼를 이용해
    블록 네스티드 루프 조인을 한다는걸 알 수 있다.
    
    아래는 위 쿼리의 실행 계획에서 조인 버퍼가 어떻게 사용되는지를 보여준다.
    
    ![그림 9.9 조인 버퍼를 사용하는 조인(Block Nested Loop)](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%209.png)
    
    그림 9.9 조인 버퍼를 사용하는 조인(Block Nested Loop)
    
    1. dept_emp 테이블의 ix_fromdate 인덱스를 이용해
    from_date>’1995-01-01’ 조건을 만족하는 레코드를 검색한다.
    2. 조인에 필요한 나머지 컬럼을 모두
    dept_emp 테이블로부터 읽어 조인 버퍼에 저장한다.
    3. employees 테이블의 프라이머리 키를 이용해
    emp_no<109004 조건을 만족하는 레코드를 검색한다.
    4. 3번에서 검색된 결과에 2번의 캐시된 조인 버퍼의 레코드를 결합해 반환한다.
    
    위 그림에서 중요한 점은 조인 버퍼가 사용되는 쿼리에서는
    조인 순서가 거꾸로인 것처럼 실행된다는 것이다.
    
    위에서 설명한 절차의 4번 단계가 employees 테이블의 결과를 기준으로
    dept_emp 테이블의 결과를 병합한다는 것을 의미한다.
    
    실제 쿼리 실행 계획상으론 dept_emp 테이블이 드라이빙 테이블이 되고
    employees 테이블이 드리븐 테이블이 된다.
    하지만 실제 드라이빙 테이블의 결과는 조인 버퍼에 담아두고
    드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.
    
    일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 의해
    결정되지만 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가
    흐트러질 수 있음을 기억해야 한다.
    
    > MySQL 8.0.18 버전부터는 해시 조인 알고리즘이 도입됐으며
    8.0.20 버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고
    해시 조인 알고리즘이 대체되어 사용되기 때문에
    Extra 컬럼에 Using Join Buffer (block nested loop) 메세지가 표시되지 않을 수 있다.
    > 
- 9.3.1.3 인덱스 컨디션 푸시다운(index_condition_pushdown)
    
    MySQL 5.6 버전부터는 인덱스 컨디션 푸시다운(Index Condition Pushdown)이라는
    기능이 도입됐다.
    
    사실 인덱스 컨디션 푸시다운은 너무 비효율적이어서
    이미 오래 전부터 개선됐어야 할 기능이지만 이제서야 보완된 것이다.
    
    아래는 인덱스 컨디션 푸시다운 기능을 비활성화한 상태와 활성화한 상태의
    실행계획 차이를 보여주는 예제다.
    
    인덱스 컨디션 푸시다운 기능 비활성화
    
    ```sql
    mysql> ALTER TABLE employees ADD INDEX ix_lastname_firstname (last_name, first_name);
    
    mysql> SET optimizer_switch='index_condition_pushdown=off';
    mysql> SHOW VARIABLES LIKE 'optimizer_switch' \G
    Variable_name : optimizer_switch
    				Value : ...,index_condition_pushdown=off,...
    ```
    
    ```sql
    mysql> SELECT * FROM employees WHERE last_name='Acton' AND first_name LIKE '%sal';
    ```
    
    위와 같은 쿼리를 실행할 때 스토리지 엔진이 몇 건의 레코드를 읽는지 살펴보자.
    
    last_name=’Acton’ 조건은 위에서 생성한
    ix_last_name_firstname 인덱스를 레인지 스캔으로 사용 가능하지만
    first_name LIKE ‘%sal’ 조건은 인덱스 레인지 스캔으로는 인덱스의 범위를 좁힐 수 없다.
    
    그래서 위 쿼리에서 last_name 조건은 인덱스 레인지 스캔 조건,
    first_name 조건은 필터링 조건으로만 사용된다.
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2010.png)
    
    위 쿼리의 실행 계획을 확인해 보면 Extra 컬럼에
    Using where 이 표시된 것을 확인할 수 있다.
    
    여기서 Using where 은 InnoDB 스토리지 엔진이 읽어 반환한 레코드가
    인덱스를 사용할 수 없는 WHERE 조건에 일치하는지 검사하는 과정을 의미한다.
    → 이 쿼리에서는 first_name 조건이 검사 과정에 사용된다.
    
    ![그림 9.10 인덱스 컨디션 푸시다운이 작동하지 않을 때](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2011.png)
    
    그림 9.10 인덱스 컨디션 푸시다운이 작동하지 않을 때
    
    위 그림은 last_name 조건으로 인덱스 레인지 스캔을 하고
    first_name 조건에 부합하는지 여부를 비교하는 과정을 그림으로 표현한 것이다.
    
    성능과 큰 관계가 없어보이지만 예를 들어 last_name 조건에 부합하는 레코드는 10만 건,
    first_name 조건에 부합하는 레코드는 1건 이라면
    이 경우 99,999건의 레코드 읽기가 불필요한 작업이 되어버린다.
    
    하지만 여기서 한 번 더 생각하면 first_name 조건을 처리하기 위해
    이미 읽은 ix_lastname_firstname 인덱스의 first_name 컬럼을 사용하지 않고
    다시 테이블의 레코드를 읽어 처리했는지 궁금할 것이다.
    
    인덱스의 first_name 컬럼을 이용했다면 불필요한 2건의 레코드는
    테이블에서 읽지 않아도 됬을텐데 말이다.
    
    사실 인덱스에 포함된 컬럼을 사용할지 테이블의 컬럼을 사용할지는
    first_name 조건을 누가 처리하느냐에 따라 결정된다.
    
    위 그림에서 인덱스를 비교하는 작업은 InnoDB 스토리지 엔진이 수행하지만
    테이블의 레코드에서 first_name 조건을 비교하는 작업은
    MySQL 엔진이 수행하는 작업이다.
    
    그런데 MySQL 5.5 버전까지는 인덱스를 범위 제한 조건으로 사용하지 못하는
    first_name 조건은 MySQL 엔진이 스토리지 엔진으로 아예 전달해주지 않았다.
    그래서 스토리지 엔진에서는 불필요한 테이블 읽기를 수행할 수 밖에 없던 것이다.
    
    ![그림 9.11 인덱스 컨디션 푸시다운](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2012.png)
    
    그림 9.11 인덱스 컨디션 푸시다운
    
    MySQL 5.6 버전부터는 위 예제처럼 인덱스를 범위 제한 조건으로 사용하지 못해도
    위 그림처럼 인덱스에 포함된 컬럼의 조건이 존재하면
    전부 모아 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선됐다.
    
    처음에 수정했던 옵티마이저 옵션을 롤백하고 실행 계획을 살펴보자.
    
    ```sql
    mysql> SET optimizer_switch='index_condition_pushdown=on';
    mysql> SHOW VARIABLES LIKE 'optimizer_switch' \G
    Variable_name : optimizer_switch
    				Value : ...,index_condition_pushdown=on,...
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2013.png)
    
    위와 같이 옵티마이저 스위치에서 index_condition_pushdown 을 활성화하고
    실행 계획을 확인해보면 Extra 컬럼에 Using where 이 없어지고
    Using index condition 이 출력되는 것을 확인할 수 있다.
    
    사실 인덱스 컨디션 푸시다운 기능은 고도의 기술력을 필요로 하는 기능은 아니다.
    하지만 쿼리의 성능을 몇 배~몇십 배로 향상시킬 수도 있는 중요한 기능이다.
    
- 9.3.1.4 인덱스 확장(use_index_extensions)
    
    use_index_extensions 옵티마이저 옵션은 InnoDB 스토리지 엔진을
    사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된
    프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.
    
    [8.8절 클러스터링 인덱스](Chapter%2008%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%20c110ec3c38054747ab9cde4320f79759.md)에서 살펴본 것처럼 InnoDB 스토리지 엔진은
    프라이머리 키를 클러스터링 키로 생성한다.
    
    그래서 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가진다.
    예를 들어 아래와 같은 프라이머리 키와 세컨더리 인덱스를 가진 테이블을 가정해본다.
    
    ```sql
    mysql> CREATE TABLE dept_emp (
    				 emp_no INT NOT NULL,
    				 dept_no CHAR(4) NOT NULL,
    				 from_date DATE NOT NULL,
    				 to_date DATE NOT NULL,
    				 PRIMARY KEY (dept_no, emp_no),
    				 KEY ix_fromdate (from_date)
    			 ) ENGINE=InnoDB;
    ```
    
    위 예제에서 프라이머리 키는 (dept_no, emp_no) 이며,
    세컨더리 인덱스 ix_fromdate는 from_date 컬럼만 포함한다.
    
    그런데 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키인
    dept_no 와 emp_no 컬럼을 순서대로 포함한다.
    
    그래서 최종적으로 ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로
    인덱스를 생성한 것과 비슷하게 작동할 수 있게 된다.
    
    예전 MySQL 버전에서는 위와 같은 쿼리가 세컨더리 인덱스의
    마지막에 자동 추가되는 프라이머리 키를 제대로 활용하지 못했지만
    MySQL 서버가 업그레이드되면서 옵티마이저는 ix_fromdate 인덱스의 마지막에
    (dept_no, emp_no) 컬럼이 숨어있다는걸 인지하고 실행 계획을 수립하도록 개선됐다.
    
    ```sql
    mysql> EXPLAIN SELECT COUNT(*) FROM dept_emp WHERE from_date='1987-07-25' AND dept_no='d001';
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2014.png)
    
    위 실행 계획의 key_len 컬럼은 쿼리가 인덱스를 구성하는 컬럼 중에서
    어느 부분까지 사용했는지를 바이트 수로 보여주는데
    19바이트가 표시된 것을 보면 from_date 컬럼(3바이트)과
    dept_emp 컬럼(16바이트)까지 사용했다는 것을 알 수 있다.
    
    ```sql
    mysql> EXPLAIN SELECT COUNT(*) FROM dept_emp WHERE from_date='1987-07-25' ORDER BY dept_no;
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2015.png)
    
    위 실행 계획을 보면 InnoDB의 프라이머리 키가 세컨더리 인덱스에 포함돼 있으므로
    정렬 작업도 인덱스를 활용해 처리되는 장점이 있다는 것을 볼 수 있다.
    
    Extra 컬럼에 Using Filesort가 표시되지 않았다는 것은
    MySQL 서버가 별도의 정렬 작업 없이 인덱스 순서대로 레코드를 읽기만 함으로써
    ORDER BY 를 만족했다는 것을 의미한다.
    
- 9.3.1.5 인덱스 머지(index_merge)
    
    인덱스를 이용해 쿼리를 실행하는 경우 대부분 옵티마이저는
    테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다.
    
    하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해
    2개 이상의 인덱스를 이용해 쿼리를 처리한다.
    
    쿼리에서 한 테이블에 대한 WHERE 조건이 여러 개 있더라도
    하나의 인덱스에 포함된 컬럼에 대한 조건만으로 인덱스를 검색하고
    나머지 조건은 읽어온 레코드에 대해 체크하는 형태로만 사용되는 것이 일반적이다.
    
    이렇게 하나의 인덱스만 사용해 작업 범위를 충분히 줄일 수 있는 경우라면
    하나의 인덱스만 사용하는 것이 효율적이지만
    쿼리의 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고
    그 조건을 만족하는 레코드 건수가 많을 것으로 예상되는 경우
    MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
    
    인덱스 머지 실행 계획은 아래와 같이 3개의 세부 실행 계획으로 나눠 볼 수 있다.
    
    3가지 방법 모두 여러 개의 인덱스를 통해 결과를 가져온다는 것은 동일하지만
    각각의 결과를 **어떤 방식으로 병합**할지에 따라 구분된다.
    
- 9.3.1.6 인덱스 머지 - 교집합(index_merge_intersection)
    
    ```sql
    mysql> EXPLAIN SELECT *
    			 FROM employees
    			 WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000; 
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2016.png)
    
    위 쿼리는 2개의 WHERE 조건을 갖고 있고 employees 테이블의
    first_name 컬럼과 emp_no 컬럼 모두 각각의 인덱스(PK)를 가지고 있다.
    
    즉 2개 중 어떤 조건을 사용해도 인덱스를 사용할 수 있다는 뜻이다.
    
    그에 따라 옵티마이저는 ix_firstname과 PK를 모두 사용해서
    쿼리를 처리하기로 결정한다.
    
    실행 계획의 Extra 컬럼에 Using intersect 라고 표시된 것은 이 쿼리가
    여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환했다는 것을 의미한다.
    
    ```sql
    mysql> SELECT COUNT(*) FROM employees WHERE first_name='Georgi';
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2017.png)
    
    ```sql
    mysql> SELECT COUNT(*) FROM employees WHERE emp_no BETWEEN 10000 AND 20000;
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2018.png)
    
    인덱스 머지 실행 계획이 아니었다면 위 예제처럼 2가지 방식으로 처리해야 했을 것이다.
    
    - first_name 조건만 인덱스를 사용했다면 일치하는 레코드 253건을 검색한 다음
    데이터 페이지에서 레코드를 찾고 emp_no 컬럼의 조건에 일치하는 레코드들만 반환하는
    형태로 처리돼야 한다.
    - emp_no 조건만 인덱스를 사용했다면 프라이머리 키를 이용해 10,000건을 읽어와 first_name 조건에 일치하는 레코드만 반환하는 형태로 처리돼야 한다.
    
    대략 생각해보면 첫 번째 두 번째 방법 모두 나쁘지 않은 실행 계획이 될 것 같지만
    왜 옵티마이저는 두 인덱스의 교집합만 가져오는 실행 계획을 세웠을까?
    
    ```sql
    mysql> SELECT COUNT(*) FROM employees
    			 WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2019.png)
    
    위 결과를 보면 실제로 두 조건을 모두 만족하는 레코드는 14건밖에 안 된다.
    
    즉 ix_firstname 인덱스만 사용했다면 253번의 데이터 페이지 읽기를 하지만
    실질적으로 의미있는 작업은 겨우 14번이었을 것이고
    PK만 사용했다면 10,000건을 읽어 9,986건은 버리고 14건만 반환하는 작업이 됐을 것이다.
    
    ```sql
    -- // MySQL 서버 전체적으로 index_merge_intersection 최적화 비활성화
    mysql> SET GLOBAL optimizer_switch='index_merge_intersection=off';
    
    -- // 현재 커넥션에 대해 index_merge_intersection 최적화 비활성화
    mysql> SET SESSION optimizer_switch='index_merge_intersection=off';
    
    -- // 현재 쿼리에서만 index_merge_intersection 최적화 비활성화
    mysql> EXPLAIN
    			 SELECT /*+ SET_VAR(optimizer_switch='index_merge_intersection=off') */ *
    			 FROM employees
    			 WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2020.png)
    
    그런데 ix_firsname 인덱스는 PK인 emp_no 컬럼을 자동으로 포함하고 있기에
    ix_firstname 인덱스만 사용하는 것이 더 성능이 좋을거라고 생각할 수 있다.
    
    그렇다면 위와 같이 index_merge_intersection 최적화를 비활성화하면 된다.
    
- 9.3.1.7 인덱스 머지 - 합집합(index_merge_union)
    
    인덱스 머지의 Using union 은 WHERE 절에 사용된 2개 이상의 조건이
    각각의 인덱스를 사용하되 OR 연산자로 연결된 경우 사용하는 최적화다.
    
    ```sql
    mysql> SELECT *
    			 FROM employees
    			 WHERE first_name='Matt' OR hire_date='1987-03-31';
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2021.png)
    
    위 예제 쿼리를 보면 employees 테이블에는 first_name 컬럼과 hire_date 컬럼에 각각
    ix_firstname 인덱스와 ix_hiredate 가 준비돼 있다.
    
    그래서 first_name 조건과 hire_date 조건이 각각의 인덱스를 사용할 수 있다.
    이 쿼리의 실행계획은 위와 같이 Using union 최적화를 사용한다.
    
    실행 계획에서 볼 수 있듯 Extra 컬럼에 Using union(ix_firstname, ix_hiredate)로 표시되는데
    이는 인덱스 머지 최적화가 ix_firstname 인덱스의 검색 결과와 ix_hiredate 인덱스 검색결과를
    Union 알고리즘으로 병합(합집합)했다는 것을 의미한다.
    
    위 예제에서 first_name 조건과 hire_date 조건을 만족하는 사원이 있었다면
    그 사원의 정보는 ix_firstname 인덱스를 검색한 결과에도 포함되어 있을 것이고
    ix_hiredate 인덱스를 검색한 결과에도 포함되어 있을 것이다.
    
    하지만 위 쿼리의 결과에서는 조건을 만족하는 사원의 데이터가 중복으로 출력되지는 않는다.
    그렇다면 MySQL 서버가 두 결과 집합을 정렬해 중복 레코드를 제거했다는 말이 되는데
    실행 계획에는 정렬을 했다는 표시가 존재하지 않는다.
    
    ![그림 9.12 인덱스 머지(Using union)](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2022.png)
    
    그림 9.12 인덱스 머지(Using union)
    
    위 그림에서도 알 수 있듯 first_name 컬럼의 검색 결과와 hire_date 컬럼의 검색 결과에서 사원 번호가 13163인 사원은 양쪽 집합에 모두 포함돼 있어 반드시 제거해야 한다.
    
    하지만 MySQL 서버는 first_name 조건을 검색한 결과와 hire_date 컬럼을 검색한 결과가 프라이머리 키로 이미 각각 정렬돼 있다는 것을 알고 있다.
    
    ```sql
    mysql> SELECT * FROM employees WHERE first_name='Matt';
    mysql> SELECT * FROM employees WHERE hire_date='1987-03-31';
    ```
    
    예제 쿼리를 위 처럼 각각 분리해 실행해도 인덱스 검색을 통한 두 결과 집합이
    모두 PK로 정렬돼 있다는 것을 쉽게 확인할 수 있다.
    
    그래서 MySQL 서버는 두 집합에서 하나씩 가져와 서로 비교하면서 PK인 emp_no 컬럼의 값이
    중복된 레코드들을 정렬 없이 걸러낼 수 있는 것이다.
    
    이렇게 정렬된 두 집합의 결과를 하나씩 가져와 중복제거를 수행할 때 사용된 알고리즘을
    우선순위 큐(Priority Queue)라고 한다.
    
- 9.3.1.8 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
    
    Union 알고리즘은 중복 데이터를 제거하기 위해 정렬된 결과를 필요로 하지만
    정렬을 수행하지 않고 중복 제거를 한다는 사실을 알 수 있었다.
    
    하지만 모든 경우가 그럴 수 있는 것은 아니다.
    만약 인덱스 머지 작업 도중 정렬 작업이 필요하다면 MySQL 서버는
    인덱스 머지 최적화의 Sort union 알고리즘을 사용한다.
    
    ```sql
    mysql> EXPLAIN
    				 SELECT * FROM employees
    				 WHERE first_name='Matt'
    						OR hire_date BETWEEN '1987-03-01' AND '1987-03-31';
    ```
    
    위 쿼리를 두 개의 쿼리로 분리해 생각해보자.
    
    ```sql
    mysql> SELECT * FROM employees WHERE first_name='Matt';
    mysql> SELECT * FROM employees WHERE hire_date BETWEEN '1987-03-01' AND '1987-03-31';
    ```
    
    첫 번째 쿼리는 결과가 emp_no 로 정렬되어 출력되지만
    두 번째 쿼리는 emp_no 컬럼으로 정렬되어있지 않은 채로 출력되는 것을 알 수 있다.
    
    즉 위 예제의 결과에서는 중복을 제거하기 위해 우선순위 큐를 사용하는 것이 불가능하다.
    
    그래서 MySQL 서버는 두 집합의 결과에서 중복을 제거하기 위해
    각 집합을 emp_no 컬럼으로 정렬한 후 중복 제거를 수행한다.
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2023.png)
    
    위 실행 계획을 보면 인덱스 머지 최적화에서 중복 제거를 위해 강제로 정렬을 수행해야 하는 경우
    실행 계획의 Extra 컬럼에 Using sort_union 문구가 표시된다.
    

- 9.3.1.9 세미 조인(semijoin)
    
    다른 테이블과 실제 조인을 수행하지 않고 다른 테이블에서 조건에 부합하는
    레코드가 있는지 없는지 체크하는 형태의 쿼리를 세미 조인(Semi-Join)이라고 한다.
    
    MySQL 5.7 은 전통적으로 세미 조인 형태의 쿼리를 최적화하는 부분이 상당히 취약했다.
    
    ```sql
    mysql> SELECT *
    			 FROM employees e
    			 WHERE e.emp_no IN
    					 (SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01');
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2024.png)
    
    일반적으로 다른 RDBMS 에 익숙한 사용자였다면
    dept_emp 테이블을 조회하는 서브쿼리 부분이 먼저 실행되고
    그 다음 employees 테이블에서 일치하는 레코드만 검색할 것으로 기대했겠지만
    
    MySQL 서버는 위 실행 계획처럼 employees 테이블을 풀 스캔하고
    한 건씩 서브쿼리 조건에 일치하는지 비교한다.
    
    세미 조인 형태의 쿼리와 안티 세미 조인 형태의 쿼리는 최적화 방법에 차이가 있다.
    
    1. [세미 조인] = (subquery) || IN (subquery)
        1. 세미 조인 최적화
        2. IN-to-EXISTS 최적화
        3. MATERIALIZATION(구체화) 최적화
    2. [안티 세미 조인] <> (subquery) || NOT IN (subquery)
        1. IN-to-EXISTS 최적화
        2. MATERIALIZATION(구체화) 최적화
    
    아래는 MySQL 8.0 버전부터 추가된 최적화 전략이다.
    
    - Table Pull-out
    - Duplicate Weed-out
    - First Match
    - Loose Scan
    - Materialization
    
    쿼리에 사용되는 테이블과 조인 조건의 특성에 따라
    옵티마이저는 사용 가능한 전략들을 선별적으로 사용한다.
    
    Table Pull-out 전략은 사용 가능하면 항상 세미 조인보다
    좋은 성능을 내기 때문에 별도의 제어 옵션을 제공하지 않는다.
    
    First Match와 Loose Scan 전략은 firstmatch, loosescan 옵티마이저 옵션으로
    사용 여부를 결정할 수 있고
    
    Duplicate Weed-out과 Materialization 전략은
    materialization 옵티마이저 스위치로 사용 여부를 결정할 수 있다.
    
    optimizer_swich 시스템 변수의 semijoin 옵티마이저 옵션은
    firstmatch, loosecscan, materialization 옵션을 한 번에 비/활성화할 때 사용한다.
    
- 9.3.1.10 테이블 풀-아웃(Table Pull-out)
    
    Table Pull-out 최적화는 세미 조인의 서브쿼리에 사용된 테이블을
    아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성하는 형태의 최적화다.
    
    이는 서브쿼리 최적화가 도입되기 전 수동으로 쿼리를 튜닝하던 대표적인 방법이였다.
    
    ```sql
    mysql> EXPLAIN
    			 SELECT * FROM employees e
    			 WHERE e.emp_no IN (SELECT de.emp_no FROM dept_emp de WHERE de.dept_no='d009');
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2025.png)
    
    위 실행 계획은 MySQL 8.0 의 쿼리 결과를 나타낸다.
    실행 계획에서 가장 중요한 부분은 id 컬럼의 값이 모두 1이라는 것이다.
    
    Table Pull-out 전략은 별도로 실행 계획의 Extra 컬럼에 별도의 문구가 출력되지 않는다.
    
    그래서 Table Pull-out 전략이 사용됐는지는 실행 계획에서 해당 테이블들의
    id 컬럼 값이 같은지 다른지를 비교해보는 것(그러면서 Extra 컬럼이 NULL 인 경우)이
    가장 간단한 방법이다.
    
    더 정확하게 확인하는 방법은 EXPLAIN 명령어를 실행한 직후
    SHOW WARNINGS 명령으로 옵티마이저가 재작성한 쿼리를 살펴보는 것이다.
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2026.png)
    
    위 쿼리를 보면 IN 형태는 사라지고 JOIN으로 쿼리가 재작성된 것을 확인할 수 있다.
    
    물론 Table Pull-out 전략은 모든 형태의 서브쿼리에서 사용될 수 있는 것은 아니다.
    아래는 Table Pull-out 전략의 제한 사항과 특성을 나열한 것이다.
    
    - Table Pull-out 전략은 세미 조인 서브쿼리에서만 사용 가능하다.
    - Table Pull-out 전략은 서브쿼리 부분이 UNIQUE 인덱스나
    프라이머리 키 룩업으로 결과가 한 건인 경우에만 사용 가능하다.
    - Table Pull-out 이 적용된다 해도 기존 쿼리에서 가능했던
    최적화 방법이 사용 불가능한 것은 아니므로
    MySQL 에서는 가능하다면 Table Pull-out 전략을 최대한 적용한다.
    - Table Pull-out 전략은 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면
    서브쿼리 자체가 없어진다.
    - MySQL 에서는 `최대한 서브쿼리를 조인으로 풀어 사용해라` 라는 튜닝 가이드가 많은데
    Table Pull-out 전략은 이 가이드를 그대로 실행하는 것이다.
    그래서 이제부터는 서브쿼리를 조인으로 풀어 사용할 필요가 없다.
- 9.3.1.11 퍼스트 매치(firstmatch)
    
    First Match 전략은 IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로
    튜닝한 것과 비슷한 방법으로 실행된다.
    
    ```sql
    mysql> EXPLAIN SELECT *
    			 FROM employees e WHERE e.first_name='Matt'
    				 AND e.emp_no IN (
    					 SELECT t.emp_no FROM titles t
    					 WHERE t.from_date BETWEEN '1995-01-01' AND '1995-01-30'
    					 );
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2027.png)
    
    위 쿼리의 실행 계획을 보면 id 컬럼의 값이 모두 1로 표시됐다는 것과
    Extra 컬럼에 FirstMatch(e) 라는 문구가 출력됐다는 걸 알 수 있다.
    
    FirstMatch(e) 문구는 employees 테이블의 레코드에 대해
    titles 테이블에 일치하는 레코드 한 건만 찾으면
    더이상의 titles 테이블 검색을 하지 않는다는 것을 의미한다.
    
    실제 의미론적으로는 EXISTS(subquery)와 동일하게 처리된 것이다.
    
    하지만 FirstMatch는 서브쿼리가 아니라 조인으로 풀어 실행하면서
    일치하는 첫 번째 레코드만 검색하는 최적화를 실행한 것이다.
    
    ![그림 9.13 FirstMatch 최적화 작동 방식](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2028.png)
    
    그림 9.13 FirstMatch 최적화 작동 방식
    
    먼저 employees 테이블에서 first_name 컬럼의 값이 ‘Matt’인 사원의 정보를
    ix_firstname 인덱스를 사용해 레인지 스캔으로 읽은 결과가
    위 그림의 왼쪽에 있는 employees 테이블이다.
    
    first_name이 ‘Matt’ 인 사원 번호가 12302인 레코드를 titles 테이블과 조인해
    titles 테이블의 from_date가 t.from_date 조건을 만족하는 레코드를 찾아본다.
    
    12302번 사원은 from_date 조건을 만족하는 레코드가 없기 때문에 반환 결과는 없다.
    
    그 다음으로 243075번 사원의 레코드를 읽어 titles 테이블과 조인하고
    조인된 titles 레코드 중에서 from_date 조건을 만족하는지 검사하고
    
    이 때 일치하는 첫 번째 레코드를 찾았기 때문에 243075번 사원에 대해서는
    더 이상 titles 테이블을 검색하지 않고 사원번호가 243075인 레코드를 결과로 반환한다.
    
    위 그림에서 본 것처럼 First Match 전략은 MySQL 5.5에서 수행했던 최적화 방법인
    IN-to-EXISTS 변환과 거의 비슷한 처리 로직을 수행한다.
    이 IN-to-EXISTS 변환에 비해 First Match 최적화 전략은 아래 같은 장점이 있다.
    
    - 가끔 여러 테이블이 조인되는 경우 원래 쿼리에 없던 동등 조건을
    옵티마이저가 자동으로 추가하는 형태의 최적화가 실행되기도 한다.
    기존의 IN-to-EXISTS 전략에서는 이런 동등 조건 전파가 서브쿼리 내에서만
    가능했지만 First Match 에서는 조인 형태로 처리되기 때문에
    서브쿼리뿐만 아니라 아우터 쿼리의 테이블까지 전파될 수 있다.
    최종적으로 First Match 전략으로 실행되면 더 많은 조건이 주어지는 것이므로
    더 나은 실행 계획을 수립할 수 있다.
    - IN-to-EXISTS 변환 전략에서는 아무런 조건 없이
    변환 가능한 경우 무조건 그 최적화를 수행했지만,
    First Match 전략에서는 서브쿼리의 모든 테이블에 대해
    First Match 최적화를 수행할지 일부 테이블에 대해서만 수행할지
    취사선택할 수 있다는 것이 장점이다.
    
    First Match 전략 또한 특정 형태의 서브쿼리에서 자주 사용되는 최적화 전략이다.
    
    아래는 First Match 전략의 제한 사항과 특성을 나타낸다.
    
    - First Match 는 서브쿼리에서 하나의 레코드만 검색되면
    더이상의 검색을 멈추는 단축 실행 경로(Short-cut path)이기 때문에
    First Match 전략에서 서브쿼리는 그 서브쿼리가 참조하는 모든 아우터 테이블이
    먼저 조회된 이후에 실행된다.
    - First Match 전략이 사용되면 실행 계획의 Extra 컬럼에는
    FirstMatch(table-N) 문구가 표시된다.
    - First Match 전략은 상관 서브쿼리(Correlated subquery)에서도 사용될 수 있다.
    - First Match 전략은 GROUP BY나 집합 함수가
    사용된 서브쿼리의 최적화에는 사용될 수 없다.
    
    First Match 전략은 optimizer_switch 시스템 변수에서
    semijoin 옵션과 firstmatch 옵션이 모두 ON으로 활성화된 경우만 사용할 수 있다.
    만약 firstmatch 최적화만 비활성화하려면 semijoin 옵션은 활성화하되
    firstmatch 옵티마이저 옵션만 비활성화하면 된다.
    
- 9.3.1.12 루스 스캔(loosescan)
    
    세미 조인 서브쿼리 전략의 LooseScan은 인덱스를 사용하는
    GROUP BY 최적화 방법에서 살펴본 Using index for group-by의
    루스 인덱스 스캔(Loose Index Scan)과 비슷한 읽기 방식을 사용한다.
    
    ```sql
    mysql> EXPLAIN
    			 SELECT * FROM departments d WHERE d.dept_no IN (
    					 SELECT de.dept_no FROM dept_emp de );
    ```
    
    departments 테이블의 레코드 건수는 9건밖에 안되지만
    dept_emp 테이블의 레코드는 33만 건 가까이 저장돼 있다.
    
    그런데 dept_emp 테이블에는 dept_no + emp_no 컬럼 조합으로 PK가 만들어져 있다.
    
    그리고 이 PK의 전체 레코드 수는 33만 건 정도 있지만
    dept_no만으로 그루핑해 보면 9건밖에 없다는 것을 알 수 있다.
    
    그렇다면 dept_emp 테이블의 PK를 루스 인덱스 스캔으로 유니크한 dept_no 만 읽으면
    아주 효율적으로 서브쿼리 부분을 실행할 수 있다.
    
    ![그림 9.14 LooseScan 최적화 작동 방식](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2029.png)
    
    그림 9.14 LooseScan 최적화 작동 방식
    
    위 그림에서는 서브쿼리에 사용된 dept_emp 테이블이 드라이빙 테이블로 실행되고
    dept_emp 테이블의 PK를 dept_no 부분에서 유니크하게 읽고 있다는 걸 볼 수 있다.
    
    루스 인덱스 스캔의 Using index for group-by도 위 그림처럼
    dept_emp 테이블의 PK를 읽는 방식과 동일하게 작동한다.
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2030.png)
    
    위 실행 계획의 Extra 컬럼을 보면 LooseScan 이라는 문구가 표시된 것을 알 수 있다.
    
    또한 실행 계획의 각 테이블에 할당된 id 컬럼의 값이 동일하게 1이라는 것도
    MySQL 내부적으로는 조인처럼 처리됐다는 것을 말해준다.
    
    LooseScan 전략은 아래와 같은 특성을 가진다.
    
    LooseScan 전략은 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고
    그 다음으로 아우터 테이블을 드리븐으로 사용해 조인을 수행한다.
    
    그래서 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이
    갖춰져야 사용할 수 있는 전략이다.
    
    루스 인덱스 스캔 최적화는 아래 같은 형태의 서브쿼리에서 사용할 수 있다.
    
    ```sql
    SELECT .. FROM .. WHERE expr IN (SELECT keypart1 FROM tab WHERE ....)
    SELECT .. FROM .. WHERE expr IN (SELECT keypart2 FROM tab WHERE keypart1='상수' ....)
    ```
    
    옵티마이저가 LooseScan 최적화를 사용하지 못하게 비활성화 하려면
    optimizer_switch 변수의 loosescan 옵션을 off 로 설정하면 된다.
    
    ```sql
    mysql> SET optimizer_switch='loosescan=off';
    ```
    
- 9.3.1.13 구체화(Materialization)
    
    Materialization 전략은 세미 조인에 사용된 서브쿼리를 통째로 구체화해
    쿼리를 최적화한다는 의미다.
    
    여기서 Materialization를 쉽게 표현하면 임시 테이블을 생성한다는 것을 의미한다.
    
    ```sql
    mysql> EXPLAIN
    			 SELECT *
    			 FROM employees e
    			 WHERE e.emp_no IN
    					 (SELECT de.emp_no FROM dept_emp de
    						WHERE de.from_date='1995-01-01');
    ```
    
    위 쿼리는 First Match 전략을 사용하면 employees 테이블에 대한 조건이
    서브쿼리 외에는 아무것도 없기 때문에 employees 테이블을 풀 스캔해야 할 것이다.
    
    그래서 이런 형태의 세미 조인에서는 First Match 가 성능 향상에 큰 도움을 주진 못한다.
    
    대신 옵티마이저는 이런 형태의 쿼리를 위해 서브쿼리 구체화(Subquery Materialization)
    라는 최적화 전략을 도입했다.
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2031.png)
    
    위 실행 계획 마지막 라인의 select_type 컬럼에는
    간단하게 MATERIALIZED 라고만 표시됐다.
    
    이 쿼리에서 사용하는 테이블은 2개인데 실행 계획은 3개 라인이 출력된 것을 봐도
    이 실행 계획 어디선가 임시 테이블이 생성됐다는 것을 짐작할 수 있다.
    
    dept_emp 테이블을 읽는 서브쿼리가 먼저 실행되어
    그 결과로 임시 테이블(<subquery2>)이 만들어졌다.
    
    그리고 최종적으로 서브쿼리가 구체화된 임시 테이블과
    employees 테이블을 조인해 결과를 반환한다.
    
    Materialization 전략은 다른 서브쿼리 전략과 달리 아래 쿼리같은 서브쿼리 내의
    GROUP BY 절이 있더라도 이 전략을 사용할 수 있다.
    
    ```sql
    mysql> EXPLAIN
    			 SELECT *
    			 FROM employees e
    			 WHERE e.emp_no IN
    					 (SELECT de.emp_no FROM dept_emp de
    						WHERE de.from_date='1995-01-01'
    						GROUP BY de.dept_no);
    ```
    
    Materialization 최적화 전략이 사용될 수 있는 형태의 쿼리에도
    역시나 제한 사항과 특성이 존재한다.
    
    - IN(subquery)에서 서브쿼리는 상관 서브쿼리가 아니어야 한다.
    - 서브쿼리는 GROUP BY나 집합 합수들이 사용돼도 구체화를 사용할 수 있다.
    - 구체화가 사용된 경우에는 내부 임시 테이블이 사용된다.
    
    Materialization 최적화 전략은 optimizer_switch 변수에서 semijoin 옵션과 materialization 옵션이 모두 활성화된 경우에만 사용되고
    MySQL 8.0 버전에서는 기본적으로 이 두 옵션은 활성화돼 있다.
    
    Materialization 전략만 비활성화하고자 한다면 
    emijoin 옵티마이저 옵션은 활성화하되 materialization 옵션만 비활성화하면 된다.
    
    Materialization 전략을 비활성화할 때 주의해야할 점이 있는데
    세미 조인이 아닌 서브쿼리의 최적화에서도
    Materialization를 이용한 최적화가 사용될 수 있다.
    
    하지만 materialization 옵션이 비활성화된다면 세미 조인이 아닌
    서브쿼리 최적화에서도 Materialization를 이용한 최적화는 사용되지 못한다.
    
- 9.3.1.14 중복 제거(Duplicated Weed-out)
    
    Duplicated Weed-out은 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔
    실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.
    
    ```sql
    mysql> EXPLAIN
    			 SELECT * FROM employees e
    			 WHERE e.emp_no IN (SELECT s.emp_no FROM salaries s WHERE s.salary>150000);
    ```
    
    salaries 테이블의 PK가 emp_no + from_date 이므로 salary가 150000 이상인 레코드를
    salaries 테이블에서 조회하면 그 결과에는 중복된 emp_no가 발생할 수 있다.
    
    그래서 이 쿼리를 아래와 같이 재작성해 GROUP BY절을 넣어주면
    위의 세미 조인 서브쿼리와 동일한 결과를 얻을 수 있다.
    
    ```sql
    mysql> SELECT e.*
    			 FROM employees e, salaries s
    			 WHERE e.emp_no=s.emp_no AND s.salary>150000
    			 GROUP BY e.emp_no;
    ```
    
    실제로 duplicate Weed-out 알고리즘은 원본 쿼리를
    위 쿼리처럼 INNER JOIN + GROUP BY 절로 변환 후 실행하는 것과
    동일한 작업으로 쿼리를 처리한다.
    
    ![그림 9.15 Duplicate Weed-out 최적화 작동 방식](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2032.png)
    
    그림 9.15 Duplicate Weed-out 최적화 작동 방식
    
    1. salaries 테이블의 ix_salary 인덱스를 스캔해 salary가 150000보다 큰 사원을 검색해
    employees 테이블 조인을 실행
    2. 조인된 결과를 임시 테이블에 저장
    3. 임시 테이블에 저장된 결과에서 emp_no 기준으로 중복 제거
    4. 중복을 제거하고 남은 레코드를 최종적으로 반환
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2033.png)
    
    위는 Duplicate Weed-out 최적화를 이용한 예제 쿼리의 실행 계획이다.
    
    이 실행 계획에서는 Duplicate Weedout 같은 문구가 별도로 표시되진 않지만
    Extra 컬럼에 Start temporary와 End temporary 문구가 표기된 것을 확인할 수 있다.
    
    위 그림에서 처리 과정을 설명할 때 1번과 2번 과정을 나눠 서술하긴 했지만
    결국 1번에서 조인을 수행하는 작업과 2번에서 임시 테이블로 저장하는 작업은
    반복적으로 실행되는 과정이다.
    
    이 반복 과정이 시작되는 테이블의 실행 계획 라인에는 Start temporary 문구가
    반복 과정이 끝나는 테이블의 실행 계획 라인에는 End temporary 문구가 표시된다.
    
    Duplicate Weed-out 최적화 알고리즘은 아래와 같은 장점과 제약 사항이 있다.
    
    - 서브쿼리가 상관 서브쿼리라 해도 사용할 수 있는 전략이다.
    - 서브쿼리가 GROUP BY나 집합 함수가 사용된 경우 사용될 수 없다.
    - Duplicate Weed-out은 서브쿼리의 테이블을 조인으로 처리하기 때문에
    최적화할 수 있는 방법이 무수히 많다.
    
    > 이 책에서 예제로 사용하는 데이터베이스에서는
    Duplicate Weed-out 최적화 처리가 필요한 쿼리 예제를 만들기가 쉽지 않았다.
    
    그래서 이 쿼리를 실행하는 과정에서는 optimizer_switch 변수의 값을 변경해
    Materialization과 First Match, LooseScan 최적화가
    사용되지 못하게 한 상태에서 테스트했다.
    > 
- 9.3.1.15 컨디션 팬아웃(condition_fanout_filter)
    
    조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다.
    
    예를 들어 A 와 B 테이블을 조인할 때 A 테이블에는 조건에 일치하는 레코드가 만 건이고
    B 테이블에는 10건이라고 가정할 때 A 테이블을 드라이빙 테이블로 결정하면
    B 테이블을 만 번 읽어야 한다.
    
    이 때 B 테이블의 인덱스를 이용해 조인을 실행한다 해도 레코드를 읽을 때마다
    B 테이블의 인덱스를 구성하는 B-Tree의 루트 노드부터 검색을 실행해야 한다.
    
    그래서 MySQL 옵티마이저는 여러 테이블이 조인되는 경우
    가능하다면 일치하는 레코드 건수가 적은 순서로 조인을 실행한다.
    
    ```sql
    mysql> SELECT *
    			 FROM employees e
    				 INNER JOIN salaries s ON s.emp_no=e.emp_no
    			 WHERE e.first_name='Matt'
    				 AND e.hire_date BETWEEN '1985-11-21' AND '1986-11-21';
    ```
    
    ```sql
    mysql> SET optimizer_switch='condition_fanout_filter=off';
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2034.png)
    
    1. employees 테이블에서 ix_firstname 인덱스를 이용해
    first_name 조건에 일치하는 233건의 레코드를 검색한다.
    2. 검색된 233건의 레코드에서 hire_date 조건에 맞는 레코드를 걸러낸다.
    여기서 filtered 컬럼의 값이 100인 이유는 옵티마이저가 233건 모두
    hire_date 조건을 만족할 것으로 예측했다는 것을 의미한다.
    3. employees 테이블을 읽은 결과 233건에 대해
    salaries 테이블의 PK를 이용해 salaries 테이블의 레코드를 읽는다.
    이 때 옵티마이저는 employees 테이블의 레코드 한 건당
    salaries 테이블의 레코드 10건이 일치할 것으로 예상했다.
    
    ```sql
    mysql> SET optimizer_switch='condition_fanout_filter=on';
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2035.png)
    
    condition_fanout_filter 옵션을 활성화한 후 조회한 실행 계획에서는
    filtered 컬럼의 값이 23.2%로 변경된 걸 확인할 수 있다.
    
    이는 옵션이 활성화 되면서 옵티마이저가 인덱스를 사용할 수 있는 first_name 조건 외의
    나머지 조건(hire_date)에 대해서도 얼마나 조건을 충족할지 고려했다는 뜻이다.
    
    즉, 옵션을 비활성화 했을 경우 employees 테이블에서
    모든 조건을 충족하는 컬럼이 233건일 것으로 예측하고,
    옵션이 활성화된 경우 54건(233 * 0.232)만 충족할 것이라고 예측했다.
    
    이제 MySQL 옵티마이저가 조건을 만족하는 레코드 건수를 정확하게 예측할 수 있다면
    더 빠른 실행 계획을 만들어 낼 수 있다는 사실을 알 수 있다.
    
    그러면 condition_fanout_filter 옵션은 어떻게 filtered 컬럼의 값을 예측하는지 알아보자.
    
    MySQL 8.0 버전에서는 옵션이 활성화되면 아래와 같은 조건을 만족하는
    컬럼의 조건들에 대해 조건을 만족하는 레코드의 비율을 계산할 수 있다.
    
    1. WHERE 조건절에 사용된 컬럼에 대한 인덱스가 있는 경우
    2. WHERE 조건절에 사용된 컬럼에 대한 히스토그램이 존재하는 경우
    
    위 쿼리가 실제 실행될 때 first_name 조건을 위해 ix_firstname 인덱스만을 사용하지만
    실행 계획을 수립할 때 ix_firstname 인덱스를 사용해
    first_name 조건에 일치하는 레코드 건수가 233건정도라는 것을 알아내고
    hire_date 컬럼의 조건을 만족하는 레코드의 비율이 대략 23.2%일 것으로 예측한다.
    
    만약 employees 테이블의 hire_date 컬럼에 인덱스가 없었다면
    옵티마이저는 first_name 컬럼의 인덱스를 이용해
    hire_date 컬럼값의 분포도를 보고 filtered 컬럼의 값을 예측한다.
    
    condition_fanout_filter 최적화 옵션을 활성화하면 옵티마이저는 더 정교한 계산을
    할 수 있지만 그에 따라 쿼리 실행 계획 수립에 더 많은 자원과 시간을 소모하게 된다.
    
    쿼리가 간단하고 MySQL 8.0 이전에서도 실행 계획이 잘못된 선택을 한적이 별로 없다면
    condition_fanout_filter 옵션은 성능 향상에 크게 도움이 되지 않을 가능성이 높다.
    
    MySQL 서버가 처리하는 쿼리의 빈도가 매우 높다면 실행 계획 수립에 추가되는
    오버헤드가 더 커보일 수 있으니 가급적 업그레이드 전 성능 테스트를 진행하는게 좋다.
    
    MySQL 옵티마이저가 실행 계획을 수립할 때 테이블이나 인덱스의 통계 정보만
    사용하는 것이 아니라 아래와 같은 순서로 사용 가능한 방식을 선택한다.
    
    1. 레인지 옵티마이저(Range optimizer)를 이용한 예측
    2. 히스토그램을 이용한 예측
    3. 인덱스 통계를 이용한 예측
    4. 추측에 기반한 예측(Guesstimates)
    
    여기서 가장 우선순위가 높은 레인지 옵티마이저는
    실제 인덱스의 데이터를 보고 레코드 건수를 예측하는 방식인데
    실제 쿼리가 실행되기 전 실행 계획을 수립 단계에서
    소량의 데이터를 빠르게 읽어보는 것이다.
    
    레인지 옵티마이저에 의한 예측은 인덱스를 이용해 쿼리가 실행될 수 있을때 사용되고
    레인지 옵티마이저가 다른 방법보다 우선순위가 높기 때문에
    히스토그램이나 인덱스의 통계 정보와 다른 값이 표시될 수도 있다.
    

- 9.3.1.16 파생 테이블 머지(derived_merge)
    
    ```sql
    mysql> EXPLAIN
    			 SELECT * FROM (
    				 SELECT * FROM employees WHERE first_name='Matt'
    			 ) derived_table
    			 WHERE derived_table.hire_date='1986-04-03';
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2036.png)
    
    예전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리는
    먼저 실행해 결과를 임시 테이블로 만들고 외부 쿼리를 처리했다.
    
    쿼리의 실행 계획을 보면 employees 테이블을 읽는 라인의
    select_type 컬럼의 값이 DERIVED라고 표시돼 있다.
    
    이는 employees 테이블에서 first_name 조건에 맞는 레코드만 읽어
    임시 테이블을 생성하고 이 임시 테이블을 다시 읽어
    hire_date 조건에 맞는 레코드를 걸러내 반환한 것이다.
    
    MySQL 서버에서는 이렇게 FROM 절에 사용된 서브쿼리를
    파생 테이블(Derived Table)이라고 부른다.
    
    위 실행 계획은 임시 테이블을 생성하고 다시 읽는 오버헤드가 추가된다.
    
    내부적으로 생성되는 임시 테이블은 처음엔 메모리에 생성되지만
    임시 테이블에 저장될 레코드가 많아지면 결국 디스크로 기록돼야 한다.
    
    그래서 임시 테이블이 메모리에 상주할 만큼 크기가 작다면 성능에 영향이 없겠지만
    레코드가 많아진다면 오버헤드로 인해 쿼리의 성능이 많이 느려질 것이다.
    
    MySQL 5.7 버전부터는 이렇게 파생 테이블로 만들어지는 서브쿼리를
    외부 쿼리와 병합해 서브쿼리 부분을 제거하는 최적화가 도입됐는데
    derived_merge 최적화 옵션은 이런 임시 테이블 최적화를 활성화할지 여부를 결정한다.
    
    ![임시 테이블이 외부 쿼리로 병합된 실행 계획](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2037.png)
    
    임시 테이블이 외부 쿼리로 병합된 실행 계획
    
    위 실행 계획에서는 select_type 컬럼이 DERIVED였던 라인이 없어지고
    서브쿼리 없이 employees 테이블을 조회하는 형태의 단순 실행 계획으로 변경됐다.
    
    그리고 SHOW WARNINGS 명령으로 옵티마이저가 새로 작성한 쿼리를 살펴보면
    서브쿼리가 어떻게 외부 쿼리로 병합됐는지 확인할 수 있다.
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2038.png)
    
    예전 버전의 MySQL 서버에서는 서브쿼리로 작성된 쿼리를 외부 쿼리로
    병합하는 작업을 DBA가 수작업으로 처리했다.
    
    하지만 이제 옵티마이저가 자동으로 처리할 수 있기 때문에
    굳이 쿼리를 새로 작성할 필요는 없어졌다.
    
    물론 옵티마이저가 모든 쿼리에 대해 병합 작업을 하진 못한다.
    아래 조건들의 경우 병합 작업을 수행할 수 없게 된다.
    
    - SUM() 또는 MIN(), MAX() 같은 집계 함수와
    윈도우 함수(Window Function)가 사용된 서브쿼리
    - DISTINCT가 사용된 서브쿼리
    - GROUP BY나 HAVING이 사용된 서브쿼리
    - LIMIT이 사용된 서브쿼리
    - UNION 또는 UNION ALL을 포함하는 서브쿼리
    - SELECT 절에 사용된 서브쿼리
    - 값이 변경되는 사용자 변수가 사용된 서브쿼리
- 9.3.1.17 인비저블 인덱스(use_invisible_indexes)
    
    MySQL 8.0 버전부터 인덱스의 가용 상태를 제어할 수 있는 기능이 추가됐다.
    
    원래는 인덱스가 존재하면 항상 옵티마이저가
    실행 계획을 수립할 때 해당 인덱스를 검토하고 사용했다.
    
    하지만 MySQL 8.0 버전부터는 인덱스를 삭제하지 않고
    해당 인덱스를 사용하지 못하게 제어하는 기능을 제공한다.
    
    ```sql
    -- // 옵티마이저가 ix_hiredate 인덱스를 사용하지 못하게 변경
    mysql> ALTER TABLE employees ALTER INDEX ix_hiredate INVISIBLE;
    
    -- // 옵티마이저가 ix_hiredate 인덱스를 사용할 수 있게 변경
    mysql> ALTER TABLE employees ALTER INDEX ix_hiredate BISIBLE;
    ```
    
    위 예제처럼 `ALTER TABLE ... ALTER INDEX ... [ VISIBLE | INVISIBLE ]`명령으로
    인덱스의 가용 상태를 변경할 수 있다.
    
    use_invisible_indexes 옵션을 사용하면 INVISIBLE로 설정된 인덱스라도
    옵티마이저가 사용하게 제어할 수 있다.
    
    use_invisible_indexes 옵션의 기본값은 비활성화라 INVISIBLE 상태의 인덱스는
    기본적으로 옵티마이저가 볼 수 없는 상태다.
    
    아래와 같이 옵션을 변경하면 INVISIBLE 상태의 인덱스도 볼 수 있게 설정할 수 있다.
    
    ```sql
    mysql> SET optimizer_switch='use_invisible_indexes=on';
    ```
    
- 9.3.1.18 스킵 스캔(skip_scan)
    
    인덱스의 핵심은 값이 정렬돼 있다는 것이고 이로 인해
    인덱스를 구성하는 컬럼의 순서가 매우 중요하다.
    
    예를 들어 A B C 컬럼으로 구성된 인덱스가 존재할 때
    WHERE 절에 A와 B 컬럼에 대한 조건이 있다면
    이 쿼리는 A 컬럼과 B 컬럼까지만 인덱스를 활용할 수 있다.
    
    그런데 WHERE 절에 B와 C 컬럼에 대한 조건을 가지고 있다면
    이 쿼리는 인덱스를 활용할 수 없다.
    
    인덱스 스킵 스캔은 제한적이긴 하지만 이런 제약 사항을
    뛰어넘을 수 있는 최적화 기법이다.
    
    ```sql
    mysql> ALTER TABLE employees
    				 ADD INDEX ix_gender_birthdate (gender, birth_date);
    ```
    
    위 인덱스를 사용하기 위해서 WHERE 조건절에
    gender 컬럼에 대한 비교 조건이 필수적이다.
    
    ```sql
    -- // ix_gender_birthdate 인덱스를 사용하지 못하는 쿼리
    mysql> SELECT * FROM employees WHERE birth_date>='1965-02-01';
    
    -- // ix_gender_birthdate 인덱스를 사용할 수 있는 쿼리
    mysql> SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
    ```
    
    위의 2개 쿼리 중 gender 컬럼과 birth_date 컬럼의 조건을 모두 가진
    두 번째 쿼리는 인덱스를 효율적으로 사용할 수 있지만
    gender 컬럼에 대한 비교 조건이 없는
    첫 번째 쿼리는 인덱스를 사용할 수가 없었다.
    
    이런 경우 birth_date 컬럼부터 시작하는 인덱스를 새로 생성해야만 했다.
    
    MySQL 8.0 버전부터는 인덱스 스킵 스캔 최적화가 도입됐고
    이 기능은 인덱스의 선행 컬럼이 조건절에 사용되지 않더라도
    후행 컬럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능하다.
    
    위의 첫 번째 쿼리를 실행할 때 옵티마이저는
    테이블에 존재하는 모든 gender 컬럼값을 가져와
    두 번째 쿼리와 같이 gender 컬럼의 조건이 있는 것처럼 쿼리를 최적화한다.
    
    그런데 인덱스의 선행 컬럼이 매우 다양한 값을 가지는 경우에는
    인덱스 스킵 스캔이 비효율적일 수 있다.
    
    그래서 MySQL 8.0 옵티마이저는 인덱스의 선행 컬럼이
    소수의 유니크한 값을 가질 때만 인덱스 스킵 스캔을 사용한다.
    
    ```sql
    -- // 현재 세션에서 인덱스 스킵 스캔 최적화를 활성화
    mysql> SET optimizer_switch='skip_scan=on';
    
    -- // 현재 세션에서 인덱스 스킵 스캔 최적화를 비활성화
    mysql> SET optimizer_switch='skip-scan=on';
    
    -- // 특정 테이브에 대해 인덱스 스킵 스캔을 사용하도록 힌트를 사용
    mysql> SELECT /*+ SKIP_SCAN(employees)*/ COUNT(*)
    			 FROM employees
    			 WHERE birth_date>='1965-02-01';
    
    -- // 특정 테이블과 인덱스에 대해 인덱스 스킵 스캔을 사용하도록 힌트를 사용
    mysql> SELECT /*+ SKIP_SCAN(employees ix_gender_birthdate)*/ COUNT(*)
    			 FROM employees
    			 WHERE birth_date>='1965-02-01';
    
    -- // 특정 테이블에 대해 인덱스 스킵 스캔을 사용하지 않도록 힌트를 사용
    mysql> SELECT /*+ NO_SKIP_SCAN(employees)*/ COUNT(*)
    			 FROM employees
    			 WHERE birth_date>='1965-02-01';
    ```
    
- 9.3.1.19 해시 조인(hash_join)
    
    해시 조인은 MySQL 8.0.18 버전부터 지원되기 시작했다.
    
    많은 사용자가 해시 조인 기능을 기대하는 이유가
    기존의 네스티드 루프 조인보다 해시 조인이 빠르다고 생각하기 때문이다.
    
    하지만 항상 해시 조인이 네스티드 루프 조인보다 빠르다고 할 수 없다.
    
    ![그림 9.16 중첩 루프 조인과 해시 조인의 처리 성능](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2039.png)
    
    그림 9.16 중첩 루프 조인과 해시 조인의 처리 성능
    
    해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만
    최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는 것을 알 수 있다.
    
    그리고 네스티드 루프 조인은 마지막 레코드를 찾는 데까지는 시간이 많이 걸리지만
    첫 번째 레코드를 찾는 것은 상대적으로 훨씬 빠르다는 것을 알 수 있다.
    
    즉 해시 조인 쿼리는 최고 스루풋(Best Throughput) 전략에 적합하고
    네스티드 루프 조인은 최고 응답 속도(Best Response-time) 전략에
    적합하다는 것을 알 수 있다.
    
    일반적인 웹 서비스는 온라인 트랜잭션 서비스이기 때문에
    스루풋도 중요하지만 응답 속도가 더 중요하다.
    
    그리고 분석과 같은 서비스는 사용자의 응답 시간보다 전체적인 처리 소요 시간이
    중요하기 때문에 응답 속도보다는 전체 스루풋이 중요하다.
    
    아마도 대용량 데이터 분석을 위해 MySQL 을 사용하지 않을 것 이라는 관점에서 보면
    MySQL 서버가 응답 속도와 스루풋 중 어디에 집중해 최적화할지 명확해진다.
    
    이런 이유로 MySQL 서버는 주로 조인 조건의 컬럼이 인덱스가 없다거나
    조인 대상 테이블 중 일부 레코드 건수가 매우 적은 경우 등에 대해서만
    해시 조인 알고리즘을 사용하도록 설계돼 있다.
    
    즉 MySQL 서버의 해시 조인은 네스티드 루프 조인이 사용되기 적합하지 않는
    경우를 위한 차선책 같은 기능으로 생각하는 것이 좋다.
    
    그래서 해시 조인이 빠르다고 옵티마이저 힌트를 사용해 강제로
    쿼리의 실행 계획을 해시 조인으로 유도하는 것은 좋지 않다는 것을 알아둬야 한다.
    
    MySQL 8.0.17 버전까지는 해시 조인 기능이 없었기 때문에 조인 조건이 좋지 않은 경우
    블록 네스티드 루프 조인이라는 조인 알고리즘을 사용했다.
    
    블록 네스티드 루프 조인 또한 쿼리의 조인 조건이 인덱스를
    제대로 활용할 수 없는 경우에만 사용되는 최적화 방법 수준으로 사용됐다.
    
    그래서 인덱스가 잘 설계된 데이터베이스에서는
    블록 네스티드 루프 조인 실행 계획을 거의 볼 수 없었다.
    
    이 블록 네스티드 루프 조인에서 블록은
    join_buffer_size 시스템 변수로 조정할 수 있는 메모리 공간을 의미하고
    이 조인 버퍼는 무한정하게 설정할 수 없어 조인 대상 테이블의 레코드 크기가
    조인 버퍼보다 큰 경우 드라이빙 테이블을 여러 번 반복해 스캔해야 하는 문제점이 있다.
    
    그래서 MySQL 8.0.18 과 8.0.19 버전에서는
    동등 조인(Equi-Join)을 위해서 해시 조인이 사용됐지만
    안티 조인이나 세미 조인을 위해서는 블록 네스티드 루프 조인이 사용됐다.
    
    하지만 MySQL 8.0.20 버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고
    네스티드 루프 조인을 사용할 수 없는 경우 항상 해시 조인이 사용되도록 바뀌었다.
    
    그리고 block_nested_loop 이나 optimizer_switch 또는 BNL, NO_BNL과 같은 힌트들도
    블록 네스티드 루프가 아닌 해시 조인을 유도하는 목적으로 사용된다.
    
    ```sql
    mysql> EXPLAIN
    			 SELECT *
    			 FROM employees e IGNORE INDEX(PRIMARY, ix_hiredate)
    				 INNER JOIN dept_emp de IGNORE INDEX(ix_empno_fromdate, ix_fromdate)
    					 ON de.emp_no=e.emp_no AND de.from_date=e.hire_date;
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2040.png)
    
    위 쿼리의 실행 계획을 보면 Extra 컬럼에 hash join 이라는 문구가 노출되는데
    이는 옵티마이저가 해시 조인으로 이 쿼리를 처리했다는 것을 의미한다.
    
    위에서 사용된 IGNORE INDEX 힌트는 네스티드 루프 조인을 사용하지 못하게 해
    옵티마이저가 해시 조인을 사용하도록 유도한다.
    
    일반적으로 해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리된다.
    
    - 빌드 단계
        - 조인 대상 테이블 중 레코드 건수가 적어 해시 테이블로 만들기 용이한
        테이블을 골라 메모리에 해시 테이블을 생성(빌드)하는 작업을 수행한다.
        - 빌드 단계에서 해시 테이블을 생성할 때 사용하는
        원본 테이블을 빌드 테이블이라고도 한다.
    - 프로브 단계
        - 나머지 테이블의 레코드를 읽어 해시 테이블과
        일치하는 레코드를 찾는 작업을 수행한다.
        - 이 때 읽는 나머지 테이블을 프로브 테이블이라고도 한다.
    
    위의 실행 계획에서는 어느 테이블이 빌드인지 프로브 테이블인지 파악이 어렵기 때문에 
    EXPLAIN FORMAT=TREE 명령 또는 EXPLAIN ANALYZE 명령을 사용하면 된다.
    
    ```sql
    mysql> EXPLAIN FORMAT=TREE
    			 SELECT *
    			 FROM employees e IGNORE INDEX(PRIMARY, ix_hiredate)
    				 INNER JOIN dept_emp de IGNORE INDEX(ix_empno_fromdate, ix_fromdate)
    					 ON de.emp_no=e.emp_no AND de.from_date=e.hire_date \G
    
    -> Inner hash join (e.hire_datre = de.from_date), (e.emp_no = de.emp_no)
    									 (cost=9942694661.05 rows=331143)
    		 -> Table scan on e (cost=0.08, rows=300252)
    		 -> Hash
    				 -> Table scan on de (cost=33979.30, rows=331143)
    ```
    
    ![그림 9.17 해시 조인(메모리에서 모두 처리 가능한 경우)](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2041.png)
    
    그림 9.17 해시 조인(메모리에서 모두 처리 가능한 경우)
    
    Tree 포맷의 실행 계획을 보면 dept_emp 테이블이
    빌드 테이블로 선정된 것을 알 수 있다.
    
    옵티마이저는 해시 조인을 위해 빌드 테이블인
    dept_emp 테이블의 레코드를 읽어 메모리에 해시 테이블을 생성했다.
    
    그리고 프로브 테이블로 선택된 employees 테이블을 스캔하면서
    메모리에 생성된 해시 테이블에서 레코드를 찾아 결과를 사용자에게 반환한 것이다.
    
    ![그림 9.18 해시 조인 1차 처리(해시 테이블이 조인 버퍼 메모리보다 큰 경우)](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2042.png)
    
    그림 9.18 해시 조인 1차 처리(해시 테이블이 조인 버퍼 메모리보다 큰 경우)
    
    해시 테이블을 메모리에 저장할 때 MySQL 서버는
    join_buffer_size 변수로 크기를 제어할 수 있는 조인 버퍼를 사용한다.
    조인 버퍼의 기본 크기는 256KB인데
    해시 테이블의 레코드 건수가 많아 조인 버퍼의 공간이 부족할 수도 있다.
    
    이런 경우 MySQL 서버는 빌드 테이블과 프로브 테이블을
    적당한 크기(하나의 청크가 조인 버퍼보다 작도록)의 청크로 분리하고
    분리한 청크별로 [그림 9.17](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533.md)과 동일한 방식으로 해시 조인을 처리한다.
    
    위 그림에서는 해시 조인의 처리 방법이 복잡해졌는데
    그 이유는 생성될 해시 테이블이 설정된 메모리 크기보다 큰지 알 수 없기 때문이다.
    
    MySQL 서버는 dept_emp 테이블을 읽으면서 메모리의 해시 테이블을 준비하다가
    지정된 메모리 크기를 넘어서면 dept_emp 테이블의 나머지 레코드를
    디스크에 청크로 구분해 저장한다.
    
    그리고 employees 테이블의 emp_no 값을 이용해
    메모리의 해시 테이블을 검색해 1차 조인 결과를 생성한다.
    그리고 동시에 employees 테이블에서 읽은 레코드를 디스크에 청크로 구분해 저장한다.
    
    그래서 위 그림의 디스크에 2개의 그룹으로 구분된 청크 목록이 표현된 것이다.
    
    - 빌드 테이블 청크
        - dept_emp 테이블의 레코드를 저장해둔 공간
    - 프로브 테이블 청크
        - employees 테이블의 레코드를 저장해둔 공간
    
    ![그림 9.19 해시 조인 2차 처리(해시 테이블이 조인 버퍼 메모리보다 큰 경우)](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2043.png)
    
    그림 9.19 해시 조인 2차 처리(해시 테이블이 조인 버퍼 메모리보다 큰 경우)
    
    1차 조인이 완료되면 위 그림의 1번처럼 MySQL 서버가 디스크에 저장된
    빌드 테이블 청크에서 첫 번째 청크를 읽고 메모리 해시 테이블을 구축한다.
    
    그리고 2번처럼 프로브 테이블 청크에서 구축된
    메모리 해시 테이블과 조인을 수행해 2차 결과를 가져온다.
    
    위 그림은 빌드 테이블 청크와 프로브 테이블 청크에서
    첫 번째 청크만 처리하는 과정이지만 실제로는
    디스크에 저장된 청크 개수만큼 이 과정을 반복해 조인 결과를 만들어낸다.
    
    이렇게 청크 단위로 조인을 수행하기 위해 MySQL 서버는
    2차 해시 함수를 이용해서 빌드 테이블과 프로브 테이블을
    동일한 개수의 청크로 쪼개 디스크에 저장한다.
    
    MySQL 옵티마이저는 각 경우에 따라 서로 다른 해시 조인 알고리즘을 사용한다.
    
    그림 9.17의 경우 클래식 해시 조인(Classic hash join) 알고리즘을 사용하고
    그림 9.18의 경우 그레이스 해시 조인(Grace hash join) 알고리즘을 사용한다.
    
- 9.3.1.20 인덱스 정렬 선호(prefer_ordering_index)
    
    MySQL 옵티마이저는 ORDER BY 또는 GROUP BY 를 인덱스를 사용해 처리 가능한 경우
    쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해 실행된다.
    
    ```sql
    mysql> EXPLAIN
    			 SELECT *
    			 FROM employees
    			 WHERE hire_date BETWEEN '1985-01-01' AND '1985-02-01'
    			 ORDER BY emp_no;
    ```
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2044.png)
    
    위 쿼리는 대표적으로 두 가지 실행 계획을 선택할 수 있다.
    
    1. ix_hiredate 인덱스를 이용해 hire_date 조건에 부합하는 레코드를 찾고
    emp_no 로 정렬해 결과를 반환
    2. employees 테이블의 PK가 emp_no이므로 PK를 정순으로 읽으면서
    hire_date 조건에 부합하는지 비교 후 결과를 반환
    
    상황에 따라 다르지만 일반적으로는 hire_date 조건에 부합하는
    레코드 건수가 많지 않다면 1번이 효율적일 것이다.
    
    그런데 가끔 옵티마이저가 예제 쿼리의 실행 계획처럼
    2번 실행 계획을 선택하는 경우가 있을 수도 있다.
    
    실행 계획에서는 PK를 풀 스캔하면서 
    hire_date 조건에 부합하는 레코드만 필터링 하도록 처리하고 있는데
    
    이렇게 체크해야 하는 레코드 건수가 상당히 많음에도
    정렬된 인덱스 활용으로 실행 계획이 수립되는 것은
    옵티마이저가 실수로 잘못된 실행 계획을 선택한 것일 가능성이 높다.
    
    물론 이런 경우가 빈번하진 않지만 가끔 옵티마이저가 이런 실수를 한다.
    
    MySQL 8.0.20 버전까지는 이 같은 옵티마이저의 실수가 자주 발생했을 때
    다른 실행 계획을 사용하도록 특정 인덱스를
    사용하지 못하도록 IGNORE INDEX 힌트를 사용하거나 했다.
    
    MySQL 8.0.21 버전부터는 옵티마이저가 ORDER BY를 위한 인덱스에
    너무 많은 가중치를 부여하지 않도록 prefer_ordering_index 옵션이 추가됐다.
    
    이 옵션은 기본적으로 ON 으로 설정돼 있지만
    옵티마이저가 자주 실수를 한다면 해당 옵션을 OFF 로 변경하면 된다.
    
    ```sql
    -- // 현재 커넥션에서만 prefer_ordering_index 옵션을 비활성화
    mysql> SET SESSION optimizer_switch='prefer_ordering_index=OFF';
    
    -- // 현재 쿼리에 대해서만 prefer_ordering_idnex 옵션을 비활성화
    mysql> SELECT /*+ SET_VAR(optimizer_switch='prefer_ordering_index=OFF') */
    				 ...
    			 FROM
    				 ...
    ```
    

### 9.3.2 조인 최적화 알고리즘

MySQL 에는 조인 쿼리의 실행 계획 최적화를 위한 알고리즘이 두 가지가 존재한다.

이 알고리즘들은 MySQL 5.0 버전부터 있던 기능이다.

MySQL 조인 최적화는 나름 개선이 많이 됐다고 이야기한다.
하지만 테이블의 개수가 많아지면 최적화된 실행 계획을 찾는 것이 어려워지고

하나의 쿼리에서 조인되는 테이블의 개수가 많아지면
실행 계획을 수립하는 데만 몇 분이 걸릴 수도 있다.

테이블의 개수가 특정 한계를 넘어서면 그때부터는
실행 계획 수립에 소요되는 시간만 몇 시간이나 며칠로 늘어날 수도 있다.

```sql
mysql> SELECT *
			 FROM t1, t2, t3, t4
			 WHERE ...
```

위와 쿼리처럼 간단히 4개의 테이블을 조인하는 쿼리 문장이
각각의 조인 알고리즘을 통해 어떻게 처리되는지 살펴볼 것이다.

- 9.3.2.1 Exhaustive 검색 알고리즘
    
    ![그림 9.20 Exhaustive 검색 알고리즘](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2045.png)
    
    그림 9.20 Exhaustive 검색 알고리즘
    
    Exhaustive 검색 알고리즘은 MySQL 5.0 이하 버전에서 사용되던 조인 최적화 기법으로
    FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서
    최적의 조합 한 개를 찾는 방법이다.
    
    위 그림은 4개의 테이블이 Exhaustive 검색 알고리즘으로 처리될 때
    최적의 조인 순서를 찾는 방법을 표현한 것이다.
    
    테이블이 20개라면 이 방법으로 처리할 때 가능한 조인 조합은
    모두 20!(3628800)개가 된다.
    
    이전 버전에서 사용되던 Exhaustive 검색 알고리즘에서는
    테이블이 10개만 넘어도 실행 계획을 수립하는 데 몇 분이 걸린다.
    그리고 테이블이 10개에서 한 개만 더 늘어나도 11배의 시간이 더 걸린다.
    
- 9.3.2.2 Greedy 검색 알고리즘
    
    ![그림 9.21 Greedy 검색 알고리즘](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2046.png)
    
    그림 9.21 Greedy 검색 알고리즘
    
    Greedy 검색 알고리즘은 Exhaustive 검색 알고리즘의 시간 소모적인 문제점을
    해결하기 위해 MySQL 5.0부터 도입된 조인 최적화 기법이다.
    
    위 그림은 4개의 테이블이 Greedy 검색 알고리즘으로 처리될 때(optimizer_search_depth=2)
    최적의 조인 순서를 검색하는 방법을 보여준다.
    
    Greedy는 Exhaustive보다 조금 복잡한 형태로 최적의 조인 순서를 결정한다.
    
    1. 전체 N개의 테이블 중 optimizer_search_depth 변수에 정의된 개수의 테이블로
    가능한 조인 조합을 생성
    2. 1번에서 생성된 조인 조합 중 최소 비용의 실행 계획 하나를 선정
    3. 2번에서 선정된 실행 계획의 첫 번째 테이블을
    부분 실행 계획(그림에서는 실행 계획 완료 대상)의 첫 번째 테이블로 선정
    4. 전체 N-1개의 테이블 중(3번에서 선정된 테이블 제외)
    optimizer_search_depth 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
    5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된
    부분 실행 계획에 대입해 실행 비용을 계산
    6. 5번의 비용 계산 결과 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 부분 실행 계획의 두 번째 테이블로 선정
    7. 남은 테이블이 모두 없어질 때까지 4~6번 과정을 반복하면서
    부분 실행 계획에 테이블의 조인 순서를 기록
    8. 최종적으로 부분 실행 계획이 테이블의 조인 순서로 결정됨
    
    Greedy 검색 알고리즘은 optimizer_search_depth 변수(기본값은 62)에
    설정된 값에 따라 조인 최적화의 비용이 상당히 줄어들 수 있다.
    
    MySQL 에서는 조인 최적화를 위한 시스템 변수로
    optimizer_prune_level 과 optimizer_search_depth 가 제공된다.
    
    - optimizer_search_depth
        
        Greedy 와 Exhaustive 검색 알고리즘 중 어떤 알고리즘을 사용할지 결정한다.
        
        0~62까지의 정숫값을 설정할 수 있는데 1~62까지의 정숫값이 설정되면
        Greedy 검색 대상을 지정된 개수로 한정해 최적의 실행 계획을 산출하고
        
        0으로 설정되면 Greedy 검색을 위한 최적의 조인 검색 테이블의 개수를
        옵티마이저가 자동으로 결정한다.
        
        optimizer_search_depth 값과 조인 테이블 개수에 따라
        Exhaustive 검색만 사용하거나 둘 다 사용될 수 있다.
        
        만약 조인에 사용된 테이블의 개수가 옵션 값보다 크다면
        옵션 값 만큼의 테이블은 Exhaustive 검색이,
        나머지는 Greedy 검색이 사용된다.
        
        그리고 조인에 사용된 테이블의 개수가 옵션 값보다 작다면
        Exhaustive 검색만 사용된다.
        
        기본 값으로 62가 설정되어있긴 하지만 많은 테이블이 조인되는 쿼리에서는
        상당히 부담이 될 수 있기 때문에 4~5로 설정하는 것이 좋다.
        
    - optimizer_prune_level
        
        MySQL 5.0부터 추가된 Heuristic 검색이 작동하는 방식을 제어한다.
        
        Exhaustive 와 Greedy 알고리즘 중 어떤 알고리즘을 사용하더라도 옵티마이저는
        여러 테이블의 조인 순서를 결정하기 위해 상당히 많은 조인 경로를 비교한다.
        
        Heuristic 검색의 가장 핵심적인 내용은 다양한 조인 순서의 비용을 계산하는 도중
        이미 계산했던 조인 순서의 비용보다 큰 경우 언제든지 포기할 수 있다는 것이다.
        
        예시로 첫 번째 조인 순서의 비용이 100이라 가정하면 이후에 비교되는 조인 순서의
        비용이 100보다 크면 그 조인 순서는 끝까지 비교할 필요가 없는 것이다.
        
        그리고 아우터 조인으로 연결되는 테이블은 우선순위에서 제거하는 등
        경험 기반의 최적화도 포함돼 있다.
        
        optimizer_prune_level 옵션의 값이
        1로 설정되면 조인 순서 최적화에 경험 기반의 Heuristic 알고리즘을 사용하고
        0으로 설정되면 경험 기반의 Heuristic 최적화가 적용되지 않는다.
        
        실제 Heuristic 조인 최적화는 조인 대상 테이블이 몇 개 되지 않아도
        상당한 성능 차이를 내기 때문에 굳이 0으로 설정할 필요가 없다.
        
    
    그럼 테이블 조인이 많은 쿼리의 실행 계획이 얼마나 느려지는지 확인해보자
    
    대략 아래와 같은 테이블을 1부터 30까지 만들고
    레코드를 2000건 정도 INSERT 한다.
    
    ```sql
    mysql> CREATE TABLE tab01 (
    				 fd1 char(20) NOT NULL,
    				 fd2 char(20) DEFAULT NULL,
    				 PRIMARY KEY (fd1),
    				 KEY ix_fd2 (fd2)
    			 );
    ```
    
    ```sql
    mysql> SET SESSION optimizer_prune_level = { 0 | 1 };
    mysql> SET SESSION optimizer_search_depth = { 1 | 5 | 10 | 15 | 20 | 25 | 30 | 35 | 40 | 62 };
    mysql> EXPLAIN
    			 SELECT *
    			 FROM tab01....
    			 WHERE tab01.fd1=tab02.fd1
    						 AND ...
    ```
    
    optimizer_prune_level 변수를 1로 고정시키고
    optimizer_search_depth 변수의 값을 1부터 5까지 증가 시켜 62까지 변화시키면서
    실행 계획 수립에 걸린 시간은 차이 없이 0.01초로 동일했다.
    
    MySQL 5.1 버전에서는 optimizer_prune_level 을 1로 설정하고
    조인 순서 결정에 Heuristic 최적화를 적용해도 optimizer_search_depth 값이 증가하면
    실행 계획 수립에 1초가 넘는 시간이 걸렸다.
    
    아래는 optimizer_prune_level 세션 변수를 0으로 고정시키고
    optimizer_search_depth 는 위 예제와 동일하게 변화시켰다.
    
    ![Untitled](Chapter%2009%20%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B3%20d61b44f8ac404b22b6aa1b0357144533/Untitled%2047.png)
    
    위 그림을 보면 optimizer_search_depth 값이 15가 될 때부터
    실행 계획 수립에 너무 많은 시간이 소요되어 표기할 수 없는 것을 볼 수 있다.
    
    MySQL 8.0 버전의 조인 최적화는 많이 개선되서
    optimizer_search_depth 값에는 크게 영향을 받지 않았지만
    optimizer_prune_level 을 0으로 설정하면 optimizer_search_depth 값 변화에 따라
    실행 계획 수립에 소요되는 시간이 급증하는 것을 확인할 수 있었다.
    
    예전 버전에서는 조인 최적화와 관련된 휴리스틱의 문제점이 있었지만
    MySQL 8.0 부터는 이런 조인 최적화 관련된 휴리스틱을 비활성화 할 필요가 없어졌다.
    
    optimizer_prune_level 의 기본값이 1이므로 조인 관련된 시스템 변수의 조정은
    더 이상 필요하지 않을 것으로 보인다.
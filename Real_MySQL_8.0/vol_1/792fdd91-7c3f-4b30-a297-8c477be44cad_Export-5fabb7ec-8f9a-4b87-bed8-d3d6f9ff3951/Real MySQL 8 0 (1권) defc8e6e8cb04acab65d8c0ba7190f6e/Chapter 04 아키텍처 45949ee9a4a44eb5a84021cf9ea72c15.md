# Chapter 04 아키텍처

### 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL 의 전체 구조

**MySQL 전체 구조**

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled.png)

- 크게 MySQL 엔진과 스토리지 엔진으로 나뉜다.

### Mysql 엔진

클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 옵티마이저로 구성

DBMS의 두뇌에 해당

Mysql서버당 Mysql엔진은 하나

### 스토리지 엔진

실제 데이터를 디스크 스토리지에 저장, 조회 하는 부분을 담당

Mysql서버당 스토리지 엔진은 여러개

```sql
스토리지 엔진 설정법
CREATE TABLE test(a INT, b INT) ENGINE=INNODB;
```

### 핸들러 API

MySQL 엔진의 쿼리 실행기가 데이터를 쓰거나 읽을때, 각 스토리지 엔진에 요청을 하는데, 
이러한 요청을 핸들러 요청이라고 하고, 여기에 사용되는 API를 핸들러 API 라고 한다.

InnoDB 스토리지 엔진 또한, 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고받는다.

```sql
핸들러로 얼마나 많은 요청을 했는지 확인하는 방법
SHOW GLOBAL STATUS LIKE 'Handler%';
```

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%201.png)

### 4.1.2 MySQL 스레딩 구조

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%202.png)

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동

크게 포그라운드, 백그라운드 스레드로 구분

```sql
스레드 확인 쿼리
SELECT thread_id, name, type, processlist_user, processlist_host 
FROM performance_schema.threads 
ORDER BY type, thread_id;
```

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%203.png)

### 포 그라운드 스레드 (클라이언트 스레드)

MySQL 서버에 접속된 클라이언트 수만큼 존재

각 클라이언트 사용자가 요청하는 쿼리 문장 처리

클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 스레드는 스레드 캐시로 되돌아간다.

스레드 캐시에 저장되는 최대 스레드 개수는 thread_cache_size 시스템 변수로 조절한다.

MyISAM은 디스크 쓰기작업까지 포그라운드 스레드가 처리
InnoDB 는 데이터 버퍼, 캐시까지만 포그라운드 스레드가 처리

### 백 그라운드 스레드

InnoDB는 아래 과정이 백그라운드 스레드로 처리된다.

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링 하는 스레드

로그 스레드, 쓰기 쓰레드가 가장 중요하다.

innodb_write_io_threads, innodb_read_io_threads 로 읽기, 쓰기 스레드 개수를 설정할 수 있다.

### 4.1.3 메모리 할당 및 사용 구조

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%204.png)

### 글로벌 메모리 영역

서버가 시작되면서 운영체제로 부터 할당된다.

일반적으로 하나의 영역만 생성되며, 여러개가 생성되더라도 모든 스레드에 의해 공유된다.

- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티드 해시 인덱스
    - InnoDB 리두 로그 버퍼

### 로컬(세션) 메모리 영역

클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역

각 클라이언트 스레드 별로 독립적으로 할당되며 공유되지 않음

각 쿼리의 용도 별로 필요한 경우에만 공간이 할당되고 필요없으면 할당되지 않음

- 대표적인 로컬 메모리 영역
    - 정렬 버퍼
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%205.png)

플러그인 예시

- 스토리지 엔진
- 전문 검색 엔진을 위한 검색어 파서 (인덱싱할 키워드를 분리해내는 작업)
- 사용자 인증을 위한 Native Authentication, Caching SHA-2 Authentication

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%206.png)

플러그인의 영역은 데이터 읽기/쓰기 부분이다.

데이터 읽기/쓰기 작업은 대부분 1건의 레코드 단위로 처리된다.

MySQL 엔진이 스토리지 엔진을 조정하기 위해 사용하는 것을 핸들러 라고 한다.

GROUP BY, ORDER BY 같은 처리는 SQL 실행기에서 처리된다.

```sql
지원하는 스토리지 엔진 확인 쿼리
SHOW ENGINES;
```

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%207.png)

Support 컬럼 

- YES: MySQL 서버에 해당 스토리지 엔진이 포함되어 있고, 사용 가능으로 활성화된 상태
- DEFAULT: ‘YES’ 와 동일한 상태이지만 필수 스토리지 엔진임을 의미
이 스토리지 엔진이 없으면 MySQL 이 시작되지 않을 수도 있음
- NO: 현재 MySQL 서버에 포함되지 않음
이 엔진을 사용하려면, 서버를 다시 빌드(컴파일) 해야함
하지만, 적절히 준비만 돼 있다면, 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워 넣기만 하면 사용할 수 있음
- DISABLED: 현재 MySQL서버에 포함됐지만 파라미터에 의해 비활성화 된 상태

```sql
설치된 플러그인 확인 쿼리
SHOW PLUGINS;
```

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%208.png)

### 4.1.5 컴포넌트

플러그인의 단점을 보완하기 위해 MySQL 8.0 부터 생김

플러그인의 단점

- 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고, 플러그인 끼리는 통신불가
- 플러그인은 MySQL 서버의 변수나 함수를 직접호출해서 안전하지 않음
- 플러그인은 상호 의존관계를 설정할 수 없어서 초기화가 어려움

```sql
컴포넌트 설치 예시
INSTALL COMPONENT 'file://component_validate_password'

설치된 컴포넌트 확인
SELECT * FROM mysql.component;
```

### 4.1.6 쿼리 실행 구조

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%209.png)

### 쿼리 파서

쿼리 문장을 토큰 (MySQL 이 인식할 수 있는 최소 단위의 어휘나 기호) 으로 분리해 트리 형태의 구조로 만들어 내는 작업

쿼리 문장의 기본 문법 오류 발견

### 전처리기

쿼리 문장에 구조적인 문제점이 있는지 확인

각 토큰을 테이블 이름이나 컬럼 이름, 내장 함수같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정 수행

### 옵티마이저

쿼리 문장을 저렴한 비용으로 빠르게 처리하는 방법을 결정

DBMS의 두뇌에 해당

### 실행 엔진

중간관리자 같은 역할

옵티마이저에 의해 만들어진 계획대로 여러 핸들러들에게 요청하는 역할

### 핸들러 (스토리지 엔진)

MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 부터 읽기/쓰기 수행

### 4.1.7 복제

중요한 역할을 하는데 16장에서 자세히 다루겠다고함

### 4.1.8 쿼리 캐시

SQL 실행 결과를 메모리에 캐시하고 동일한 SQL이 실행되면 즉시 결과를 반환

테이블의 데이터가 변경되면 캐시 데이터도 삭제되기 때문에, 심각한 동시 처리 성능 저하와 많은 버그를 유발

데이터 변경없이 읽기만 하는 환경에서는 훌륭한 기능이지만 이런 서비스는 거의 없음

위와같은 문제로 MySQL 8.0에서는 쿼리 캐시 기능 삭제

### 4.1.9 스레드 풀

MySQL 서버 엔터프라이즈 에디션은 스레드 풀 기능 지원

MySQL 커뮤니티 에디션은 스레드 풀  기능 미지원

Percona Server에서 제공하는 스레드 풀 기능 기준으로 설명

- 플러그인 형태로 작동되게 구현되어 있어서 커뮤니티 에디션에서도 스레드풀 사용 가능

스레드풀의 목적

- 동시 처리되는 요청이 많더라도 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
- CPU의 프로세서 친화도를 높이고 불필요한 컨텍스트 스위치를 줄여서 오버헤드를 낮춤

Percona Server의 스레드 풀은 기본적으로 CPU 코어 개수만큼 스레드 그룹 생성

thread_pool_size 시스템 변수로 스레드 그룹의 개수 조절

일반적으로는 CPU 코어 개수만큼 맞추는게 좋음

MySQL 서버가 처리해야하는 요청이 생길때 이미 스레드 풀이 처리중인 작업이 있는 경우, thread_pool_oversubscribe 설정된 개수만큼 추가로 처리

이 값이 너무 크면 스케쥴링 해야 할 스레드가 많아져서 스레드 풀이 비효율적으로 작동할 수 있음

스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단해야하는데,

스레드 풀의 타이머 스레드가 주기적으로 스레드 그룹의 상태를 체크해서 thread_pool_stall_limit 에 정의된 밀리초 만큼 작업 스레드가 처리중인 작업을 끝내지 못하면 새로운 작업 스레드를 추가한다.

이때, 전체 스레드 풀의 스레드 개수는 thread_pool_max_threads 를 넘을 수 없다.

Percona Server의 스레드 풀 플러그인은 선순위 큐, 후순위 큐를 사용해 특정 트랜잭션이나 쿼리를 우선적으로 처리하는 기능을 제공한다.

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2010.png)

### 4.1.10 트랜잭션 지원 메타데이터

MySQL 5.7 까지는 테이블 구조를 FRM 파일에 저장

스토어드 프로그램을 파일 기반으로 관리

트랜잭션을 지원하지 않기 때문에, 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 발생

MySQL 8.0 부터는 테이블 구조, 스토어드 프로그램을 InnoDB 테이블에 저장

시스템 테이블, 데이터 딕셔너리 정보를 mysql DB에 저장
mysql DB는 mysql.ibd 라는 이름의 테이블스페이스에 저장됨

(사용자는 테이블 구조가 저장된 테이블을 직접 볼 수 없지만 information_schema 를 통해 확인할 수 있다.)

MySQL 서버가 비정상적으로 종료되도 스키마 변경이 완전히 성공하거나 완전히 실패하게 끝난다.

InnoDB 스토리지 엔진을 사용하는 테이블의 메타정보는 InnoDB 테이블 기반의 딕셔너리에 저장되지만,

MyISAM 이나 CSV 같은 스토리지 엔진을 사용하면 메타 정보가 .sdi라는 파일에 저장된다. 

.sdi는 .FRM과 동일한 역할을 한다.

### 4.2  INNODB 스토리지 엔진 아키텍처

### INNODB 스토리지 엔진 아키텍처

MySQL 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금 제공하며, 
높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2011.png)

### 4.2.1 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링 되어 저장됨

모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키 값을 논리적인 주소로 사용

프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키로 찾는게 빠름

→ 쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높음

MyISAM은 클러스터링 키를 지원하지 않음

프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스

모든 인덱스는 물리적은 레코드의 주소값 (ROWID)를 가짐

### 4.2.2 외래 키 지원

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 
변경 시에 반드시 부모/자식 테이블에 데이터가 있는지 확인하는 작업이 필요하므로 잠금이 여러 테이블로 전파되어 데드락이 발생할 때가 많음
→ 개발할 때 외래키의 존재에 주의

foreign_key_check 시스템 변수를 OFF 로 설정하면, 외래키 관계에 대한 체크 작업을 멈출 수 있다.

```sql
SET foreign_key_check=OFF; (세션 키워드가 없으면 자동으로 현재 세션의 설정만 변경)
SET SESSION foreign_key_check=OFF;
```

### 4.2.3 MVCC (Multi Version Concurrency Control)

목적: 잠금을 사용하지 않는 일관된 읽기를 제공하기 위함

언두 로그 를 사용해 MVCC 기능을 구현

```sql
한건 INSERT 하면 아래와 같이 디스크, 버퍼 풀에 저장됨
INSERT INTO member(id, name, area) VALUES (1, "MangKyu", "서울");
```

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2012.png)

```sql
한건 UPDATE 하면 아래와 같이 버퍼 풀이 변경되고 Undo로그에 이전 값이 저장됨
UPDATE member SET area = "경기" WHERE id = 1;
```

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2013.png)

```sql
위 트랜잭션이 커밋되기 전에 새로운 트랜잭션이 SELECT 를 하면 언두로그의 값인 서울이 리턴됨
(격리수준 READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE인 경우)
SELECT * FROM member WHERE id = 1;
```

트랜잭션이 길어지면 언두 로그가 많아진다.

롤백하면 언두 로그의 데이터가 버퍼 풀로 복구된다.

언두 로그를 필요로하는 트랜잭션이 없을 때, 언두 로그가 삭제된다.

### 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

격리 수준이 READ_UNCOMMIT, READ_COMMITTED, REPEATABLE_READ 수준인 경우, 
INSERT 와 연결되지 않은 SELECT 작업은 MVCC 기술을 이용해 잠금없이 읽는다.

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2014.png)

### 4.2.5 자동 데드락 감지

내부적으로 잠금이 교착상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.

데드락 감지 스레드가 주기적으로 잠금 대기 목록을 검사해서 교착 상태의 트랜잭션을 종료한다.
이때, 언두 로그의 양이 적은 트랜잭션이 종료된다.

일반적인 서비스에서는 데드락 감지 스레드의 작업은 부담이 되지 않는다.

하지만, 동시 처리 스레드가 많아지거나, 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다.

데드락 감지 스레드는 잠금 대기 목록의 테이블들에 새로운 잠금을 걸고 데드락 스레드를 찾기 때문에, 데드락 감지 스레드가 느려지면 서비스가 느려진다.

위와같은 문제를 해결하기 위해 innodb_deadlock_detect 를 OFF로 설정하면 데드락 감지 스레드를 멈출 수 있다.

위 설정 후, innodb_lock_wait_timeout으로 데드락이 일정 시간 후에 자동으로 종료되도록 할 수 있다.

### 4.2.6 자동화된 장애 복구

디스크나 서버 하드웨어 문제로 InnoDB 스토리지 엔진이 자동으로 복구를 못하는 일이 발생할 수 있다.

이떄, innodb_force_recovery 변수를 조절해서 MySQL 서버를 시작하면 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행한다.

- 로그 파일이 손상되었으면 innodb_force_recovery 를 6으로 설정
- 테이블의 데이터 파일이 손상되었으면 innodb_force_recovery 를 1로 설정

innodb_force_recovery 를 1~6까지 설정하면서 MySQL 을 재시작 하면 된다.

숫자가 클 수록 심각한 상황이며, 복구 가능성은 낮아진다.

6까지 해도 MySQL 서버가 실행되지 않으면 마지막 백업으로 데이터베이스를 다시 구축하자.

---

### 4.2.7 InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 디스크 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간

### 버퍼 풀 크기 설정

운영체제의 전체 메모리 공간이 8GB 미만이면 50%정도만 InnoDB 버퍼풀로 사용
나머지 공간은 MySQL 서버와 운영체제, 다른 프로그램을 위한 공간으로 사용

8GB 이상이면, 50%에서 조금씩 올리고 

50GB 이상이면 대략 15~30GB정도를 MySQL 서버와 운영체제에 사용
나머지를 InnoDB 버퍼 풀로 사용

innodb_buffer_pool_size 시스템 변수로 설정 가능

→ 더 크게 변경하는 것은 시스템 영향도 적음

→ 더 작게 변경하는 것은 서비스 영양도 매우 큼

innodb_buffer_pool_instance 시스템 변수로 버퍼 풀 인스턴스 개수 설정 가능

→ 기본값 : 8개, 메모리 1GB 미만이면 1개

→ 40GB 이상이면 5GB 단위로 인스턴스를 설정하는게 적절

### 버퍼 풀의 구조

innodb_page_size 설정값만큼 조각을 분리해서 관리

LRU (Least Recently Used) 리스트, Flush 리스트, Free 리스트 라는 3개의 자료 구조를 관리

- 프리 리스트: 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용
- LRU 리스트
    
    ![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2015.png)
    
    Old 리스트: LRU 
    
    New 리스트: MRU (Most Recently Used)
    

자주 사용하는 데이터는 New 리스트로 이동, 사용되지 않는 데이터는 Old 리스트로 이동후 제거된다.

- 플러시 리스트: 디스크로 동기화 되지 않은 데이터를 가진 데이터 페이지 (더티 페이지)의 변경 시점 기준의 페이지 목록을 관리

### 버퍼 풀과 리두 로그

InnoDB 버퍼 풀은 클수록 쿼리의 성능이 빨라진다.

버퍼풀은 데이터 캐시, 쓰기 버퍼링 두가지 용도로 사용되는데 
단순히 버퍼풀의 크기만 늘리면 캐시 기능만 향상된다.

쓰기 버퍼링 기능도 향상시키려면 리두 로그 크기도 증가시켜야 된다.

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2016.png)

- 활성 리두 로그(Active Redo Log): 리두 로그 공간중 재사용이 불가능한 공간
- LSN(Log Sequence Number): 리두 로그 파일의 공간이 사용될때마다 증가하는 값
리두 로그, 버퍼풀 더티 페이지를 디스크로 동기화할때 체크포인트 이벤트를 발생시키는데 가장 최근 체크포인트지점의 LSN이 활성 리두 로그 공간의 시작점이 된다.
- 체크포인트 에이지(Checkpoint Age): 가장 최근 체크포인트 LSN과 마지막 리두 로그 엔트리의 LSN 차이
활성 리두 로그 공간의 크기

체크포인트가 발생하면 체크포인트 LSN 보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화 되어야 함

일반적으로 버퍼풀의 크기가 100GB 이하의 MySQL 서버에서는 리두로그 파일의 전체 크기가 5~10GB가 적절하다.

### 버퍼 풀 플러시(Buffer Pool Flush)

더디페이지 플러시: 더티 페이지를 디스크에 동기화 하는 부분

**플러시 리스트 플러시**

주기적으로 플러시 리스트 플러시 함수를 호출해서 오래전에 변경된 데이터 페이지를 디스크에 동기화시킨다.

클리너 스레드(Cleaner Thread) : 더티 페이지를 디스크로 동기화시키는 스레드

innodb_page_cleaner: 클리너 스레드 개수 설정

innodb_max_dirty_pages_pct: 버퍼 풀의 더티페이지 공간 비율

innodb_io_capacity: 더티 페이지 쓰기를 실행하는 기준

innodb_max_dirty_pages_pct_lwm: 일정 수준의 더티 페이지가 넘어가면 디스크로 기록하게 하는 기준

어댑티브 플러시 (Adaptive flush)

innodb_adaptive_fushing: 기능 on/off (default: on)

어떤 알고리즘을 사용해서 리두 로그 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행

innodb_adaptive_flushing_lwm: 해당 변수이상으로 활성 리두 로그가 쌓이면, 어댑티브 플러시가 작동

위 값들은 전부다 기본값을 추천한다.

LRU **리스트 플러시**

사용빈도가 낮은 데이터 페이지를 제거할때 LRU 리스트 플러시 사용

LRU 리스트의 끝부분부터 최대 innodb_lru_scan_depth 만큼 페이지를 스캔해서
더티페이지는 디스크에 동기화, 클린 페이지는 프리 리스트 페이지로 이동

### 버퍼 풀 상태 백업 및 복구

워밍업: 디스크 데이터가 버퍼풀에 적재된 상태

MySQL 5.6 부터 버퍼 풀 덤프 및 적재 기능 도입

```sql
서버 셧다운 전에 버퍼 풀 상태 백업
SET GLOBAL innodb_buffer_pool_dump_now=ON;

서버 재시작 후, 백업된 버퍼 풀 상태 복구
SET GLOBAL innodb_buffer_pool_load_now=ON;

버퍼 풀 복구 중지
SET GLOBAL innodb_buffer_pool_load_abort=ON;
```

버퍼 풀 백업은 빠르나, 버퍼 풀 복구는 느릴 수 있다.

```sql
버퍼 풀 복구 상태 확인 명령어
SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G
```

InnoDB 스토리지 엔진은 아래 설정으로 서버가 셧다운되기 직전, 시작된 후에 백업/복구를 자동화 할수 있다.

```sql
innodb_buffer_pool_dump_at_shutdown
innodb_buffer_pool_load_at_startup
-> MySQL 설정 파일에 추가
```

### 버퍼 풀의 적재 내용 확인

MySQL 5.6 부터 information_schema 의 innodb_buffer_page로 어떤 테이블이 버퍼 풀에 적재되었는지 확인 가능

InnoDB 버퍼 풀 크기가 큰 경우, 조회에 부하가 크다는 문제가 있음

MySQL 8.0 부터는 information_schema 에 innodb_cached_indexes 가 추가되어서 빠르게 확인 가능

### 4.2.8 Double Write Buffer

파셜 페이지(Partial-page), 톤 페이지(Torn-page): 더티 페이지를 디스크 파일로 플러시 할 때, 일부만 기록되는 현상
하드웨어의 오작동이나 시스템의 비정상 종료등으로 발생 가능

위 문제를 막기 위해 Double-Write 기법 사용 : innodb_doublewrite 로 ON/OFF 가능

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2017.png)

실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 묶어서 DoubleWrite 버퍼에 저장
그 후에 각 더티 페이지를 파일에 랜덤으로 저장

만약, A~E를 데이터파일에 저장하는과정에 오류가 발생하면
DoubleWrite 버퍼를 다시 데이터 파일에 저장시킨다.

HDD에서는 부담이 없지만 SSD에서는 부담스러운 기능이므로 데이터 무결성이 중요하면 사용하고 아니면 사용하지 않아도 된다.

리두 로그 동기화 설정 (innodb_flush_log_at_trx_commit 이 1이 아님) 이 비활성이면 
DoubleWrite도 비활성하는것이 좋다.

### 4.2.9 언두 로그

언두로그: DML로 변경되기 이전 버전의 데이터를 별도로 백업한 것

언두로그의 사용처

- 트랜잭션 보장: 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해 둔 이전 버전의 데이터를 이용해 복구한다.
- 격리 수준 보장: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면, 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해 둔 데이터를 읽어서 반환하기도 한다.

### 언두 로그 모니터링

MySQL 5.5 이전에는 한번 늘어난 언두 로그 용량이 줄지 않음

→ MySQL 5.7 부터는 필요한 시점에 사용 공간을 줄여 줌

트랜잭션관리가 제대로 되지 않으면 언두 로그가 많이 쌓일 수 있음

언두 로그가 많이 쌓이면 조회 쿼리 성능이 떨어짐

→ 활성 상태의 트랜잭션을 장기간 유지하지 않기위해 언두 로그 건수를 모니터링 해야 한다.

```sql
// 모든 버전 명령어
SHOW ENGINE INNODB STATUS \G

// MySQL 8.0 명령어
SELECT count
FROM information_schema.innodb_metrics
WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
```

### 언두 테이블스페이스 관리

언두 테이블스페이스: 언두 로그가 저장되는 공간

![Untitled](Chapter%2004%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%2045949ee9a4a44eb5a84021cf9ea72c15/Untitled%2018.png)

언두 테이블 스페이스는 1~128개의 롤백 세그먼트를 가진다.

롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다. (InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수만큼)

동시 트랜잭션 최대 개수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)

(일반적으로 131072개)

MySQL8.0 부터는 CREATE UNDO TABLESPACE, DROP TABLESPACE 명령어로 언두 테이블 스페이스를 동적으로 추가/삭제할수 있다.

Undo tablespace truncate: 언두 테이블 스페이스 공간을 필요한 만큼만 남기고 운영체제로 반납하는것

- 자동 모드: 퍼지 스레드 (Purge Thread) 가 주기적으로 불필요한 언두 로그 삭제
innodb_undo_log_truncate 가 ON이어야 동작
- 수동 모드: 언두 테이블 스페이스를 수동으로 비활성화 하면, 퍼지 스레드가 비활성화된 언두 테이블 스페이스를 반납
언두 테이블 스페이스가 최소 3개 이상이어야 작동

```sql
언두 테이블 스페이스 비활성화
ALTER UNDO TABLESPACE tablespace_nae SET INACTIVE;
```

---
# Chapter 04 아키텍처

## 4.2 INNODB 스토리지 엔진 아키텍처

- **4.2.10 체인지 버퍼**
    
    RDBMS에서 레코드가 INSERT or UPDATE 될 때 데이터 파일만 변경하는 것이 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요함
    
    인덱스를 업데이트하는 작업
    
    랜덤하게 디스크를 읽는 작업이 필요
    
    테이블에 인덱스가 많다면 많은 자원을 소모하게 됨
    
    InnoDB
    
    변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행
    
    디스크로부터 읽어와서 업데이트해야 하는 경우
    
    즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상
    
    이때 사용하는 **임시 메모리 공간** → **체인지 버퍼**
    
    유니크 인덱스
    
    사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 함
    
    체인지 버퍼를 사용할 수 없음
    
    체인지 버퍼에 임시로 저장된 인덱스 레코드 조각
    
    백그라운드 스레드에 의해 병합 → **체인지 버퍼 머지 스레드**
    
    MySQL 5.5 이전 버전
    
    INSERT 작업만 가능
    
    MySQL 8.0 버전
    
    INSERT, DELETE, UPDATE 작업 모두 가능
    
    innodb_change_buffering
    
    MySQL 5.5 이전 버전
    
    별도의 시스템 변수 설정 없이 기본적으로 기능이 활성화
    
    MySQL 5.5 이후 버전
    
    innodb_change_buffering 시스템 변수 도입으로 각각 종류별로 체인지 버퍼 활성화 가능
    
    ```kotlin
    all: 모든 인덱스 관련 작업(inserts, deletes, purges)을 버퍼링
    none: 버퍼링 안함
    inserts: 인덱스에서 새로운 아이템을 추가하는 작업만 버퍼링
    deletes: 인덱스에서 기존 아이템을 삭제하는 작업(삭제 됐다는 마킹 작업)만 버퍼링
    changes: 인덱스에 추가하고 삭제하는 작업반(inserts, deletes) 버퍼링
    purges: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)
    ```
    
    InnoDB 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정돼 있음
    
    50%까지 사용하게 설정 가능
    
    innodb_change_buffer_max_size 시스템 변수로 비율 설정 가능
    
    ```sql
    select event_name, current_number_of_bytes_used
    from performance_schema.memory_summary_global_by_event_name
    where event_name = 'memory/innodb/ibuf0ibuf';
    ```
    
- **4.2.11 리두 로그 및 로그 버퍼**
    
    리두 로그(Redo Log)
    
    하드웨어나 소프트웨어 등 여러 가지 문제로 인해 서버가 비정상적으로 종료됐을 때 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치
    
    영속성과 밀접한 관련
    
    거의 모든 DBMS
    
    쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있음
    
    변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용 필요
    
    성능 저하를 막기 위해 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있음
    
    서버가 비정상 종료되는 경우 InnoDB 스토리지 엔진의 데이터 파일이 가지게 되는 일관되지 않은 데이터
    
    커밋됐지만 데이터 파일에 기록되지 않은 데이터
    
    리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하면 됨
    
    롤백됐지만 데이터 파일에 이미 기록된 데이터
    
    리두 로그로는 해결 불가능
    
    변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에  복사
    
    리두 로그로 커밋, 롤백, 트랜잭션 상태 등을 확인
    
    트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장
    
    서버가 비정상적으로 종료됐을 때 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록 및 복구 가능
    
    innodb_flush_log_at_trx_commit
    
    리두 로그를 어느 주기로 디스크에 동기화할지 결정하는 환경 변수
    
    ```kotlin
    0: 1초에 한 번씩 기록, 동기화 실행
    1: 매번 트랜잭션이 커밋될 때마다 기록, 동기화 수행
    2: 매번 트랜잭션이 커밋될 때마다 기록 수행, 동기화는 1초에 한 번씩
    ```
    
    0이나 2로 설정되는 경우 항상 1초 간격으로 실행되는 것은 아니고, 스키마 변경을 위한 DDL이 실행되면 리두 로그가 디스크로 동기화되기 때문에 1초보다 간격이 작을 수도 있음
    
    innodb_flush_log_at_timeout
    
    디스크 동기화 시간 간격을 변경하는 시스템 변수
    
    기본값은 1초
    
    보통은 잘 사용하지 않음
    
    리두 로그 파일들의 전체 크기
    
    InnoDB 스토리지 엔진이 가지고 있는 버퍼 풀의 효율성을 결정하기 때문에 신중하게
    
    적절히 선택돼야 InnoDB 스토리지 엔진이 적절히 변경된 내용을 버퍼 풀에 모았다가 한 번에 기록 가능
    
    변경 작업이 많은 서버의 경우 리두 로그 기록 작업이 큰 문제가 되는데 이를 보완하기 위해 ACID 속성을 보장하는 수준에서 버퍼링
    
    = innodb_log_file_size * innodb_log_files_in_group
    
    innodb_log_file_size
    
    리두 로그 파일을 설정하는 시스템 변수
    
    innodb_log_files_in_group
    
    리두 로그 파일의 개수를 설정하는 시스템 변수
    
- **4.2.11.1 리두 로그 아카이빙**
    
    MySQL 8.0 버전부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙할 수 있는 기능이 추가됨
    
    데이터 변경이 많아서 리두 로그가 덮어쓰인다고 해도 백업이 실패하지 않음
    
    백업 툴이 리두 로그 아카이빙 사용하는 방법
    
    1. 리두 로그가 저장될 디렉터리 설정
        
        innodb_redo_log_archive_dirs
        
        아카이빙된 리두 로그가 저장될 디렉터리를 설정하는 시스템 변수
        
        해당 디렉터리는 운영체제의 MySQL 서버를 실행하는 유저만 접근이 가능해야 함
        
    2. innodb_redo_log_archive_start(UDF: 사용자 정의 함수) 실행
        
        innodb_redo_log_archive_start
        
        첫 번째 파라미터: 리두 로그를 아카이빙할 디렉터리에 대한 레이블
        
        두 번째 파라미터: 서브디렉터리명 / 필수값 X(innodb_redo_log_archive_dirs 시스템 변수에 있는 값 사용)
        
        세션이 끊어지면 리두 로그 아카이빙을 멈추고 아카이빙 파일도 자동으로 삭제됨
        
    3. innodb_redo_log_archive_stop UDF 실행
        
        리두 로그 아카이빙 종료
        
        InnoDB 스토리지 엔진은 리두 로그 아카이빙을 멈추고 아카이빙 파일도 종료
        
        삭제하지는 않음 / 사용자가 수동으로 삭제해야 함
        
    
- **4.2.11.2 리두 로그 활성화 및 비활성화**
    
    MySQL 8.0 버전부터 수동으로 리두 로그 활성화 및 비활성화 가능
    
    ```sql
    SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enables';   -- 활성화 여부 조회
    ALTER INSTANCE DISABLE INNODB REDO_LOG;              -- 비활성화
    ALTER INSTANCE ENABLE INNODB REDO_LOG;               -- 활성화
    ```
    
    데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화하여 데이터의 적재 시간 단축 가능(작업이 종료된 후 다시 활성화 꼭 하기)
    
    데이터 일부가 손실돼도 괜찮으면 비활성화하는 것보다 innodb_flush_log_at_trx_commit 시스템 변수를 0 또는 2로 설정해서 사용하는 것을 권장
    
- **4.2.12 어댑티브 해시 인덱스**
    
    InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
    
    innodb_adaptive_hash_index
    
    어댑티브 해시 인덱스 기능 활성화 여부를 설정하는 시스템 변수
    
    자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만듦
    
    필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있음
    
    루트 노트부터 리프 노트까지 찾아가는 비용(B-Tree)이 없어지면서 CPU는 그만큼 적은 일을 하지만 쿼리의 성능은 빨라짐
    
    그와 동시에 더 많은 쿼리를 동시에 처리 가능
    
    해시 인덱스
    
    인덱스 키 값 / 데이터 페이지 주소
    
    인덱스 키 값
    
    B-Tree 인덱스의 고유번호 / B-Tree 인덱스의 실제 키 값
    
    InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재
    
    모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장
    
    특정 키 값이 어느 인덱스에 속한 것인지도 구분이 필요
    
    데이터 페이지 주소
    
    실제 키 값이 저장된 데이터 메모리 주소
    
    InnoDB 버퍼 풀에 로딩된 페이지 주소
    
    어댑티드 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리
    
    버퍼 풀에 해당 페이지가 없어지면 어댑티드 해시 인덱스에서도 해당 페이지의 정보는 사라짐
    
    MySQL 8.0 이전까지는 어댑티브 해시 인덱스가 하나의 메모리 객체인 이유로 경합이 심했음
    
    MySQL 8.0 이후부터는 내부 잠금(세마포어) 경합을 줄이기 위해 파티션 기능을 제공
    
    innodb_adaptive_hash_index_parts
    
    파티션 개수를 설정하는 시스템 변수
    
    기본값은 8개
    
    어댑티브 해시 인덱스가 성능에 많은 도움이 된다면 파티션 개수를 많이 설정하는 것도 내부 잠금 경합을 줄이는 것에 도움이 될 것
    
    성능 향상에 크게 도움이 되지 않는 경우
    
    디스크 읽기가 많은 경우
    
    특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
    
    매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
    
    성능 향상에 많은 도움이 되는 경우
    
    디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
    
    동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
    
    쿼리가 데이터 중에서 일부 데이터에 집중되는 경우
    
    어댑티브 해시 메모리를 사용할 때 참고해야 할 것
    
    저장 공간인 메모리를 사용(때로는 상당히 큰 메모리 공간을 사용)
    
    불필요한 경우 제거되어야 함
    
    인덱스의 효율이 없는 경우에도 InnoDB는 계속 해시 인덱스를 사용할 것
    
    테이블 DELETE or ALTER 작업
    
    테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야 함
    
    많은 CPU 자원을 사용함 → 데이터베이스 서버의 처리 성능이 느려짐
    
    어댑티브 해시 인덱스의 도움을 많이 받을수록 테이블 삭제, 변경 작업이 더 치명적이게 됨
    
    어댑티브 해시 인덱스가 도움이 되는지 아니면 불필요한 오버헤드를 만들고 있는지 판단하는 법
    
    MySQL 서버의 상태 값들을 확인
    
    ```sql
    SHOW ENGINE INNODB STATUS;
    
    -- 결과값
    -- 1.03 hash searches/s, 2.64 non-hash searches/s
    -- searches: 쿼리가 처리되기 위해 내부적으로 키 값의 검색이 몇 번 실행됐는지
    -- 초당 3.67(1.03 + 2.64)번의 검색 실행
    -- 1.03번은 어댑티브 해시 인덱스 사용 O
    -- 2.64번은 어댑티브 해시 인덱스 사용 X
    
    -- 어댑티브 해시 인덱스의 효율
    -- 두 값의 비율(해시 인덱스 히트율)과 어댑티브 해시 인덱스가 사용 중인 메모리 공간, 서버의 CPU 사용량을 종합해서 판단
    ```
    
- **4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교**
    
    MyISAM
    
    MySQL 5.5 이전까지 기본 스토리지 엔진으로 많이 사용
    
    이후에도 기본 스토리지 엔진은 아니지만 시스템 테이블(사용자 인증 관련된 정보와 복제 관련된 정보가 저장된 mysql DB의 테이블)로는 여전히 사용됨
    
    MySQL 8.0 이전까지는 MyISAM 제외하고 전문 검색이나 공간 좌표 검색 기능을 제공하지 않음
    
    InnoDB의 기능 개선과 함께 도태되는 상황
    
    이후 버전에서는 없어질 것으로 예상
    
    InnoDB
    
    MySQL 5.5 이후부터 기본 스토리지 엔진 채택
    
    MySQL 8.0 이후부터 모든 시스템 테이블이 InnoDB로 교체
    
    전문 검색 및 공간 좌표 검색도 지원
    
    서버의 모든 기능을 InnoDB 스토리지 엔진만으로 구현 가능
    
    MySQL 5.1, 5.5 버전에서는 MEMORY or MyISAM과의 비교가 의미 있었으나, MySQL 8.0 이후부터는 무의미한 비교가 됨
    
    MEMORY
    
    이름 때문에 과대평가 받음
    
    동시 처리 성능
    
    InnoDB 따라갈 수 없음
    
    하나의 스레드에서만 데이터를 읽고 쓴다면 InnoDB보다 빠를 수 있지만 그럴 경우 거의 없음
    
    MySQL 5.7 이전까지 내부 임시 테이블의 용도로 사용
    
    가변 길이 타입의 컬럼을 지원하지 않는다는 문제점이 있음
    
    MySQL 8.0 이후부터는 TempTable 스토리지 엔진으로 대체
    
    MEMORY와 TempTable 중에 선택 가능하나 MEMORY의 장점이 없음
    
    이후 버전에서는 없어질 것으로 예상
    
    지금도 이전 버전과의 호환성 유지 차원임
    

## 4.3 MyISAM 스토리지 엔진 아키텍처

- **4.3.1 키 캐시**
    
    인덱스만을 대상으로 작동
    
    인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할
    
    InnoDB의 버퍼 풀과 비슷한 역할
    
    키 캐시가 얼마나 효율적으로 작동하는지
    
    ```sql
    키 캐시 히트율(Hit rate0 = 100 - (Key_reads / Key_read_requests * 100)
    ```
    
    Key_reads
    
    인덱스를 디스크에서 읽어 들인 횟수를 저장하는 상태 변수
    
    Key_read_Requests
    
    키 캐시로부터 인덱스를 읽은 횟수를 저장하는 상태 변수
    
    ```sql
    SHOW GLOBAL STATUS LIKE 'Key%';
    ```
    
    일반적으로 키 캐시를 이용한 쿼리의 비율을 99% 이상으로 유지하라고 권장
    
    99% 미만이라면 키 캐시를 조금 더 크게 설정하는 것이 좋음
    
    32비트 운영체제에서는 하나의 키 캐시에 4GB 이상의 메모리 공간을 설정할 수 없음
    
    64비트 운영체제에서는 OS_PER_PROCESS_LIMIT 값에 설정된 크기만큼의 메모리 할당 가능
    
    제한 값 이상의 키 캐시를 사용하고 싶다면 기본 키 캐시 이외에 별도의 이름이 붙은 키 캐시 공간을 설정
    
    기본 키 캐시 공간 설정 → key_buffer_size
    
    별도의 이름이 붙은 키 캐시 공간 설정 → kbuf_board.key_buffer_size
    
    어떤 인덱스를 캐시할지 MySQL에 알려줘야 함
    
    아니면 메모리만 할당하고 사용하지 않음
    
    ```sql
    CACHE INDEX db1.board, db2.board IN kbuf_board;
    ```
    
- **4.3.2 운영체제의 캐시 및 버퍼**
    
    인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠른 검색 가능
    
    데이터에 대해서는 디스크로부터의 I/O를 해결해 줄 만한 캐시나 버퍼링 기능이 없음
    
    데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기, 쓰기 작업으로 요청
    
    운영체제의 캐시 기능
    
    InnoDB처럼 전문적이지는 못하지만 없는 것보다는 나음
    
    남는 메모리를 사용하는 것이 기본
    
    데이터베이스에서 MyISAM 테이블을 주로 사용한다면 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모리를 비워둬야 쿼리가 느려지는 문제를 방지할 수 있음
    
- **4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조**
    
    프라이머리 키에 의한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용됨
    
    레코드는 프라이머리 키 값과 무관하게 INSERT되는 순서대로 데이터 파일에 저장
    
    테이블에 저장되는 레코드는 모두 ROWID라는 물리적인 주솟값을 가짐
    
    프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가짐
    
    ROWID 저장 방법
    
    고정 길이
    
    자주 사용되지 않음
    
    테이블을 생성할 때 MAX_ROWS 옵션을 명시하면 MySQL 서버는 최대로 가질 수 있는 레코드가 한정된 테이블을 생성 → 레코드의 개수가 한정되면 ROWID 값으로 4바이트 정수를 사용
    
    INSERT된 순번이 ROWID로 사용
    
    가변 길이
    
    MAX_ROWS 옵션을 설정하지 않으면 ROWID는 최대 myisam_data_pointer_size 시스템 변수에 설정된 바이트 수만큼 공간 사용 가능 → 기본값 7 (최대 256TB)
    
    2~7바이트까지 가변적인 ROWID를 갖고, 첫 번째 바이트는 ROWID의 길이를 저장하는 용도로 사용
    

## 4.4 MySQL 로그 파일

- **4.4.1 에러 로그 파일**
    
    에러 로그 파일
    
    MySQL이 실행되는 도중에 발생하는 에러나 경고 메세지가 출력
    
    my.cnf 파일 log_error 파라미터로 정의된 경로에 생성
    
    정의되어 있지 않은 경우에는 datadir 파라미터에 설정된 디렉터리에 .err 확장자가 붙어서 생성
    
    MySQL이 시작하는 과정과 관련된 정보성 및 에러 메세지
    
    MySQL의 설정 파일을 변경하거나 데이터베이스가 비정상적으로 종료된 이후 다시 시작하는 경우
    
    MySQL 에러 로그 파일을 통해 잘 적용됐는지 확인 필요 
    
    서버가 정상적으로 기동했는지(mysqld: ready for connections) 확인
    
    새로 변경하거나 추가한 파라미터에 대한 특별한 에러가 없는지 확인
    
    특정 변수가 ignore된 경우에는 서버는 잘 작동했지만 변수는 적용되지 못했음을 의미
    
    마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메세지
    
    MySQL 서버가 비정상적 또는 강제적으로 종료됐다면 다시 시작되면서 완료되지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 진행
    
    문제가 있을 경우 에러 메세지 출력 후 다시 종료
    
    자세한 건 4.2.6장 or MySQL 매뉴얼 참조
    
    쿼리 처리 도중에 발생하는 문제에 대한 에러 메세지
    
    쿼리 도중 발생하는 문제점은 사전 예방이 어려움
    
    주기적으로 에러 로그 파일을 검토하는 과정에서 알게됨
    
    에러 로그를 자주 검토하는 것이 데이터베이스의 숨겨진 문제를 해결하는 데 많은 도움이 될 것
    
    비정상적으로 종료된 커넥션 메세지(Aborted connection)
    
    애플리케이션이 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 에러 로그 파일에 기록
    
    중간에 네트워크에 문제가 있어서 의도하지 않게 접속이 끊어지는 경우에도 기록
    
    InnoDB의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS 같은)의 결과 메세지
    
    테이블 모니터링, 락 모니터링, 엔진 상태를 조회하는 명령은 상대적으로 큰 메세지를 에러 로그 파일에 기록
    
    모니터링을 활성화 상태로 유지하면 에러 로그 파일이 커져서 파일 시스템 공간을 다 사용할 수도 있음
    
    모니터링을 사용한 후에는 다시 비활성화하여 로그 파일이 커지지 않도록
    
    MySQL 종료 메세지
    
    MySQL이 마지막으로 종료되면서 출력한 메세지를 통해 종료된 이유를 알 수 있음
    
- **4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)**
    
    MySQL 서버에서 실행되는 전체 쿼리 목록 검토
    
    쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일에 기록해서 그 파일을 확인
    
    시간 단위로 실행했던 쿼리의 내용이 모두 기록
    
    MySQL이 쿼리 요청을 받으면 바로 기록
    
    쿼리 실행 중에 에러가 발생해도 일단 기록
    
    general_log_file
    
    쿼리 로그 파일 경로가 저장되어 있는 파라미터
    
    log_output
    
    파일에 저장할지 테이블에 저장할지 설정하는 파라미터
    
    자세한 건 [MySQL 매뉴얼](https://dev.mysql.com/doc/refman/8.0/en/log-destinations.html) 참조
    
- **4.4.3 슬로우 쿼리 로그**
    
    쿼리 튜닝
    
    서비스가 적용되기 전에 전체적으로 하는 튜닝
    
    모든 쿼리가 대상
    
    서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사 or 정기적인 점검을 위한 튜닝
    
    어떤 쿼리가 문제의 쿼리인지 판단하기 어려움
    
    슬로우 쿼리 로그가 많은 도움이 됨
    
    long_query_time
    
    슬로우 쿼리 로그 파일에 기록되는 기준 쿼리 시간
    
    해당 시간보다 더 오래 걸릴 경우 기록
    
    마이크로 초 단위로 설정 가능
    
    실제 소요된 시간을 기준으로 기록 여부 결정
    
    중간에 실패하면 기록되지 않음
    
    log_output
    
    슬로우 쿼리 로그를 파일로 기록할지 테이블로 기록할지 설정하는 옵션
    
    TABLE
    
    general_log, slow_log 테이블에 저장
    
    csv 스토리지 엔진을 사용하기 때문에 결국에는 csv 파일로 저장하는 것과 동일하게 작동
    
    FILE
    
    디스크의 파일로 저장
    
    슬로우 쿼리 로그 내용
    
    Time: 쿼리가 종료된 시점
    
    User@Host: 쿼리를 실행한 사용자의 계정
    
    Query_time: 쿼리가 실행되는 데 걸린 전체 시간
    
    Lock_time: 테이블 잠금에 대한 대기 시간(실제 쿼리가 실행되는 데 필요한 잠금 체크와 같은 코드 실행 부분의 시간까지 포함 / 매우 작은 값이면 무시해도 무방)
    
    Rows_examined: 쿼리가 처리되기 위해 몇 건의 레코드에 접근했는지
    
    Rows_sent: 실제 몇 건의 처리 결과를 클라이언트로 보냈는지
    
    내용이 많아서 직접 쿼리를 하나씩 검토하기에는 너무 많은 시간이 걸리고, 어느 쿼리를 집중적으로 튜닝해야 할지 식별하기 어려움
    
    Percona Toolkit
    
    pt-query-digest 스크립트를 이용하면 쉽게 빈도나 처리 성능별로 쿼리를 정렬해서 볼 수 있음
    
    ```bash
    ## General Log 파일 분석
    pt-query-digest --type='genlog' general.log > parsed_general.log
    
    ## Slow Log 파일 분석
    pt-query-digest --type='slowlog' mysql-slow.log > parsed_mysql-slog.log
    ```
    
    로그 파일의 분석이 완료되면 그 결과는 3개의 그룹으로 나뉘어 저장
    
    슬로우 쿼리 통계
    
    분석 결과의 최상단에 표시
    
    모든 쿼리를 대상으로 슬로우 쿼리 로그의 실행 시간, 잠금 대기 시간 등에 대해 평균 및 최소/최대 값을 표시
    
    실행 빈도 및 누적 실행 시간순 랭킹
    
    각 쿼리별로 응답 시간과 실행 횟수를 보여줌
    
    pt-query-digest 명령 실행 시 —order-by 옵션으로 정렬 순서 설정 가능
    
    동일 모양의 쿼리는 동일한 Query Id를 가짐
    
    Query Id: 실행된 쿼리 문장을 정규화해서 만들어진 해시 값
    
    쿼리별 실행 횟수 및 누적 실행 시간 상세 정보
    
    Query Id별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여줌
    
    상세한 쿼리 내용은 개별 쿼리의 정보를 확인해 보면 됨
    
    쿼리가 얼마나 실행됐는지
    
    쿼리의 응답 시간에 대한 히스토그램
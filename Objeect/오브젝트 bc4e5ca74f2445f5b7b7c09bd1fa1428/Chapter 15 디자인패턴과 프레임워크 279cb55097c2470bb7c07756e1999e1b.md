# Chapter 15 디자인패턴과 프레임워크

소프트웨어 설계에서 반복적으로 발생하는 문제에 대해
반복적으로 적용할 수 있는 해결 방법을 **디자인 패턴**이라고 부른다.

설계와 코드를 함께 재사용하기 위한 것을 **프레임워크**라고 부른다.

### 1. 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

아래는 패턴이란 무엇인가에 대해 논의할 때마다 언급되는 몇 가지 핵심 특징이다.

- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며,
이 지식을 다른 사람과 의사소통할 수 있다.
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 실무에서 탄생했다는 점이다.

오브젝트에서 선호하는 패턴의 정의는 마틴 파울러의 아래 문장이다.

> 내가 사용하는 패턴 정의는 **하나의 실무 컨텍스트에서 유용하게 사용해 왔고
다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어**다.
아이디어라는 용어를 사용하는 이유는 어떤 것도 패턴이 될 수 있기 때문이다.
패턴은 “GoF”에서 이야기하는 것처럼
협력하는 객체 그룹일 수도 있고, 프로젝트 조직 원리일 수도 있다.
실무 컨텍스트라는 용어는 패턴이 실무 프로젝트에서 비롯됐다는 사실을 반영한다.
흔히 패턴을 ‘발명했다’고 하지 않고 ‘발견했다’고 말한다.
모델의 유용성이 널리 받아들여지는 경우에만 패턴으로 인정할 수 있기에 타당하지만
그렇다고 실무 프로젝트의 모든 아이디어가 패턴인 것은 아니다.
: 패턴은 개발자들이 다른 컨텍스트에서도 유용할 것이라고 생각하는 어떤 것이다.
> 

패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 ‘아이디어’다.

일반적으로 최소 세 가지의 서로 다른 시스템에 문제 없이 적용할 수 있고
유용한 경우에만 패턴으로 간주할 수 있다.
→ 3의 규칙

- 패턴은 경험의 산물이다.
    - 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을
    효과적으로 요약하고 전달할 수 있다는 점이다.
    - 실무 경험이 적은 초보자라 해도 패턴을 익히고 반복적으로 적용하는 과정 속에서
    유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.
- 패턴의 이름은 지식 전달과 커뮤니케이션의 수단이다.
    - 패턴의 이름은 커뮤니티가 공유할 수 있는 중요한 어휘집을 제공하고,
    수준 높은 대화를 가능케 한다.
    잘 알려진 이름을 통해 아래와 같은 상황을 방지할 수 있다.
        
        “인터페이스를 하나 추가해 이 인터페이스를 구체화 하는 클래스를 만든 후
        객체의 생성자나 setter 메서드에 할당해서 런타임 시 알고리즘을 바꿀 수 있게 하자”
        → **STRATEGY** 패턴을 적용하자로 축약된 대화가 가능
        

마틴 파울러가 언급한 것처럼 패턴의 범위가 분석, 설계, 구현 영역만으로 한정되는 것은 아니다.
다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법,
스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이
반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.

### 패턴 분류

패턴을 분류하는 가장 일반적인 방법은 패턴의 범위, 적용 단계에 따라 4가지로 분류할 수 있다.

- 디자인 패턴
    - 특정 정황 내에서 일반적인 설계 문제를 해결하며,
    협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조
    - 중간 규모의 패턴으로 특정 설계 문제를 해결하는 것을 목적으로 하며,
    프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
- 아키텍처 패턴
    - 디자인 패턴의 상위 패턴으로 소프트웨어의 전체적인 구조를 결정하기 위해 사용한다.
    - 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의,
    서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
    - 이 또한 디자인 패턴과 동일하게 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
- 이디엄
    - 디자인 패턴의 하위 패턴으로 특정 프로그래밍 언어에만 국한된 패턴이다.
    - 주어진 언어의 기능을 사용해 컴포넌트,
    혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
- 분석 패턴
    - 업무 모델링 시 발견되는 공통적인 구조를 표현하는 개념들의 집합으로
    도메인 내의 개념적 문제를 해결하는 데 초점을 맞춘다.
    - 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다.

### 패턴과 책임-주도 설계

객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고
객체 간의 유연한 협력 관계를 구축하는 일이다.

책임과 협력의 윤곽은 다양한 요소들의 트레이드오프를 통해 결정된다.
가끔씩 책임과 협력을 결정하는 작업이 쉽게 진행되는 경우도 있지만
대부분 훌륭한 품질의 설계를 얻기 위해 많은 시간과 노력을 들여야만 한다.

패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는
공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.

GoF의 디자인 패턴에 정리된 패턴을 예로 들어 설명한다.

STRATEGY 패턴은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다.

BRIDGE 패턴은 추상화의 조합으로 인한 클래스 폭발 문제를 해결하기 위해
역할과 책임을 추상화와 구현 두 개의 커다란 집합으로 분해해 설계를 확장 가능하게 만든다.

OBSERVER 패턴은 유연한 통지 메커니즘을 구축하기 위해
객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.

위에서 언급한 패턴들의 세부적인 내용이 중요한게 아니다.
중요한 것은 패턴을 따르면 특정 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실이다.

패턴의 구성 요소는 클래스가 아니라 ‘역할’이다.
아래 그림은 클라이언트가 개별 객체와 복합 객체를
동일하게 취급할 수 있는 COMPOSITE 패턴의 다이어그램이다.

![Untitled](Chapter%2015%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20279cb55097c2470bb7c07756e1999e1b/Untitled.png)

패턴의 구성 요소인 Component, Composite, Leaf 는
클래스가 아니라 협력에 참여하는 객체들의 역할이다.
Component는 역할이기 때문에 Component가 제공하는 오퍼레이션을
구현하는 어떤 객체라도 Component의 역할을 수행할 수 있다.

패턴을 구성하는 요소가 클래스가 아닌 역할이라는 사실은
패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다.

역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시하기에
하나의 객체가 세 가지 역할 모두를 수행하더라도 문제가 없다.
반대로 다수의 클래스가 동일한 역할을 구현할 수도 있다.

계속 말하고있지만 디자인 패턴의 구성 요소가 클래스와 메서드가 아닌
역할과 책임이라는 사실을 이해하는 것이 중요하다.

어떤 디자인 패턴을 따른다 할 때 역할, 책임, 협력의 관점에서 유사성을 공유하는 것이지
특정한 구현 방식을 강요하는 것은 아니라는 점을 이해하는 것 역시 중요하다.

위에서 말한 예제로 하나의 객체가 여러가지 역할을 수행하거나
다수의 클래스가 동일한 역할을 수행하는 두 방법 모두 올바른 COMPOSITE 패턴이다.
이를 통해 패턴을 적용하기 위해서는 패턴에서 제시하는 구조를 그대로 표현하는 것이 아닌
현재의 요구에 맞게 구조를 수정해야 한다는 것을 의미한다.

### 캡슐화와 디자인 패턴

몇 가지 예외 사항을 제외하면 대부분의 디자인 패턴은
협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다.
따라서 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.

영화 예매 시스템에서 상속 계층을 합성 관계로 유지해야 하는 다양한 설계 원칙을 다뤘지만
사실 이 설계는 STRATEGY 패턴을 적용한 예시다.

STRATEGY 패턴은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.

물론 변경을 캡슐화하는 방법이 합성만 있는 것은 아니다.
변경을 캡슐화 하기 위한 또 다른 방법인 상속이 있다.

![Untitled](Chapter%2015%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20279cb55097c2470bb7c07756e1999e1b/Untitled%201.png)

변경하지 않는 부분은 부모 클래스로, 변하는 부분은 자식 클래스로 분리함으로써 변경을 캡슐화한다.
이처럼 알고리즘을 캡슐화하기 위해 상속 관계를 사용하는 것을 TEMPLATE METHOD 패턴이라고 한다.

이처럼 TEMPLATE METHOD 패턴은 부모 클래스가 알고리즘의 기본 구조를 정의하고
구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다.
다만 STRATEGY 패턴처럼 알고리즘을 동적으로 변경하는 것은 불가능하다.
하지만 알고리즘 교체와 같은 요구사항이 없다면 상대적으로 STRATEGY 패턴보다
복잡도를 낮출 수 있다는 면에서는 장점이라고 할 수 있다.

아래 그림은 핸드폰 과금 시스템 다이어그램이다. 해당 설계 구조는 DECORATOR 패턴을 기반으로 한다.
DECORATOR 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로
기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다.

![Untitled](Chapter%2015%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20279cb55097c2470bb7c07756e1999e1b/Untitled%202.png)

대부분의 디자인 패턴의 목적은 특정한 변경을 캡슐화해
유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다.

디자인 패턴에서 중요한 것은 디자인 패턴의 구현 방법이나 구조가 아니다.
어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다.
그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요하다.

### 패턴은 출발점이다

**패턴은 출발점이지 목적지가 아니다**

많은 전문가들은 널리 요구되는 유연성이나 공통적으로 발견되는
설계 이슈를 해결하기 위해 적절한 디자인 패턴을 이용해 설계를 시작한다.

그러나 패턴은 설계의 목표가 돼서는 안 된다.
패턴은 단지 목표로하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.
디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에
적합하지 않다면 패턴을 과감히 목적에 맞게 수정해야 한다.

패턴은 공통적인 문제에 적절한 해법을 제공할 뿐이지 우리가 직면한 모든 문제의 해법이 아니다.
문제를 분석하고 창의력을 발휘해 패턴을 현재의 문제에 적합하도록 적절하게 수정해야 한다.
비록 패턴이 현재의 문제에 들어맞지 않는다 해도 참조할 수 있는
모범적인 역할과 책임의 집합을 알고 있는 것은 큰 도움이 될 것이다.

### 2. 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

오랜시간 동안 개발자들은 기존 컴포넌트를 조립해서 어플리케이션을 구축하는 방법을 추구해왔음
⇒ 아이디어 자체는 이상적이지만, 실제로 적용하는 과정에서 현실적이지 않음.

**애플리케이션**과 **도메인**의 다양성으로인해 두 가지 문제가 아주 비슷한 경우는 거의 없음

따라서 가장 기본이 되는 아주 적은 부분만이 일반화 될 수 있음.
결국 다양한 도메인에 재사용 가능한 컴포넌트라는 개념은 비현실적임

설계를 재사용하면서도 유사한 코드를 반복적으로 구현하는 문제를 피할수 있는 방법을 고민함. 

⇒ 프레임워크 탄생배경

프레임워크란 ‘**추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호 작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계**’ 또는 ‘**애플리케이션 개발자가 현재 요구사항에 맞게 커스터마이징 할 수  있는 애플리케이션의 골격**’ 을 의미함.

- 프레임워크의 구조적인 측면에 초점을 맞춤
    
    ⇒ **추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호 작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계**
    
- 코드와 설계 재사용 이라는 사용목적에 초점을 맞춤
    
    ⇒ **애플리케이션 개발자가 현재 요구사항에 맞게 커스터마이징 할 수  있는 애플리케이션의 골격**
    

프레임워크는 애플리케이션 영역에 걸쳐 공통의 클래스들을 정의해서 일반적인 설계 결정을 미리 내려둠.
프레임워크는 코드의 재사용 보다는 설계 자체의 재사용을 중요시함.

### 상위 정책과 하위 정책으로 패키지 분리하기

프레임워크의 핵심은 추상클래스나 인터페이스와 같은 추상화임

추상 클래스와 인터페이스가 가지는 어떤 특징이 프레임워크의 재사용성을 향상시키는지? 
→ 일관성 있는 협력 이라는 주제와 관련 있음.

협력을 일관성 있고 유연하게 만들기 위해서는 **추상화를 이용해 변경을 캡슐화**해야함.
협력을 구현하는 코드 안의 **의존성**은 가급적이면 **추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성**해야함.

(아래 그림에서)

구체적인 클래스들은 RatePolicy, AdditionalRatePolicy, FeeCondition 에 의존하지만,
추상화들은 구체 클래스에 의존하지 않음. 
→ 이 설계는 의존성역전 원칙에 기반하고 있음.

![Untitled](Chapter%2015%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20279cb55097c2470bb7c07756e1999e1b/Untitled%203.png)

의존성 역전 원칙의 관점에서 세부 사항은 ‘변경’을 의미함.

다양한 어플리케이션에 걸쳐 재사용하고 싶다고 가정해보면,
동일한 역할을 수행하는 객체들 사이의 협력 구조를 다양한 애플리케이션 안에서 재 사용하는것이 핵심임.

---

첫 걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는것임.

중요한것은 패키지 사이의 의존성 방향임, 세부사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야함.

좀 더 나아가 상위정책을 구현하고 패키지가 충분히 안정적으로 성숙하면 분리하여 별도의 배포단위로 만들 수 있음. 
상위 정책 패키지를 여러 애플리케이션에서 재사용할 수 있는 기반이 만들어짐. 다시말해 재사용 가능한 요금 계산 로직을 구현한 프레임워크가 만들어진것임

![Untitled](Chapter%2015%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20279cb55097c2470bb7c07756e1999e1b/Untitled%204.png)

### 제어 역전 원리

의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리임.

추상화와 구체적인 사항이 서로 고립되어 있기 때문에 유지보수 하기 더 쉬움

그림에서 전체적인 협력 흐름은 프레임워크에 정의돼 있음. FeeCondition을 대체할 서브타입만 개발하면 프레임워크에 정의된 플로우에 따라 요금이 계산됨.

![Untitled](Chapter%2015%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%20279cb55097c2470bb7c07756e1999e1b/Untitled%205.png)

프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둠.
이렇게 완성되지 않은 채로 남겨진 동작을 훅(hook)라고 부름.

재정의된 훅은 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출됨.
여기서 협력을 제어하는 것은 프레임워크라는 것에 주목해야함.

프레임워크가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐임.
과거에는 우리가 직접 라이브러리의 코드를 호출했지만, 객체지향의 시대에는 그저 프레임워크가 호출하는 코드를 작성해야함.

제어가 우리에게서 프레임워크로 넘어가 버린것임, 제어가 역전된 것임.

### 나아가기

이 책에서 설명하는 원칙과 기법들을 실무에 적용하기 위해서는 다양한 상황을 트레이드오프할 수 있는 능력을 길러야함.

실제로 완성된 설계는 절차에 따라 매끄럽게 진행된 것이 아니라 다양한 시행착오와 실패가 누적된 결과물임.

다음과 같은 방법을 통해 설계 기법을 익히고 통찰력을 길렀으면함.

- 디자인 패턴 : 디자인 패턴을 익히고 적용해보는 것은 설계를 트레이드오프 할 수 있는 능력을 기를 수 있는 가장 좋은 방법인 동시에 훌륭한 객체지향 설계의 특징을 배울 수 있는 참고자료임
- 리펙터링 : 코드를 개선해가며 원하는 설계에 이를 수 있는 융통성을 얻게 됨
- 테스트-주도 개발 : 테스트-주도 개발은 메시지를 먼저 선택하고 메시지가 객체를 선택하게 한다는 점이 책임-주도 설계 방법과 잘 어울림

가장 중요한 것은 코드를 작성하는 매순간마다 끊임없이 고민하고 트레이드오프하는 것임.

캡슐화, 응집도, 결합도의 정의와 원칙은 늘 유효함.
객체지향 패러다임의 중심에는 역할, 책임, 협력이 위치함.

우리가 할 일은 원칙이 적합하지 않은 지점을 만났을때, 이상이 현실 안에 안전하게 정착하도록 설계를 약간 비트는일임
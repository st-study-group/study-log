# 11장 클라이언트 식별과 쿠키

### 11.1 개별 접촉

HTTP 는 익명으로 사용하며 상태가 없고, 요청과 응답으로 통신하는 프로토콜임

현재의 웹 사이트들은 개인화된 서비스를 제공하고 싶어함.

아마존은 여러가지 방식으로 사이트를 개인화시켜 사용자에게 제공함

- 개별인사
    - 사용자에게 특화된 환영 메세지나 페이지 내용을 만듬
- 사용자 맞춤 추천
    - 고객의 흥미가 무엇인지 학습하여 고객이 좋아 할 것이라고 예상 되는 제품을 추천함.
    - 고객의 생일이나 다른 중요한 날이 다가오면 특별한 제품을 제시하기도 함
- 저장된 사용자 정보
    - 주소나 신용카드 정보를 저장하여 편하게 쇼핑할 수 있게 저장된 정보를 사용함
- 세션 추적
    - HTTP 트랜잭션은 상태가 없음
    - 웹사이트에서 사용자가 사이트와 상호작용할 수 있게 사용자의 상태를 남김(ex) 온라인 쇼핑 장바구니 기능) 이렇게 상태를 유지하려면, 웹 사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요함.

논의할 내용들

- 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
- 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL 에 식별자를 포함하는 기술인 뚱뚱한 URL
- 식별 정보를 지속해서 유지하는 강력하면서 효율적인 쿠키

### 11.2 HTTP 헤더

일곱가지 HTTP 요청 헤더가 있음.   (4개는 뒤에 장에서 다룸)

- From 헤더: 이메일 주소를 포함한다. 악의적 사용(스팸 메일 등) 문제가 있어 활용이 적다.
- User-Agent 헤더: 사용자의 브라우저 이름과 버전정보, 경우에 따라 운영체제에 대한 정보
- Referer 헤더: 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL
- Authorization
- Client-ip
- X-Forwarded-For
- Cookie

### 11.3 클라이언트 IP 주소

식별에 클라이언트 IP 를 사용하려 했으나, 
클라이언트 IP 주소로 사용자를 식별하는 경우 다음과 같은 약점이 있음

- IP 주소는 사용자가 아닌, 사용하는 컴퓨터를 가르킴
    - 만약 여러 사용자가 같은 컴퓨터를 사용한다면 그들을 식별할 수 없음
- 인터넷 서비스 제공자는 사용자가 로그인하면 동적 IP 주소를 할당함
    - 로그인한 시간에 따라, 사용자는 매번 다른 주소를 받음. 웹 서버는 사용자를 IP 주소로 식별할 수 없음
- 보안을 강화하고 부족한 주소를 관리하려고 많은 사용자가 NAT 방화벽을 통해 인터넷을 사용함
    - 실제 IP 주소를 숨기고, 하나의 방화벽 IP 주소로 변환함
- HTTP 프락시와 게이트 웨이는 원 서버에 새로운 TCP 연결을 함, 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 봄
    - Client-ip 나 X-Forwarded-For HTTP 같은 확장헤더를 통해 이 문제를 해결하려고 했으나, 모든 프락시가 이런 식으로 동작하지 않음.

### 11.4 사용자 로그인

IP 주소로 사용자를 식별하려는 수동적인 방식보다, 웹 서버는 사용자의 이름과 비밀번호로 인증(로그인) 할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있음

(HTTP 인증에 대한 자세한 내용은 12장에서 다룸)

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%A8%E1%84%87%E1%85%A7%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8F%E1%85%AE%E1%84%8F%E1%85%B5%207bda0152db644bff9e0cd457a3669d2d/Untitled.png)

- a) 브라우저는 [www.joes-hardware.com](http://www.joes-hardware.com) 사이트 요청
- b) 식별정보를 알지 못하므로 401 Login Required HTTP 응답 코드와 WWW-Authenticate 헤더를 반환하여 로그인 요청함
- c) 사용자가 이름과 비밀번호를 입력하고 브라우저는 기존 요청을 다시 보내 사용자 식별 시도함
    - 서버는 사용자 식별 정보름 알게됨
- d) 이 시점이후 요청에 대해서는, 브라우저는 서버로 부터 사용자 식별 정보 요청을 받으면 요청에 대해 자동으로 사용자의 이름과 비밀번호를 포함하여 요청함, 심지어 요청하지 않았을때도 전달함.
- 한 세션이 진행되는 내내 그 사용자에 대한 식별을 유지함

 

### 11.5 뚱뚱한 URL

사용자의 상태 정보를 포함하고 있는 URL 을 뚱뚱한 URL 이라고 함.

뚱뚱한 URL 은 사이트 브라우징하는 사용자를 식별하는데 사용할 수 있음. 하지만 여러 심각한 문제가 있음

- 못생긴 URL
    - 뚱뚱한 URL 은 새로운 사용자에게 혼란을 줌
- 공유하지 못하는 URL
    - 뚱뚱한 URL은 특정 사용자와 세션에 대한 상태 정보를 포함함.
    - 만약 그 주소를 누군가에게 메일로 보내면, 개인정보를 본의 아니게 공유하게 됨
- 캐시를 사용할 수 없음
    - URL 이 달라지기 때문에 기존 캐시에 접근할 수 없다는 것을 의미함.
- 서버 부하 가중
    - 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야함.
- 이탈
    - 링크를 타고 다른 사이트로 이동하거나, 특정 URL 을 요청해서 의도치 않게 뚱뚱한 URL 세션에서 이탈하기 쉬움
    - 사전에 세션 정보가 추가된 링크만 사용해야 뚱뚱한 URL 문제없이 동작하기 때문
- 세션 간 지속성의 부재
    - 사용자가 특정 뚱뚱한 URL 을 북마킹하지 않는 이상, 로그아웃하면 모든 정보를 잃게 됨

### 11.6 쿠키

쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식임

쿠키는 새로운 HTTP 헤더를 정의함, 쿠키는 캐시와 충돌 할 수 있어서, 대부분의 캐시나 브러우저는 쿠키에 있는 내용물을 캐싱 하지 않음(뒤에서 자세히 다룸)

### 11.6.1 쿠키의 타입

쿠키는 세션쿠키(session cookie) 와 지속쿠키(persistent cookie) 두가지 타입으로 나눌 수 있음

세션쿠키

- 사용자가 사이트를 탐색할때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키
- 사용자가 브라우저를 닫으면 삭제됨

지속 쿠키

- 삭제되지 않고 더 길게 유지 될 수 있음
- 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작 하더라도 남아있음.
- 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용함.

세션쿠키와 지속쿠키의 다른점은 파기되는 시점 뿐임.

 

쿠키는 Discard(삭제) 파라미터 가 설정되어 있거나, 파기되기꺼지 남은 시간을 가리키는 Expires 혹은 Max-Age 파라미터가 없으면 세션 쿠키가 됨

### 11.6.2 쿠키는 어떻게 동작하는가

쿠키는 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 혹은 ~~Set-Cookie2(확장헤더)~~ 같은 HTTP 응답 헤더에 기술되어 전달됨

브라우저는 서버로 온 Set-Cookie ~~혹은 Set-Cookie2(확장헤더)~~ 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터 베이스에 저장함.

브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청헤더에 기술해 전송함.ㅁ

### 11.6.3 쿠키 상자: 클라언트 측 상태

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%A8%E1%84%87%E1%85%A7%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8F%E1%85%AE%E1%84%8F%E1%85%B5%207bda0152db644bff9e0cd457a3669d2d/Untitled%201.png)

쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 서버에 접근할때마다 그 정보를 함께 전송하는 것임

- 구글 크롬 쿠키

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%A8%E1%84%87%E1%85%A7%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8F%E1%85%AE%E1%84%8F%E1%85%B5%207bda0152db644bff9e0cd457a3669d2d/Untitled%202.png)

SQLite 파일에 있는 각 행이 쿠키 한개에 해당함.

- 마이크로소프트 인터넷 익스프로러 쿠키
    
    **(2022년 6월 15일 마침내 마이크로소프트(MS)의 웹 브라우저 인터넷 익스플로러  공식 지원이 종료)**
    
    각각 개별 파일로 쿠키를 저장함
    
    각 쿠키는 개별 저장되며, 각 쿠키는 여러 행으로 기술되어 있음.
    

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 쿠키 전부를 모든 사이트에 보내지 않음.

보통 각 사이트에 두개, 혹은 세개의 쿠키만을 보냄, 이유는 다음과 같음

- 쿠키를 모두 전달하면 성능이 크게 저하됨
- 대부분 서버에 특화된 키/값 형태이기에, 다른사이트에서 인식하지 않는 무의미한 값임
- 모든 사이트에 쿠키 전체를 전달하는것은 잠재적인 개인정보 문제를 일으킬 것임

보통 브라우저는 쿠키를 생성한 서버에만 쿠키에 담긴 정보를 전달함

많은 웹사이트는 광고를 관리하는 협력업체와 계약을 함, 같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버로 전송함.

이는 지속쿠키의 도메인이 같기 때문임

광고사는 이 기술에 Referer 헤더를 접목하여 사용자의 프로필과 웹사이트를 사용하는 습관에 대한 방대한 데이터를 구축 할 수있음.

- 쿠키 Domain 속성
    
    Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있음.
    
    Set-Cookie: user=”mary17”; domian=”art.com”
    
    [www.art.com](http://www.art.com) 이나 [www.spetial.art.com](http://www.spetial.art.com)  같이 *.art.com 으로 끝나는 사이트에 방문하면 다음 Cookie 헤더가 항상 적용될것임
    
    Cookie: uer=”mary17”
    
- 쿠키 Path 속성
    
    URL 경로의 앞부분을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달함
    
    Set-Cookie: per=compact; domain=”art.com”; path=/autos/
    
    [art.com/specials.html](http://art.com/specials.html) 접근시
    
    Cookie: user=”mary17”
    
    [art.com/autos/cheapo/index.html](http://art.com/autos/cheapo/index.html) 로 접근시 두가지의 쿠키를 받게됨
    
    Cookie: user=”mary17”
    
    Cookie: pref=compact
    
    (사실은 **cookie:** user=”mary17”;  pref=compact)
    
    ### 11.6.5 쿠키 구성 요소
    
    쿠키 명세는 version 0 쿠키, version 1 쿠키 가 있음
    
    Version 1 쿠키는 Version 0 쿠키의 확장으로 널리 쓰이지 않음
    
    Version 1 (**RFC2965의 Set-cookie2 제시) ⇒ 폐기 되었음**
    
    ### 11.6.6 Version 0(넷스케이프 쿠키)
    
    Version 0 쿠키는 다음과 같은 형태임
    
    Set-Cookie : name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
    
    Cookie : name1=value1 [; name2=value2] ..
    
    | Set-Cookie 속성 | 예 |
    | --- | --- |
    | 이름=값 | (필수 속성)
    Set-Cookie: customer=Mary |
    | Expires | 날짜 형식은 다음과 같음
    요일, DD-MM-YY, HH:MM:SS GMT
    사용할수 있는 타임존은 GMT 뿐임, 쿠키에 Expires 를 명사하지 않으면, 그 쿠키는 사용자의 세션이 끝날때 파기 됨
    
    Set-Cookie: foo=bar; expires=Wendsday, 09-Nov-99 23:12:40 GMT |
    | Domain | 두개에서 세개 영역을 가지는 도메인을 기술 해야함.
    (.com, .edu 는 안됨)
    Set-Cookie: SHIPPING=REDEX; domain="joes-hardware.com" |
    | Path | /foo 경로는 /foobar 와 /foo/bar.html 에 들어 맞음
    ”/” 경로는 도메인에 있는 모든것에 들어 맞음
    만약 경로를 명시하지 않으면, Set-Cookie 응답을 전달하는 URL 의 경로가 사용됨
    Set-Cookie: lastorder=00183; path:/orders |
    | Secure | HTTP 가 SSL 보안 연결을 사용할때만 쿠키를 전송함
    Set-Cookie: private_id=519; secure |
    
    ### 11.6.7 Version1 (RFC 2965) ⇒ 폐기
    
     넘어가도록하겠음..
    
    ---
    
    (그런의미로 다른 블로그에 정리 된 내용 가져옴.)
    
    ([https://feel5ny.github.io/2019/11/16/HTTP_011_02/](https://feel5ny.github.io/2019/11/16/HTTP_011_02/))
    
    # **🧩 쿠키 구성요소**
    
    - 현재 사용되는 쿠키 명세에는**Version0** 쿠키 (= 넷스케이프 쿠키)**Version1** 쿠키 (RFC 2965 => RFC 2965 => RFC 6265)
    - Version1 쿠키는 Version0 쿠키의 확장으로널리 쓰이지는 않는다.
    - Version0과 Version1 쿠키 명세 모두 HTTP/1.1 명세 일부로 기술되어 있지는 않는다.
    
    ## **Version 0**
    
    ### **1. Set-Cookie 헤더**
    
    - Set-Cookie 헤더는 쿠키의 이름과 값을 가져야 한다.
    - 이는 쿠키 옵션 속성들에 `;`으로 이어 기술한다.
    1. `이름=값`: 필수 값
    2. `Expires`: 선택적인 속성. 쿠키의 생명주기를 가리키는 날짜 문자열
        - **요일, DD-MM-YY HH:MM:SS GMT**
        - 사용할 수 있는 타임존은 GMT
        - 쿠키에 Expires를 명시하지 않으면 그 쿠키는 사용자의 세션이 끝날 때 파기될 것이다.
    3. `Domain`: 선택적인 속성. 브라우저는 이 속성에 기술된 도메인을 사용하는 서버 호스트명으로만 쿠키를 전송한다.
        - 이는 서버가 해당 도메인에만 쿠키를 제한적으로 전달하게 한다.
        - 도메인이 명시되어 있지 않으면, Set-Cookie 응답을 생성한 서버의 호스트 명을 기본값으로 사용한다.
    4. `Path`: 선택적인 속성. 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다.
        - `/foo`경로는 `/foobar`와 `/foo/bar.html`에 들어맞는다.
        - `/`는 모든 것에 들어맞는다.
        - 경로를 명시하지 않으면, Set-Cookie 응답을 전달하는 URL의 경로가 사용된다.
    5. `Secure`: 선택적인 속성. 쿠키는 HTTP가 SSL 보안 연결을 사용할 때만 쿠키를 전송한다.
    6. `HttpOnly`: HttpOnly는 쿠키의 범위를 HTTP 요청으로 제한한다.HttpOnly가 설정된 경우 클라이언트 사이드 API로는 쿠키에 접근하지 못한다.
    
    ### **RFC 6265와 RFC 2109 쿠키의 차이**
    
    - **RFC 6265**가 나오면서 RFC 2109, RFC 2965는 폐기
    - 둘디 Set-Cookie 헤더를 사용합니다.
    - RFC 2109는 Name, Value, Comment, Domain, Max-Age, Path, Secure, Version
    - **RFC 6265는 Name, Value, Expires, Domain, Max-Age, Path, Secure, HttpOnly**
        - **Max-Age를 설정하면 자동으로 Expires가 정해진다.**
        - **HttpOnly: 비 HTTP 요청을 막는다.**
    - 구현 고려 사항
        - RFC 2109는 유저 에이전트가 최소 300개의 쿠키,쿠키마다 적어도 4096바이트,한 호스트나 도메인마다 최소 20개를 지원해야 한다.
        - **RFC 6265는 유저 에이전트가 최소 3000개의 쿠키쿠키마다 적어도 4096바이트,도메인 당 최소 50개의 쿠키를 저장 가능해야 한다고 명시.**
    
    ---
    
    ### 11.6.8 쿠키의 세션과 추적
    
    아마존 사이트에 접속하면, 일련의 리다이렉트, URL 리라이트, 쿠키설정을 통해 서버가 식별정보를 첨부하기위한 연속적인 트랜잭션을 시작함.
    
    ![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%A8%E1%84%87%E1%85%A7%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8F%E1%85%AE%E1%84%8F%E1%85%B5%207bda0152db644bff9e0cd457a3669d2d/Untitled%203.png)
    
    ### 11.6.9 쿠키와 캐싱
    
    쿠키 트랜잭션과 관련된 문서를 캐싱하는것은 주의해야함
    
    이전 사용자의 쿠키가 다른 사용자에게 할당되거나, 누군가의 개인정보가 다른이에게 노출되는 상황이 일어 날 수 있음.
    
    쿠키와 캐싱에 관련된 규칙은 정리가 잘 되어 있지 않음.
    
    다음은 캐시를 다루는 기본 원칙에 대한 안내임.
    
- **캐시되지 말아야할 문서가 있다면 표시하라**
    - 문서를 캐시하면 될지 안될지는 문서의 소유자가 잘 암
    - 만약 문서가 Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면
        - Cache-Control: no-cache=”Set-Cookie” 를 기술하여 명확히 표시함.
    - 캐시를 해도 되는 문서에
        - Cache-Control: public 을 사용하면 웹 대역폭을 절약 시켜줌
    
- **Set-Cookie 헤더를 캐시 하는 것에 유의하라**
    - 응답이 Set-Cookie 헤더를 가지고 있으면, 본문은 캐시할 수 있지만, Set-Cookie 헤더를 캐시하는 것은 주의를 기울여야만 함.
    - 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패함
    - 캐시가 모든 요청마다 원서버와 재검사를 시켜 클라이언트로 가는 응답에 Set-Cookie 헤더값을 기술해서 이 문제를 개선할 수 있음
        - Cache-Control: must-revalidate, max-age=0
    
- **Cookie 헤더를 가지고 있는 요청을 주의하라**
    - 요청이 Cookie 헤더와 함께 오면, 결과 콘텐츠가 개인정보를 담고 있을 수 있다는 힌트임
        - 개인정보는 캐시되지 않도록 표시되어 있어야 하지만, 그 표시를 하지 않는 서버도 있음.
    - 보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것임
    

### 11.6.10 쿠키, 보안 그리고 개인정보

개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용 될 수 있기 때문에 항상 조심하는 것이 좋음. 

```json
(미 재무성 컴퓨터 사고 자문단이 1998 년 쿠키의 위험성이 과대평가됐다는 평가서를 작성함.)

미국 재무성 컴퓨터 사고 자문단 : 인터넷 쿠키

문제 : 쿠키는 웹 서버가 웹 사용자를 식별하는 작은 데이터 조각이다. 
 쿠키의 개념과 기능에 대해 이해할 수 없는 수준까지 올라온 수많은 
뜬소문들은 사용자를 놀라게 하고 그들의 관리자까지 걱정 끼칠 수준이다.

취약성 평가 : 쿠키를 사용하면 시스템의 취약한 부분이 손상되거나 스누핑 하는 것은 
근복적으로 있을 수 없다.

쿠키는 당신의 방문 흔적과 약간의 정보(사용자 번호와 같은)를 다시 접속 하였을 때 서버에게
 다시 보내는 용도일 뿐이다.

쿠키는 대부분 세션 쿠키이며 지속 쿠키 또한 파기 시간을 가지고 있고 시간이 지나면
 디스크에서 삭제된다.

지속 쿠키는 사용자가 언제 사이트로 돌아오는지 식별해서 사용자의 탐색 습관을 
추적하는데 사용될 수 있다.

당신이 어디서 왔는지, 당신이 어떤 페이지에 접근했는지 로그파일도 존재하며, 
그것을 통해서 사용자의 브라우징 습관을 추적할 수도 있다. 쿠키는 그것을 좀 더 편리하게 해줄 뿐이다.
```
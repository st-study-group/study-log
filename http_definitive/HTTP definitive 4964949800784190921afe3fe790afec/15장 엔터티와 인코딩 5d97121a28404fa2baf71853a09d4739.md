# 15장 엔터티와 인코딩

### 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지는 컨테이너고 엔터티는 컨테이너안의 화물이다.
- 아래는 HTTP/1.1 의 10가지 주요 엔터티 헤더 필드이다.
    - Content-Type : 엔터티에 의해 전달된 객체의 종류
    - Content-Length : 전달되는 메시지의 길이나 크기
    - Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어
    - Content-Encoding : 객체 데이터에 대해 행해진 변형
    - Content-Location : 오청 시점을 기준으로, 객체의 또 다른 위치
    - Content-Range : 만약 이 엔터티가 부분 엔터티라면,
    이 엔터티가 전체에서 어느 부분에 해당하는지 정의
    - Content-MD5 : 엔터티 본문의 콘텐츠에 대한 체크섬
    - Last-Modified : 서버에서 이 콘텐츠가 생성되거나 수정된 날
    - Expires : 엔터티 데이터의 만료 일자
    - Allow : 리소스에 대해 허용되는 요청 메서드
    - ETag : 인스턴스(15.7)에 대한 고유한 검사기
    엔터티 헤더로 정의되진 않았지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더
    - Cache-Control : 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자
    이 또한 ETag 헤더와 마찬가지로 엔터티로 정의되진 않았다.
- 엔터티 본문
    - 엔터티 본문은 가공되지 않은 생 데이터만을 담고있는다.
    그렇기에 엔터티 헤더는 이 데이터의 의미에 대해 설명해야한다.
    - 엔터티 본문은 어떠한 형태던간에 무조건 헤더 필드의 끝을 의미하는
    빈 CRLF 줄 다음부터 시작된다.

### Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 Byte 단위로 나타내고,
메시지를 청크 인코딩으로 전송하지 않는 이상
엔터티 본문을 포함한 메시지에서는 필수적으로 존재해야 한다.
    - 청크 인코딩은 메시지를 일정 크기로 잘라 여럿의 청크로 쪼개
    서버에서 쪼갠 청크를 순차적으로 보내서 전체 크기를 알 필요가 없기에
    Content-Length 헤더가 필요하지 않다.
- Content-Length 헤더는 서버 충돌로 인해서 메시지가 누락되었는지 감지하고자,
또는 지속 커넥션을 공유하는 메시지를 올바르게 분할할 때 필요하다.
- 잘림 검출
    - 옛날의 HTTP 는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했으나,
    Content-Length가 없다면 클라이언트는 커넥션이 제대로 닫힌 것인지
    메시지 전송 중에 서버에 충돌이 발생한 것인지 구분하지 못하기 때문에
    클라이언트가 메시지 잘림을 검출하기 위해서 Content-Length 를 필요로 한다.
- 잘못된 Content-Length
    - Content-Length가 잘못된 값을 담고 있을 경우 존재하지 않는 경우보다
    큰 피해를 유발할 수 있다.
    초창기의 클라이언트/서버 중 일부는 Content-Length 의 계산과 관련한 버그들을
    가지고 있기 때문에 이러한 오작동을 했는지 탐지하고 교정을 시도한다.
    
    공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 Content-Length 를 받고
    그 사실을 인지했을 때 사용자에게 알려주게 되어있다.
- Content-Length와 지속 커넥션
    - Content-Length는 지속 커넥션을 위해서 필수다.
    - 만약 응답이 지속 커넥션을 통해 온 것이라면
    또 다른 응답이 즉시 그 뒤를 이을 것이다.
    - Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고
    다음 시작이 어디인지를 알려준다.
    - 커넥션은 지속적이기 때문에 클라이언트가 커넥션이 닫힌 위치를 근거로
    메시지의 끝을 인식하는 것은 불가능하다.
- 콘텐츠 인코딩
    - HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록
    엔터티 본문을 인코딩할 수 있게 해준다.
    만약 본문의 콘텐츠가 인코딩되어 있다면 Content-Length 헤더는
    인코딩되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.
- 엔터티 본문 길이 판별을 위한 규칙
    1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다. 이 경우 Content-Length 헤더는 부가정보에 불가하며, 실제 본문 길이를 서술하지 않는다.
    2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서
    먼저 끝나지 않는 이상 엔터티는 0 바이트 청크라 불리는 특별한 패턴으로 끝나야 한다.
    3. 메시지가 Content-Length 헤더를 갖고 메시지 유형이 엔터티 본문을 허용한다면,
    Transfer-Encoding 헤더가 존재하지 않는 이상
    Content-Length 값은 본문의 길이를 담게된다.
    4. 메시지가 multipart/byteranges 미디어 타입을 사용하고
    엔터티 길이가 별도로 정의되지 않았다면,
    멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다.
    5. 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.
    6. HTTP/1.1 애플리케이션과의 호환을 위해, 엔터티 본문을 갖고 있는
    HTTP/1.1 요청은 반드시 유효한 Content-Length헤더도 갖고 있어야 한다.

### 엔터티 요약

- 엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해,
최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며,
수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해
체크섬으로 기본적인 검사를 할 수 있다.

### 미디어 타입과 차셋(Charset)

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.
    - MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름이다.
    클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해
    MIME 타입을 이용한다.
- Content-Type의 값은 IANA(인터넷 할당 번호 관리기관)에 등록된 표준화된 MIME 타입으로,
주 미디어 타입인 텍스트, 이미지, 오디오 등으로 시작해 빗금,
미디어 타입을 구체적으로 서술하는 subtype으로 구성된다.
(MIME 타입은 부록 D)
- 텍스트 매체를 위한 문자 인코딩
    - Content-Type 헤더는 내용 유형을 자세히 지정하기 위한
    선택적 매개변수(charset 등)도 지원한다.
- 멀티파트 미디어 타입
    - MIME 멀티파트 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하고,
    하나의 복합 메시지로 보내진다.
    - 각 구성요소는 자신에 대해 서술하는 헤더를 포함하고 여러 구성요소들이 이어지며,
    문자열 하나로 서로의 경계가 식별된다.
    - HTTP는 멀티파트 본문도 지원하지만 일반적으론 폼을 채워 제출할 때와
    문서의 일부분을 실어 나르는 범위 응답을 할 때의 두 가지 경우에만 사용된다.
- 멀티파트 폼 제출
    - HTTP 폼을 채워 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는
    각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.
    - 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.
- 멀티파트 범위 응답
    - 범위 요청에 대한 HTTP응답 또한 멀티파트가 될 수 있다.
    그러한 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를
    담고 있는 멀티파트 본문이 함께 온다.

### 콘텐츠 인코딩

- HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 한다.
(큰 HTML 문서의 전송 시간을 줄이기 위해 압축하거나 콘텐츠를 암호화 하는 등..)
- 콘텐츠 인코딩 과정
    1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한
    원본 응답 메시지를 생성한다.
    2. 콘텐츠 인코딩 서버(원 서버 or 다운스트림 프락시)가 인코딩된 메시지를 생성한다.
    콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가해 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다.
    3. 수신 측 프로그램은 인코딩된 메시지를 받아 디코딩하고 원본을 얻는다.
- 콘텐츠 인코딩 유형
    
    ![Untitled](15%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%A5%E1%84%90%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%205d97121a28404fa2baf71853a09d4739/Untitled.png)
    
- Accept-Encoding 헤더
    - 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해,
    클라이언트는 자신이 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해
    전달한다. 만약 HTTP 요청에 Accept-Encoding 헤더를 포함하지 않거나
    Accept-Encoding: * 을 전달하면 서버는 클라이언트가 어떤 인코딩이든
    받아들일 수 있는 것으로 간주한다.
    - 클라이언트는 각 인코딩에 Q(quality) 값을 매개변수로 더해 선호도를 나타낼 수 있다. (min: 0.0 ~ max:1.0)

### 전송 인코딩과 청크 인코딩

- 전송 인코딩은 콘텐츠 인코딩과 같이 엔터티 본문에 적용되는 가역적 변환이지만
이는 구조적 이유 때문에 적용되는 것이며,
콘텐츠 포맷과 긴밀하게 연관되있는 콘텐츠 인코딩과 다르게 전송 인코딩은 독립적이다.
- 안전한 전송
    - 역사적으로 전송 인코딩은 타 프로토콜에서도 네트워크를 통한
    안전한 전송을 위해 존재했다.
    하지만 HTTP 는 안전한 전송의 초점을 다른 데에 맞추고 있다.
    - 아래는 HTTP에서 전송된 메시지 본문이 문제를 일으킬 수 있는 이유 중 두가지다.
        - 알 수 없는 크기
            - 몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다.
            - 흔히 이 서버들은 그 사이즈를 알기 전에 데이터를 전송하려고 한다.
            HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에
            몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 달아
            전송 인코딩으로 데이터를 보내려 시도한다.
        - 보안
            - 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해
            알아보기 어렵게 뒤섞어버리는 방법도 있다.
            그러나 이미 SSL과 같은 유명한 전송 계층 보안 방식이 존재하기에 전송 인코딩 보안은 흔하지 않다.
- Transfer-Encoding 헤더
    - 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두 개뿐이다.
        - Transfer-Encoding
            - 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지
            수신자에게 알려준다.
        - TE
            - 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해
            요청 헤더에 사용한다.
- 청크 인코딩
    - 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼개
    서버가 청크를 순차적으로 보낸다.
    이렇게 청크로 쪼개 보내면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.
    - 청크 인코딩이 전송 인코딩의 한 형태이며 본문이 아닌
    메시지의 속성임에 주목해야 한다.
    - 청크와 지속 커넥션
        - 클라이언트와 서버 사이의 커넥션이 지속적이지 않다면,
        클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다.
        서버가 커넥션을 닫을 때까지를 본문으로 간주하고 읽을 것이기 때문이다.
        - 지속 커넥션에선 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를
        담아 보내야 한다.
        - 하지만 콘텐츠가 서버에서 동적으로 생성될 때 본문의 길이를 알 수 없는데
        이 때 청크 인코딩을 이용할 수 있다.
        - 서버는 동적으로 생성된 본문을 일정 크기로 쪼개 보내고 크기가 0인 청크를 보내
        본문이 끝났음을 알린 후 다음 응답을 위해서 커넥션을 유지할 수 있다.
    - 청크 인코딩된 메시지의 트레일러
        - 다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.
            - 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
            - 트레일러가 응답을 만든 서버에 의해 추가되었고, 그 트레일러의 콘텐츠는
            클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로
            클라이언트가 무시하고 버려도 되는 경우
        - 트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.
- 콘텐츠와 전송 인코딩의 조합
    - 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.
    - 콘텐츠 인코딩을 사용해서 HTML 파일을 압축하고
    그 청크 데이터를 전송 인코딩을 사용해서 전송한다.
- 전송 인코딩 규칙
    - 전송 인코딩이 메시지 본문에 적용될 때 아래 규칙이 반드시 적용되어야 한다.
        - 전송 인코딩의 집합은 반드시 chunked 를 포함해야 하고,
        예외적으로 메시지가 커넥션의 종료로 끝나는 경우에만 포함하지 않아도 된다.
        - 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된
        마지막 전송 인코딩이 존재해야 한다.
        - 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.

### 시간에 따라 바뀌는 인스턴스

- 웹 객체는 정적이지 않아서 같은 URL의 리소스에 대해 시간에 따라
다른 인스턴스(객체)를 응답 받을 수 있다.
    
    ![Untitled](15%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%A5%E1%84%90%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%205d97121a28404fa2baf71853a09d4739/Untitled%201.png)
    

### 검사기와 신선도

- 신선도
    - 서버는 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고
    그것이 신선하다고 가정할 수 있는지에 대한 정보를 줄 것이다.
    - 이를 Expires 또는 Cache-Control 헤더를 통해 이러한 정보를 제공할 수 있다.
    - 하지만 서로의 시간을 동기화 시켜야하는 Expires는 매번 동기화 시키기 어려워
    Cache-Control 헤더로 문서의 최대 수명을 초 단위로 정해 정확한 결과를 말해준다.
- 조건부 요청과 검사기
    - 캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면
    캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요가 있다.
    하지만 캐시가 가져오는 대부분의 원 서버의 문서는 여전히 신선하지 않은
    캐시와 같을 것이다.
    - 이를 고치기 위해 HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는
    조건부 요청이라 불리는 특별한 요청을 할 수 있는 방법을 제공한다.
    - 조건부 요청은 If-로 시작하는 조건부 헤더에 의해 구현된다.

### 범위 요청

- HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.
예를 들어 웹에서 다운로드를 받다가 어떤 이유 때문에 잠시 중단을 했을 때
범위 요청을 이용해 중단된 시점부터 재개할 수 있다.

### 델타 인코딩

- 델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는
HTTP 프로토콜의 확장이다.
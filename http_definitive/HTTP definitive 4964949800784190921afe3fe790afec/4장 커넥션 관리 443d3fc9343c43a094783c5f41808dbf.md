# 4장 커넥션 관리

## TCP 커넥션

- 대부분의 HTTP 통신은 TCP/IP 를 통해 이루어진다.
- 세계 어디에서든 클라이언트와 서버는 TCP/IP 커넥션을 맺을 수 있다.
- 커넥션이 맺어지면 클라이언트와 서버간에 주고받는 메시지는 안전하고 정확하게 전달된다.
- URL 을 입력받은 브라우저의 수행 단계
    1. 브라우저가 URL 에서 호스트 명을 추출한다.
    2. 브라우저가 호스트 명에 대한 IP 주소를 찾는다.
    3. 브라우저가 포트 번호를 얻는다.
    4. 브라우저가 찾은 IP 주소와 얻은 포트로 TCP 커넥션을 생성한다.
    5. 브라우저가 서버로 요청 메시지를 보낸다.
    6. 브라우저가 서버에서 온 응답 메시지를 읽는다.
    7. 브라우저가 커넥션을 끊는다.
- TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다
    - HTTP 가 메시지를 전송 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해
    메시지 데이터의 내용을 순서대로 보낸다.
    - TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고,
    세그먼트를 IP 패킷이라고 불리는 봉투에 담아 인터넷을 통해 데이터를 전달한다.
    - IP 패킷 구조
        - IP 패킷 헤더
            - 발신지, 목적지 IP 주소, 크기, 기타 플래그를 가지고있다.
        - TCP 세그먼트 헤더
            - TCP 포트 번호, TCP 제어 플래그,
            데이터의 순서 및 무결성을 검사하는 용도의 숫자 값을 가지고있다.
        - TCP 데이터 조각
- TCP 커넥션 유지하기
    - TCP 커넥션은 발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트 로 식별하며,
    이 네 가지 값으로 유일한 커넥션을 생성한다.
- TCP 소켓 프로그래밍
    - 소켓 API를 사용하면, TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
    - TCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로 숨긴다.

## TCP 성능에 대한 고려

- HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은
그 아래 계층인 TCP 성능에 영향을 받는다.
- HTTP 트랜잭션 지연
    
    ![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%84%82%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20443d3fc9343c43a094783c5f41808dbf/Untitled.png)
    
    - 트랜잭션을 처리하는 시간은 TCP 커넥션을 설정하고,
    요청을 전송하고, 응답 메시지를 보내는 것에 비하면 상당히 짧다는 것을 알 수 있다.
    - 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
    (클라나 서버가 많은 데이터를 내려받거나 복잡하고 동적인 자원들을 실행하지 않는 한)
    - HTTP 트랜잭션을 지연시키는 원인
        1. 클라이언트는 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야 한다.
            - 만약 호스트에 방문한 적이 없으면 DNS 인프라를 사용하여 IP 주소로 변환하는데 수십 초의 시간이 걸릴 것이다.
            - 물론 지금은 인프라의 발전으로 대부분 밀리초 단위로 DNS 이름 분석이 끝난다.
        2. 클라이언트는 TCP 커넥션 요청을 서버에게 보내고, 서버가 커넥션 허가 응답을 회신하기를 기다린다.
            - 커넥션 설정 시간은 새로운 TCP 커넥션에서 항상 발생한다.
        3. 커넥션이 맺어지면 클라는 HTTP 요청을 새로 생성한 TCP 파이프를 통해 전송한다.
            - 웹 서버는 데이터가 도착하는 대로 TCP 커넥션에서 요청 메세지를 읽고 처리한다.
        4. 웹 서버가 HTTP 응답을 보내는 것 역시 시간이 소요된다.
- 성능 관련 중요 요소
    - 고성능의 HTTP 소프트웨어를 개발하고 있다면 아래 항목을 전부 이해해야하지만,
    그 정도의 성능 최적화를 할 게 아니라면 이 부분은 건너뛰어도 된다.
    1. TCP 커넥션 핸드셰이크 지연
    2. 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작
    3. 데이터를 한데 모아 한 번에 전송하기 위한 네이글 알고리즘
    4. TCP 편승 확인 응답을 위한 확인 응답 지연 알고리즘
    5. TIME_WAIT의 누적과 포트 고갈

## HTTP 커넥션 관리

- 흔히 잘못 이해하는 Connection 헤더
    - HTTP 메시지는 클라이언트에서 서버까지 중개 서버들을 하나하나 거치면서 전달된다.
    - 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있다.
    - HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않는다.
    - Connection 헤더에 있는 모든 헤더 필드는 메시지를 다른곳으로 전달하는 시점에 삭제되어야 한다.
- 순차적인 트랜잭션 처리에 의한 지연
    - 웹 페이지에 세 개의 이미지 파일이 있다고 가정할 때, 브라우저가 이 페이지를 보여주려면 네 개의 HTTP 트랜잭션을 만들어야 한다.
    - 각 트랜잭션이 새로운 커넥션을 필요로 한다면, 커넥션을 맺는데 발생하는 지연과 함께 느린 시작 지연이 발생할 것이다.
    - 순차적인 처리는 물리적 지연뿐 아니라, 하나의 이미지를 내려받는 동안 웹 페이지의 나머지 공간에 아무런 변화가 없어서 생기는 심리적 지연도 있다.

## 병렬 커넥션

- 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.
- 병렬 커넥션은 페이지를 더 빠르게 내려받는다
    - 단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면
    여러 개의 객체가 있는 웹 페이지를 더 빠르게 내려받을 수 있다.
    - 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 내려받는 데에 남은 대역폭을 사용할 수 있다.
- 병렬 커넥션이 항상 더 빠르지는 않다
    - 일반적으로 병렬 커넥션이 일반 커넥션보다 빠르긴 하지만,
    클라이언트의 네트워크 대역폭이 좁을 때 대부분의 시간을 데이터 전송에만
    사용하기 때문에 여러 개의 객체를 병렬로 내려받는 경우
    성능상의 장점은 거의 없어진다.
    
    오히려 여러 개의 커넥션을 생성하면서 생기는 부하로 인해 일반 커넥션보다
    더 오래 걸릴 수 있다.

## 지속 커넥션

- 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간 커넥션을 유지해
커넥션을 재사용함으로 커넥션을 맺기 위한 준비작업에 따른 시간을 절약할 수 있고,
TCP 의 느린 시작으로 인한 지연을 피함으로써 더 빠르게 데이터를 전송할 수 있다.
- 지속 커넥션 VS 병렬 커넥션
    - 병렬 커넥션은 각 트랜잭션 마다 새로운 커넥션을 맺고 끊어 시간과 대역폭이 소요되고,
    각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
    - 지속 커넥션은 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고,
    튜닝된 커넥션을 유지해 커넥션의 수를 줄여준다. 하지만 지속 커넥션을
    잘못 관리할 경우 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 된다.
        - 튜닝된 커넥션 : TCP 느린 시작에서 패킷을 여러번 성공적으로 전송한 결과로
        한 번에 다수의 패킷을 전송할 수 있는 권한을 얻는 커넥션을 의미한다.
    - 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적이다.
    애플리케이션은 적은 수의 병렬 커넥션만을 맺고 그것을 유지한다.
    
    두 가지의 지속 커넥션 타입이 있는데 HTTP/1.0+ 에선 keep-alive,
    HTTP/1.1 에는 지속 커넥션이 있다.
- Keep-Alive 커넥션
    - keep-alive 커넥션은 지속 커넥션을 지원하기 위해 확장되었다.
    - 같은 HTTP 트랜잭션에 대해 연속적으로 커넥션을 생성해 처리하는 방식에 비해
    하나의 지속 커넥션으로만 처리하기 때문에 커넥션을 맺고 끊는 데 필요한 작업과
    TCP 느린 시작이 일어나지 않기 때문에 시간이 단축된다.
- Keep-Alive 동작
    - keep-alive는 사용하지 않기로 결정되어 HTTP/1.1 명세에는 빠졌지만, 아직 브라우저와 서버간 keep-alive 핸드셰이크가 널리 사용되고 있기 때문에, HTTP 애플리케이션은 그것을 처리할 수 있게 개발해야 한다.
    - keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해
    Connection: Keep-Alive 헤더를 포함시켜 요청하고 이 요청을 받은 서버는 그 다음
    요청도 이 커넥션을 통해 받고자 할 때 응답 메세지에 같은 헤더를 포함해 응답한다.
    
    만약 응답에 해당 헤더가 존재하지 않으면 클라이언트는 keep-alive 를 지원하지 않고,
    응답 메시지가 전송되고 나면 서버 커넥션을 끊을 것이라고 추정한다.
- Keep-Alive 옵션
    - Keep-Alive 헤더는 커넥션을 유지하길 바라는 요청일 뿐이지
    무조건 그것을 따를 필요는 없다.
    
    언제든 현재의 keep-alive 커넥션을 끊을 수 있고, keep-alive 커넥션에서 처리되는
    트랜잭션의 수를 제한할 수도 있다.
    - Keep-Alive 헤더 사용은 선택 사항이지만, Connection: Keep-Alive 헤더가 있을 때만 사용할 수 있다.
- HTTP/1.1의 지속 커넥션
    - HTTP/1.1 에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된
    지속 커넥션을 지원한다.
    - keep-alive와 달리 지속 커넥션은 기본적으로 활성화되어 있으며,
    지속 커넥션을 끊으려면 Conneciton: close 헤더를 명시해야 한다.
    - Connection: close 헤더가 없으면 응답 후에도 커넥션은 유지하자는 것으로 추정하지만 클라이언트와 서버는 언제든 커넥션을 끊을 수 있다.

## 파이프라인 커넥션

- HTTP/1.1 은 지속 커넥션을 통해 요청을 파이프라이닝할 수 있다.
이를 통해 keep-alive 커넥션의 성능을 더 높여준다.
- 여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓이고,
첫 번째 요청이 네트워크를 통해 서버로 전달되면 거기에 이어
두 번째 세 번째 요청이 전달될 수 있다.
(대기 시간이 긴 네트워크 상황에서 왕복으로 인한 시간을 줄여 성능을 높여준다)
- 파이프라인 커넥션의 제약사항
    - HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안된다.
    - HTTP 응답은 요청의 순서와 같게 들어와야 한다. HTTP 메시지는 순번이 없기 때문에 제 각각 오면 정렬시킬 방법이 없다.
    - 클라이언트가 지속 커넥션을 맺고 10개의 요청을 보냈을 때 서버는 5개만 처리하고 커넥션을 끊을 수 있는데, 클라이언트는 이 커넥션은 다시 맺고 요청을 보낼 수 있어야 한다.
    - HTTP는 POST와 같은 비멱등 메서드는 반복 요청시 문제가 생길 수 있기 때문에 파이프라인을 통해 보내면 안된다.

## 커넥션 끊기에 대한 미스터리

- 커넥션 관리에는 명확한 기준이 없다.
- 마음대로 커넥션 끊기
    - HTTP 클라이언트, 서버, 혹은 프락시는 언제든지 TCP 전송 커넥션을 끊을 수 있다.
    - 보통 커넥션은 메시지를 다 보낸 다음 끊지만, 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있다.
    - 지속 커넥션이 일정 시간 동안 요청을 전송하지 않고 유휴 상태에 있으면 서버는 그 커넥션을 끊을 수 있다.
    - 서버가 유휴 상태에 있는 커넥션을 끊는 시점에, 서버는 클라이언트가 다시 요청하지 않을 것이라고 확신하지 못한다. 클라이언트가 다음 요청을 보낸다면 문제가 생긴다.
- Content-Length와 Truncation
    - 각 HTTP 응답은 본문의 정확한 크기 값을 가지는
    Content-Length 헤더를 가지고 있어야 한다.
    - 클라이언트나 프락시가 커넥션이 끊어졌다는 HTTP 응답을 받은 후,
    실제 전달 된 엔터티 본문의 길이와 Content-Length가 일치하지 않거나
    Content-Length 헤더가 존재하지 않는다면 수신자는
    데이터의 정확한 길이를 서버에게 물어봐야 한다.
    - 만약 수신자가 캐시 프락시일 경우 응답을 캐시하면 안되며, Content-Length를 정정하려 하지 말고 메시지를 받은 그대로 전달해야 한다.
- 커넥션 끊기의 허용, 재시도, 멱등성
    - 커넥션은 에러가 없더라도 언제든 끊을 수 있다.
    HTTP 애플리케이션은 이 때문에 예상치 못하게 커넥션이 끊어졌을 경우
    적절히 대응할 수 있는 준비가 되어 있어야 한다.
    - 클라이언트는 트랜잭션 수행 중 커넥션이 끊어졌을 때 다시 트랜잭션을 전송해도 문제가 없다면 커넥션은 다시 맺고 한번 더 전송해야 한다.
    
    예시로 POST 하는 부류의 요청들은 반복될 경우 데이터가 중복으로 생길 수 있어
    이전 요청에 대한 응답을 받을 때까지 기다려야 한다.
- 우아한 커넥션 끊기
    - TCP 커넥션은 양방향이며 양쪽에는 데이터를 읽거나 쓰기 위한 입력 큐와 출력 큐가 있다. 한쪽 출력 큐에 있는 데이터는 다른 쪽의 입력 큐에 보내질 것이다.
    - 전체 끊기와 절반 끊기
        - 애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있다.
        - close()를 호출하면 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는다. (전체 끊기)
        - shutdown()을 호출하면 입력 채널이나 출력 채널 중 하나를 개별적으로 끊을 수 있다. (절반 끊기)
    - TCP 끊기와 리셋 에러
        - 단순한 HTTP 애플리케이션은 전체 끊기만을 사용할 수 있다.
        - 애플리케이션은 다른 애플리케이션들과 통신할 때, 그리고 그들과 파이프라인 지속 커넥션을 사용할 때, 기기들에 예상치 못한 쓰기 에러를 발생하는 것을 예방하기 위해 절반 끊기를 사용해야 한다.
        - 보통은 커넥션의 출력 채널을 끊는 것이 안전하고,
        클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면, 서버의 운영체제는 TCP connection reset by peer 메시지를 클라이언트에게 보낸다.
        
        대부분 운영체제는 이것을 심각한 에러로 취급하여 버퍼에 저장된, 아직 읽히지 않은 데이터를 모두 삭제한다.
    - 우아하게 커넥션 끊기
        - 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널을 끊기는 것을 기다리는 것이다.
        
        애플리케이션은 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 상태 검사를 주기적으로 하고,
        입력 채널이 타임아웃 시간 내에 끊어지지 않는다면 애플리케이션은 리소스를 보호하기 위해 강제로 커넥션을 끊을 수 있다.
# 20장 리다이렉션과 부하 균형

### 왜 리다이렉트인가?

- 리다이렉션이란 최적의 분산된 콘텐츠를 찾는 것을 도와주는 기법의 집합이라고 할 수 있다.
- 리다이렉션은 현대의 웹에서 피할 수 없는 현실이다.
    - 그 이유는 HTTP 애플리케이션이 아래 세가지를 원하기 때문이다.
        - 신뢰할 수 있는 HTTP 트랜잭션의 수행
        - 지연 최소화
        - 네트워크 대역폭 절약
- 리다이렉션 장치들은 들어오는 메시지의 부하를 서버들의 집합에게 분산할 수 있다.

### 리다이렉트 할 곳

- 서버, 프락시, 캐시, 게이트웨이는 클라이언트가 그들에게 HTTP 요청을 보내고
그것들을 처리한다는 관점에서 보면, 클라이언트에게 있어 모두 서버라고 할 수 있다.
- 서버, 프락시, 캐시, 게이트웨이가 모두 공통적으로 서버의 특성을 갖고 있기 때문에
많은 리다이렉션 기법이 그들 모두에서 동작한다.
그러나 어떤 리다이렉션 기술들은 특정 종류의 종단만을 위해 설계되어
일반적인 적용이 불가하다.
- 웹 서버는 IP별로 요청을 다루고,
프락시는 프로토콜별로 요청을 다룬다.

### 리다이렉션 프로토콜의 개요

- 리다이렉션의 목표는 HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것이다.
- HTTP 메시지가 인터넷을 통해 나아가는 방향은 그 메시지가 오고, 거쳐가고, 향하는
HTTP 애플리케이션과 라우팅 장치에 영향을 받는다.
- 브라우저 설정, DNS, TCP/IP 라우팅, 그리고 HTTP는
모두 메시지를 리다이렉트 하는 메커니즘을 제공한다.

### 일반적인 리다이렉션 방법

- HTTP 리다이렉션
    - 웹 서버들은 다른 곳에 요청을 보내라고 말해주는 짧은 리다이렉트 메시지를
    클라이언트에게 돌려줄 수 있다.
    - 요청을 처리하는 서버는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아
    브라우저의 요청을 그 서버로 리다이렉트 한다.
    - 웹 서버들이 광범위하게 분산되어 있다면 최선의 가용한 서버를 결정하는 것은
    더욱 어려워진다.
    - HTTP 리다이렉션이 갖는 장점 중 하나는 리다이렉트를 하는 서버가
    클라이언트의 아이피 주소를 안다는 것이다.
- DNS 리다이렉션
    - DNS 라운드 로빈
        - 웹 서버 팜 전체에 대한 부하의 균형을 유지하기 위해
        DNS 호스트 명 분석 기능을 사용한다.
        - 이 방식은 서버에 대한 클라이언트의 상대적 위치나
        서버의 현재 스트레스를 고려하지 않는다.
    - 다중 주소와 로빈 주소 순환
        - 부하 균형을 위해 대부분의 DNS 서버는 룩업이 끝났을 때마다 주소를 순환시킨다.
    - DNS 캐싱의 효과
        - 호스트 하나에 대한 한 번의 DNS 룩업을 수행한 뒤
        그 주소를 몇번이고 다시 사용한다.
        - 이렇게 하면 DNS 룩업의 비용을 줄일 수 있을 뿐 아니라,
        같은 클라이언트와 계속 대화하는 것을 선호하는 서버들도 있기 때문이다.
    - 다른 DNS 기반 리다이렉션 알고리즘
        - 부하 균형 알고리즘
            - 몇몇 DNS 서버는 웹 서버의 로드를 추적하고
            가장 로드가 적은 웹 서버의 목록의 가장 위에 놓는다.
        - 근접 라우팅 알고리즘
            - 웹 서버들의 팜이 지리적으로 분산되어 있는 경우,
            DNS 서버는 사용자를 근처의 웹 서버로 보내는 시도를 할 수 있다.
        - 결함 마스킹 알고리즘
            - DNS 서버는 네트워크의 건강 상태를 모니터링하고 요청을 정전이나
            기타 장애를 피해서 라우팅 할 수 있다.
- 임의 캐스트 어드레싱
    - 임의 캐스트 어드레싱에서 여러 지리적으로 흩어진 웹 서버들은
    정확히 같은 아이피 주소를 갖고 클라이언트의 요청을 클라이언트에서
    가장 가까운 서버로 보내주기 위해 백본 라우터의 최단거리 라우팅 능력에 의지한다.
    - 이 기법은 분산 임의 캐스트의 동작을 위해 서버는 반드시 라우터의 언어로 말해야하고
    라우터는 일어날 수 있는 주소 충돌을 다룰 수 있어야 한다.
- 아이피 맥 포워딩
    - 이더넷 네트워크에서 HTTP 메시지는 주소가 붙은 데이터 패킷의 형태로 보내진다.
    - 각 패킷은 출발지와 목적지의 아이피 주소와 TCP 포트번호로
    이루어진 레이어-4 주소를 갖고 있다.
    - MAC 주소 포워딩은 점 대 점으로만 가능하기 때문에 서버나 프락시는
    스위치와 한 홉 거리에 위치해야 한다.
- 아이피 주소 포워딩
    - 아이피 주소 포워딩에서 스위치나 다른 레이어-4 를 이해하는 장비는
    들어오는 패킷에 대해 TCP/IP 어드레싱을 검증하고 패킷을 목적지 맥 주소가 아니라 목적지 아이피 주소의 변경에 따라 라우팅한다.
    - 맥 포워딩 보다 좋은 점 하나는 목적지 서버가 한 홉 거리에 있을 필요가 없고 
    스위치에서 업 스트림의 위치를 판별할 수만 있으면
    일반적인 레이어-3 종단간 인터넷 라우팅이 패킷을 올바른 위치로 보내준다.
    - 그러나 여기에는 라우팅 대칭성이라는 문제가 존재하는데 클라이언트로부터 들어오는 TCP 커넥션을 받아주는 스위치는 그 커넥션을 관리하고 있다.
    스위치는 반드시 그 커넥션을 통해 클라이언트에게 응답을 돌려주어야 한다.
    그러므로 목적지 서버나 프락시로부터의 모든 응답은
    반드시 그 스위치에게 돌아가야 한다.
- 네트워크 구성요소 제어 프로토콜
    - 네트워크 구성요소 제어 프로토콜(NECP)은 아이피 패킷을 전달하는 라우터나
    스위치 같은 네트워크 구성요소들이 웹 서버나 프락시 캐시와 같이
    애플리케이션 계층 요청을 처리하는 서버 구성요소들과 대화할 수 있게 해 준다.

### 프락시 리다이렉션 방법

- 명시적 브라우저 설정
    - 대부분의 브라우저에는 프락시 서버에 접촉하기 위해
    프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 풀다운 메뉴가 존재한다.
    사용자가 이를 설정하면 브라우저는 모든 요청에 대해 프락시와 접촉한다.
    - 명시적인 브라우저 설정에는 두 가지 단점이 존재한다.
        - 프락시들을 사용하도록 설정된 브라우저들은
        프락시가 응답하지 않더라도 원 서버와 접촉하지 않는다.
        - 네트워크 아키텍처를 변경했을 때 그 변경사항을
        모든 최종사용자에게 전파하는 것이 어렵다.
- 프락시 자동 설정
    - 프락시 자동설정(PAC)은 브라우저들이 URL 별로 접촉해야 할
    프락시를 지정한 PAC 파일이라 불리는 특별한 파일을 찾도록 하는 것이다.
    - 브라우저는 반드시 PAC 파일을 얻기 위해 지정된 서버에 접촉하도록 설정되어야 한다.
    그런 뒤 브라우저는 재시작할 때마다 PAC 파일을 가져온다.
    - PAC는 브라우저가 자동으로 네트워크 아키텍처 안에서의 변경에 맞는
    올바른 프락시에 접촉할 수 있도록 해줄 수 있다.
- 웹 프락시 자동발견 프로토콜
    - 웹 프락시 자동발견 프로토콜(WPAD)은 최종 사용자가 수동으로 프락시 설정을
    할 필요도, 투명한 트래픽 인터셉트에 의존할 필요도 없이 웹브라우저가
    근처의 프락시를 찾아내어 사용할 수 있게 해주는 방법을 제공하는 것이 목적이다.
    - PAC 파일 자동발견
        - WPAD는 HTTP 클라이언트가 PAC 파일 위치를 알아내고 그 파일을 이용해
        적절한 프락시 서버의 이름을 알아낼 수 있게 해준다.
    - WPAD 알고리즘
        - WPAD는 적절한 PAC 파일 CURL을 결정하기 위해
        여러가지 리소스 발견 기법들을 사용한다.
        - WPAD 명세는 아래 다섯 메커니즘을 정의하고 있다.
            - DHCP(동적 호스트 설정 프로토콜)
            - SLP(서비스 위치 프로토콜)
            - DNS 에게 잘 알려진 호스트 명
            - DNS 의 SRV 레코드
            - TXT 레코드의 DNS 서비스 URL들
        - 이 다섯 메커니즘 중에 WPAD 클라이언트에게는 오직 DHCP와 DNS에게
        잘 알려진 호스트 명 기법만이 요구된다.
    - DHCP를 이용한 CURL 발견
        - 이 메커니즘이 동작하려면 WPAD 클라이언트가 질의하는 DHCP 서버는
        반드시 CURL을 저장하고 있어야 한다.
        - WPAD 클라이언트는 DHCP 질의를 DHCP 서버에 보냄으로써 CURL을 얻는다.
    - DNS A 레코드 룩업
        - 이 메커니즘이 동작하려면 알맞은 프락시 서버의 IP 주소들이
        WPAD 클라이언트들이 질의할 수 있는 DNS 서버에 반드시 저장되어 있어야 한다.
        - WPAD 클아이언트는 A 레코드 룩업을 DNS 서버로 보내 CURL 을 얻는다.
    - PAC 파일 가져오기
        - 한번 후보 CURL이 생성되면 WPAD 클아이언트는 보통 그 CURL로
        GET 요청을 만드는데, 이때 자신이 다룰 수 있는 적절한 CFILE 포맷 정보가 담긴
        Accept 헤더를 포함해야 한다.
    - 언제 WPAD를 실행하는가
        - 웹 클라이언트가 시작될 때
        - 클라이언트 호스트의 아이피 주소가 변경된 네트워킹 스택으로부터 언급이 있을 때
    - WPAD 스푸핑
        - WPAD의 IE 5 구현은 사용자의 개입 없이 웹 클라이언트가 프락시 설정을 자동으로
        탐지하는 것을 가능하게 했다.
        - 하지만 이것은 보안 취약점을 노출하게 되는데, 악의적인 사용자가
        WPAD 서버 설정을 하고 그의 의도대로 프락시가 설정되도록 하는 명령을
        제공할 수도 있다.
        이후 버전의 IE 에서는 이 문제를 바로잡았다.
    - 타임아웃
        - WPAD 는 여러 발견 단계를 거치게 되며, 클라이언트는 각 단계가
        일정한 시간 내에 끝나는지 반드시 확인해야 한다.

### 캐시 리다이렉션 방법

- WCCP 리다이렉션
    - 캐시 조직 프로토콜(WCCP)은 라우터들과 캐시들 사이의 대화를 관리해
    라우터가 캐시를 검사하고 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 해준다.
    - WCCP 리다이렉션 동작
        - 네트워크가 필요하며 이 네트워크에는 WCCP 를 사용할 수 있는 라우터,
        다른 캐시와 의사소통할 수 있는 캐시가 포함되어야 한다.
        - 라우터들의 집합과 그들의 대상이 되는 캐시들이 WCCP 서비스 그룹을 구성한다.
        - 만약 서비스 그룹이 HTTP 트래픽을 리다이렉션하도록 설정되어 있다면
        서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보낸다.
        - HTTP 요청이 서비스 그룹의 라우터에 도착했을 때, 라우터는 그 요청을 처리하기 위해
        서비스 그룹의 캐시 중 하나를 선택한다.
        - 라우터는 요청 패킷을 캐시의 아이피 주소와 함께 캡슐화 또는 아이피 맥 포워딩을 해
        캐시로 보낸다.
        - 만약 캐시가 요청을 처리할 수 없다면 패킷은 평범하게 포워딩되기 위해
        라우터로 돌아온다.
        - 서비스 그룹의 구성원들은 지속적으로 다른 구성원들의 가용성을 확인하기 위해
        하트비트 메시지(정상 동작 메시지)를 교환한다.
    - WCCP 부하 균형
        - WCCP 라우터는 라우팅만이 아닌 여러 수신 서버 간의 부하 균형을 유지할 수 있다.

### 인터넷 캐시 프로토콜

- 인터넷 캐시 프로토콜(ICP)은 캐시들이 형제 캐시에서 일어난
캐시 적중을 찾아볼 수 있게 해준다.
- 만약 캐시가 HTTP 메시지에서 요청한 콘텐츠를 갖고 있지 않다면 캐시는 근처
형제 캐시 중 그 콘텐츠를 갖고 있는지 찾아보고,
만약 있다면 원 서버에 질의하는 것보다 비용이 더 들지 않을 것을 기대하며
그 캐시에서 콘텐츠를 가져온다.

### 캐시 배열 라우팅 프로토콜

- 캐시 배열 라우팅 프로토콜(CARP)은 프락시 서버의 배열이 클라이언트 시점에서
마치 하나의 논리적 캐시처럼 보이도록 관리해주는 표준이다.
- CARP는 ICP의 대안으로 둘 다 관리자가 여러 대의 프락시 서버를 사용해 성능을
개선할 수 있게 해준다.
- CARP 프로토콜은 협력은 하지만 분산된 캐시가 되는 ICP와 달리
프락시 서버 그룹을 하나의 캐시 집단으로 보이게 해준다.
- 결정론적인 요청 분석 경로는 한 홉 안에 있는 특정 웹 객체의 거처를 찾아내는데,
ICP에서 웹 객체를 찾아내기 위해 자주 생성되는 프락시 간 트래픽을 제거한다.
- CARP는 중복된 웹 캐시에 대한 사본의 중복을 피하게 되는데
이로 인해 캐시 시스템이 집합적으로 웹 객체를 더 많이 보관할 수 있다는 장점이 있지만,
어느 하나의 프락시가 실패하면 상당량의 캐시 콘텐츠를 재배치해야 한다는 단점도 있다.

### 하이퍼텍스트 캐싱 프로토콜

- ICP는 HTTP/0.9를 염두에 두고 설계되어 캐시가 리소스의 존재 여부를 질의할 때
URL만을 보내도록 하고있다.
- HTTP 버전 1.x는 URL과 더불어 문서 매칭에 대한 판단을 내릴 때 사용될 수 있는
많은 요청 헤더를 도입했기에 단순히 요청의 URL만을 보내는 것은
정확한 응답을 가져오지 못하는 결과를 가져올 수 있다.
- 그래서 나온 하이퍼텍스트 캐싱 프로토콜(HTCP)은 형제들이 URL과 모든 요청 및
응답 헤더를 사용해 서로에게 문서의 존재 여부에 대한 질의를 할 수 있도록 해줌으로써
적중이 아님에도 적중으로 잘못 처리될 확률을 줄인다.
- 또한 HTCP는 형제 캐시들이 서로의 캐시 안에 있는
선택된 문서의 추가 및 삭제를 모니터링하고 요청할 수 있게,
그리고 서로의 캐시된 문서에 대한 캐싱 정책을 변경할 수 있게 해준다.
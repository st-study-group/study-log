# 1장 HTTP 개관

### 1.1 HTTP: 인터넷의 멀티미티어 배달부

HTTP 는 전세계의 웹서버로부터 대량의 정보룰 빠르고, 간편하고, 정확하게 사람들의 PC에 설치된 웹브라우저로 옮겨줌

HTTP 는 신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에, 데이터가 지구 반대편에서 오더라도 전송도중 손상되거나 꼬이지 않음을 보장함.

### 1.2 웹 클라이언트와 서버

웹서버는 인터넷의 데이터를 저장하고, HTPP 클라이언트가 요청한 데이터를 제공함.

 웹브라우저는 서버에게 HTTP 객체를 요청하고 사용자의 화면에 보여줌

예를 들어 www.[example.com/index.html](http://example.com/index.html) 페이지를 열어볼때, 웹브라우저는 HTTP 요청을 www.[example.com](http://example.com/index.html) 서버로 보냄, 서버는 요청받은 객체 (/index.html) 을 찾고, 성공했다면 그것의 타입,길이 등의 정보와 함께 HTTP 응답에 실어서 클라이언트에게 보냄

클라이언트 → (HTTP 요청) /index.html 이라는 이름의 문서를 가져와라       →  www.oreilly.com

                 ← (HTTP 응답) HTTP 포맷으로 되어있고, 길이는 3,150 글자다  ←

### 1.3 리소스

웹 서버는 웹 리소스를 관리하고 제공함.

웹 리소스는 정적파일 텍스트, HTML 파일, JPEG 이미지 등 모든 종류의 파일을 포함함.

리소스는 반드시 정적파일 일 필요없음. 리소스는 요청에 따라 콘텐츠를 생산하는 프로그램이 될 수도 잇음. 

### 1.3.1 미디어 타입

인터넷은 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙음 (MIME - Multipurpose Internet Mail Extenstions)

MIME 원래 각기 다른 전자메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계되었음

MIME는 이메일 에서 워낙 잘 동작했기 때문에, HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨을 붙이기 위해 채택됨

웹 브라우저는 잘 알려진 객체 타입 수백가지를 다룰 수 있음. 

[클라이언트] ← Content-Type : image/jpeg  (MIME 타입 )  ← [서버] 

MIME 는 주타입 과 부타입으로 이루어진 문자열로 이루어짐

- HTML 로 작성된 문서는 text/html
- plain ASCII 텍스트 text/plain
- JPEG 이미지는 image/jpeg
- GIF는 image/gif

### 1.3.2 URI

서버 리소스 이름은 통합 자원 식별자 혹은 URI 라고 불림

URI 는 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있음

URI 가 HTTP 프로토콜에서 해석되는 예시

- http://www.joes-hardware.com/specials/saw-blade.gif
    - http - http 프로토콜
    - [www.joes-hardware.com](http://www.joes-hardware.com) - www.joes-hardware.com 로 이동하라
    - /specials/saw-blade.gif - /specials/saw-blade.gif 라고 불리는 리소스를 가져와라

URI 에는 두가지가 있음 URL 과 URN 이 있음

### 1.3.3 URL

URL 은 세부분으로 이루어진 표준 포멧을 따름

- URL 의 첫번째 부분은 스킴(scheme)이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술함. 보통 HTTP 프로토콜(http://)이다.
- 서버의 인터넷 주소를 제공함. (ex) www.joes-hardware.com)
- 웹 서버의 리소스를 가르킴 (ex) /specials/saw-blade.gif)

오늘날 대부분의 URI 는 URL 임

### 1.3.4 URN

URN 은 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 함

위치 독립적인 URN은 리소스를 여기저기 옮기더라도 문제없이 동작함

리소스가 그 이름을 변하지 않게 유지하는 한, 여러 종류의 네트워크 접속 프로토콜로 접근해도 문제없음

예를 들어 URN 은 ‘RFC 2141’가 어디에 있거나 상관없이 그것을 지칭하기 위해 사용할 수 있음.

urn:ietf:rfc:2141

URN 은 여전히 실험중인 상태임, 효율적인 동작을 위해 URN은 리소스 위치를 분석하기 위한 인프라 지원이 필요한데, 그러한 인프라가 부재하기에 URN 채택이 더 늦춰지고 있음. 

### 1.4 트랜잭션

HTTP 트랜잭션은 요청명령과 응답결과로 구성되어 있음.

HTTP 메세지라고 불라는 정형화된 데이터 덩어리를 이용해 이루어짐

### 1.4.1 메서드

HTTP 요청 메세지는 한개의 메서드를 갖음, 
메서드는 서버에게 어떤 동작이 취해져야 하는지 말해줌
메서드 예제 - GET, PUT, DELETE, POST, HEAD

### 1.4.2 상태코드

모든 HTTP 응답 메세지는 상태코드와 함께 반환됨. 세자리 숫자임

예제 - 200, 302, 404

### 1.4.3 웹페이지는 여러 객체로 이루어 질 수 있다.

페이지 레이아웃 HTML 을 한번의 트랜잭션으로 가져온뒤, 첨부된 이미지, 그래픽 조각 등을 가져오기위해 추가로 HTTP 트랜잭션들을 수행함.

### 1.5 메시지

HTTP 메세지는 단순한 줄 단위의 문자열임

이진 형식이 아닌 일반 텍스트이기 떄문에 사람이 읽고 쓰기 쉬움

HTTP 메세지는 세부분으로 이루어짐, 시작줄, 헤더, 본문

- 시작줄
    - 요청이라면 무엇을 해야하는지, 응답이라면 무슨일이 일어났는지 나타냄
- 헤더
    - 시작줄다음 0개 이상의 헤더 필드가 이어짐
    - 각 헤더 필드는 쌍점(:)으로 구분되어, 이름과 하나의 값으로 구성됨
    - 헤더필드를 추가하려면 그저 한 줄을 추가하기면하면 됨
- 본문
    - 빈줄 다음 어떤 종류의 데이터든 들어갈 수 있는 메세지 본분이 필요에 따라 올 수 있음.
    본문은 임의의 이진 데이터를 보함할 수 있음

|  | 요청 메세지 예제 | 응답 메세지 예제 |
| --- | --- | --- |
| 시작줄
헤더

본문 | GET /test/hi-there.text HTTP/1.0
Accept: text/*
Accept-Language: en,fr | HTTP/1.0 200 OK
Content-type: text/plain
Content-length: 19

Hi! I’m a message! |
|  |  |  |

### 1.5.1 간단한 메세지의 예

웹브라우저는 리소스 [http://www.joes-hardware.com/tools.html](http://www.joes-hardware.com/tools.html) 요청

웹브라우저는 HTTP 요청 메세지를 보냄, 시작줄에 GET 메소드가 있고, 로컬리소스는 /tools.html 임, HTTP 프로토콜른 1.0 버전으로 요청 (요청 본문 없음)

응답에는 HTTP 버전 번호, 상태코드, 사유구절, 응답헤더 , 응답 본문이 들어 있음.

### 1.6 TCP 커넥션

### 1.6.1 TCP/IP

HTTP 는 어플리케이션 계층 프로토콜임

HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서는 신경쓰지 않음. 

TCP/IP 에게 맡김

TCP 는 다음을 제공함

- 오류 없는 데이터 제공
- 순서에 맞는 전달(데이터는 언제나 보낸 순서대로 도착함)
- 조각나지 않는 데이터 스트림 (언제든 어떤 크기로는 보낼 수 있음)

TCP/IP 는 TCP와 IP가 층을 이루는 패킷 교환 네트워크의 프로토콜의 집합임

[HTTP 네트워크 프로토콜 스택]

| HTTP | 애플리케이션 계층 |
| --- | --- |
| TCP | 전송계층 |
| IP | 네트워크 계층 |
| 네트워크 데이터 링크 인터페이스 | 데이터 링크 계층 |
| 물리적인 네트워크 하드웨어 | 물리계층 |

### 1.6.2 접속, IP 주소 그리고 포트번호

HTTP 클라이언트가 서버에 메세지를 전송 할 수 있게 되기전에

인터넷 프로토콜 주소(IP) 와 포트번호 를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야함

서버의 단순한 HTML 리소스를 사용자에게 보여주는 순서

- 웹 브라우저는 서버의 URL에서 호스트 명을 추출함
- 웹 브라우저는 서버의 호스트명을 IP로 변환함
- 웹 브라우저는 URL에서 포트번호를 추출함
- 웹 브라우저는 웹서버와 TCP 커넥션을 맺음
- 웹 브라우저는 서버에 HTTP 요청을 보냄
- 서버는 웹브라우저에 HTTP 응답을 돌려 줌
- 커넥션이 닫히면, 웹 브라우저는 문서를 보여줌

### 1.6.3 텔넷을 이용한 실전 예제

[www.joes-hardware.com](http://www.joes-hardware.com) 을 연결 하는예제

- [`www.joes-hardware.com`](http://www.joes-hardware.com) 의 ip 주소를 찾아 그 컴퓨터에 80번 포트로 TCP 커넥션을 맺어야함
    - 이 일을 telnet 이 대신 해줌
- 일단 TCP 커넥션이 연결되면, HTTP 요청을 타이핑해서 입력해야함
- 요청이 완료되면, 서버는 컨텐츠를 HTTP 응답에 담아 반환하고 커넥션을 끊음

`% telnet [www.joes-hardware.com](http://www.joes-hardware.com) 80`

- 연결된후 HTTP 요청을 작성
    - 마지막 빈줄로 작성하면 작성완료
- 서버는 컨텐츠를 HTTP 응답에 담아 반환하고 커넥션 끊음

### 1.7 프로토콜 버전

- HTTP/0.9
    - 1991년의 HTTP 프로토타입은 HTTP/0.9 로 알려져 있음
    - 오직 GET 메서드만 지원함
    - 멀티미디어 컨텐츠에 대한 MIME 타입이나, HTTP 헤더, HTTP 버전 번호는 지원하지 않음
    - HTTP/0.9는 원래 간단한 HTML 객체를 받아 오기위해 만들어짐
- HTTP/1.0
    - HTTP 버전 번호, 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가되었음
    - HTTP/1.0 은 잘 정돈된 명세가 아님
    - HTTP가 상업적, 학술적으로 급성장 하던 시기에 만들어진, 잘 동작하는 용례들의 모음에 가까움
- HTTP/1.0+
    - 1990년대 중반 웹이 급격하게 성장하며 웹클라이언트와 서버들은 빠르게 HTTP에 기능을 추가해갔음
    - “keep-alive” 커넥션, 가상 호스팅 지원, 프락시 연결 지원 포함해 많은 기능이 공식적이지는 않지만 사실상의 표준으로 HTTP 에 추가됨
    - 이 규격 외의 확장된 HTTP 버전을 HTTP/1.0+ 라고 부름
- HTTP/1.1
    - HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거에 집중
    - HTTP/1.1 은 더 복잡해진 웹 애플리케이션과 배포를 지원함
- HTTP/2.0
    - HTTP/1.1 성능 문제를 개선하기위해 구글의 SPDY(스피디) 프로토콜을 기반으로 설계가 진행중인 프로토콜임
    - 현재
        - 위키 피디아 - 2014년 12월 표준안 제안(Proposed Standard)으로 고려되어, 2015년 2월 17일 IESG에서 제안안으로 승인되었다. 2015년 5월, [RFC 7540](https://tools.ietf.org/html/rfc7540)
        로 공개되었다.
        

### 1.8 웹의 구성 요소

- 프락시
    - 클라이언트와 서버 사이에 위치한 HTTP 중개자
- 캐시
    - 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
- 게이트웨이
    - 다른 애플리케이션과 연결된 특별한 웹 서버
- 터널
    - 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 에이전트
    - 자동화된 HTTP 요청을 만드는 준지능적 웹 클라이언트
    

### 1.8.1 프락시

프락시는 클라이언트와 서버 사이에 위치하여, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달함.

프락시는 주로 보안을 위해 사용됨, 모든 웹 트래픽 흐름속에서 신뢰할만한 중개자 역할을 함

프락시는 요청과 응답을 필터링함

### 1.8.2 캐시

웹 캐시와 캐시 프락시는 자신을 거쳐가는 문서들중 자주 찾는 것의 사본을 저장해두는 특별한 종류의 프락시 서버임

다음번에 클라이언트가 같은 문서를 요청하면 그 캐시가 갖고 있는 사본을 받을 수 있음

### 1.8.3 게이트웨이

게이트웨이는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용됨

게이트웨이는 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룸

클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못함

### 1.8.4 터널

HTTP 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용 됨

예로는 암호화된 SSL 트랙픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이 있음

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%80%E1%85%A2%E1%84%80%E1%85%AA%E1%86%AB%207045d0de15f34592ab07090606a252c0/Untitled.png)

### 1.8.5 에이전트

사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램임

웹브라우져 이외에 여러가지 종류의 사용자 에이전가 있음

예로는 스파이더, 웹로봇 등이 있음
# 3장 HTTP 메시지

## 3.1 메시지의 흐름

- HTTP 메시지 : HTTP 애플리케이션 간에 주고받는 데이터의 블록들
- 인바운드 : 메시지가 원 서버로 향하는 것
- 아웃바운드 : 처리 후 메시지가 사용자 에이전트로 돌아오는 것
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled.jpeg)
    
- 요청 메시지냐 응답 메시지냐에 관계 없이 모든 메시지는 다운 스트림으로 흐른다.

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%201.jpeg)

## 3.2 메세지의 각 부분

- HTTP 메시지: 단순한 데이터의 구조화된 블록
    - 시작줄
        - 어떤 메시지인지 서술
    - 헤더블록
        - 속성
    - 본문
        - 데이터를 담고 있다. 아예 없을 수도 있다.
- 시작줄과 헤더는 캐리지 리턴과 개행문자로 구성된 줄바꿈 문자열(CRLF)로 끝난다 → 오래되거나 잘못 만들어진 HTTP 애플리케이션 중에서는 캐리지 리턴과 개행 문자 모두를 항상 전송하지 않는 것들도 있기 때문에 이 점을 고려해야한다.
- 메시지 문법
    - 요청 메시지 : 웹 서버에 어떤 동작을 요구
    - 응답 메시지 : 요청의 결과를 클라이언트에게 돌려줌
    - 메서드 : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
    - 요청 URL : 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성 요소
    - 버전 : 이 메시지에서 사용중인 HTTP의 버전
    - 상태 코드 : 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자
    - 사유 구절 : 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
    - 헤더들 : 이름, 콜론(;), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
    - 엔터티 본문 : 임의의 데이터 블록을 포함. 모든 메시지가 엔터티 본문을 갖는 것은 아니므로, 때때로 메시지는 CRLF으로 끝나게 된다. → 클라이언트와 서버는 마지막 CRLF 없이 끝나는 메시지도 받아들일 수 있어야 한다.
- 시작줄
    - 모든 HTTP 메시지는 시작줄로 시작
    - 시작줄은 무엇을 해야하는지 말해준다
    - 요청줄 : 서버에서 어떤 동작이 일어나야하는지 설명해주는 메서드 + 그 동작에 대한 대상을 지칭하는 요청 URL + HTTP 버전
    - 응답줄 : 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줌. HTTP 버전 + 상태코드 + 사유구절
    - 메서드 : 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야하는지 말해줌. 이 외에도 확장메서드를 구현할 수 있음
        
        ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%202.jpeg)
        
    - 상태코드 : 클라이언트에게 무엇이 일어났는지 말해줌. 각 응답 메시지의 시작줄에 담겨 반환. 인식할 수 없는 상태 코드를 받게 되면, 누군가가 현재 프로토콜의 확장으로 그것을 정의한 것 → 그 상태코드를 포함하는 일반적인 구성원이라고 가정하고 다뤄야함(예. 5xx 코드는 서버에러코드)
    - 사유구절 : 응답 시작줄의 마지막 구성요소. 상태코드에 대한 글로 된 설명을 제공. 상태코드와 일대일로 대응
    - 버전 번호 : 요청과 응답 메시지 양쪽 모두에 기술. 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 기리킴
- 헤더
    - 헤더분류
        - 일반 헤더 : 요청과 응답 양쪽에 모두 나타날 수 있음
        - 요청 헤더 : 요청에 대한 부가 정보를 제공
        - 응답 헤더 : 응답에 대한 부가 정보를 제공
        - Entity 헤더 : 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
        - 확장 헤더 : 명세에 정의 되지 않은 새로운 헤더
- 엔티티 본문
    - 선택적인 엔티티 본문
    - HTTP가 수송할 수 있도록 설계된 메시지 화물

## 3.3 메서드

- 안전한 메서드 : HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 의미 
→ GET, HEAD
- GET : 서버에게 리소스를 달라고 요청하기 위해 쓰임
- HEAD : GET 처럼 행동하지만, 서버는 응답으로 헤더만을 올려줌(엔터티 본문 X)
    - 리소스를 가져오지 않고도 그에대해 무엇인가(타입 등)를 알아낼 수 있다.
    - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
    - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다
- PUT : 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것
- POST: 서버에 입력 데이터를 전송
- TRACE : 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌.
루프백(loopback) 진단 : 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%203.jpeg)
    
- OPTIONS : 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봄
- DELETE : 지정한 리소스를 삭제할 것을 요청. 클라이언트는 삭제가 수행되는 것을 보장하지 못함 → HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용
- 확장 메서드 : HTTP/1.1 명세에 정의 되지 않은 메서드. “엄격하게 보내고 관대하게 받아들여라”라는 규칙을 따르는 것이 좋음

## 3.4 상태코드

- 100-199: 정보성 상태코드
    - HTTP/1.1 에서 도입됨
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%204.jpeg)
    
    - 클라이언트와 100 Continue
        - 클라이언트가 엔터티를 서버에게 보내려하고, 그전에 100 Continue응답을 기다림
        - 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적
        - 막연히 기다리지 말고 약간의 타임아웃 후에 클라이언트는 엔터티를 보내야함
    - 서버와 100 Continue
        - 이 요청을 받는다면, 100 Continue 혹은 에러 코드로 응답해야함
        - 서버가 100 Continue 응답을 보내기 전에 엔터티를 받았다면 서버는 이 상태 코드를 보낼 필요가 없음 → 클라이언트가 계속해서 전송하기로 결정했기 때문
    - 프락시와 100 Continue
        - 만약 다음 홉 서버가 HTTP/1.1을 따르거나 혹은 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함시켜서 요청을 다음으로 전달해야함. 만약 다음 홉의 서버가 1.1보다 이전 버전의 HTTP를 따른다는 것을 알고 있다면 프락시는 417 Expectation Falied 에러로 응답
        - 만약 프락시가 HTTP/1.0 이나 이전 버전을 따르는 클라이언트를 대신하여 Expect헤더와 100-continue 값을 요청에 포함시키기로 결정했다면, 프락시는 100 Continue 응답을 클라이언트에 전달해서는 안됨. → 클라이언트는 그것을 어떻게 해야할지 모르기 때문
- 200-299: 성공 상태 코드
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%205.jpeg)
    
- 300-399 : 리다이렉션 상태코드
    - 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공
    - 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용
        
        ![D3A13D27-2488-41C8-A708-EC1C778B1E2F.jpeg](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/D3A13D27-2488-41C8-A708-EC1C778B1E2F.jpeg)
        
        ![AB203A9D-9C49-42F1-A7B2-7AA7C55D58CB.jpeg](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/AB203A9D-9C49-42F1-A7B2-7AA7C55D58CB.jpeg)
        
- 400~499 : 클라이언트 에러 상태 코드
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%206.jpeg)
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%207.jpeg)
    
- 500-599: 서버 에러 상태 코드
    - 서버 자체에서 에러가 발생하는 경우
    
    ![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%20f823ccfc7b8f470ab37239b5da81fa58/Untitled%208.jpeg)
    

## 3.5 헤더

- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용
- 일반 헤더
    - 클라이언트와 서버 양쪽 모두 사용.
    - 메시지에 대한 아주 기본적인 정보 제공
- 요청 헤더
    - 요청 메시지를 위한 헤더. 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무언인지와 같은 부가 정보를 제공
    - 요청이 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보다 클라이언트의 선호나 능력에 대한 정보
    - Accept 관련 헤더: 클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있음
    - 조건부 요청 헤더 : 클라이언트는 요청에 몇몇 제약을 넣기도함
    - 요청 보안헤더 : HTTP가 가지고 있는 자체적으로 요청을 위한 간단한 인증요구/응답 체계
    - 프락시 요청 헤더 : 프락시의 기능을 돕기위한 헤더
- 응답 헤더
    - 응답 메시지는 클라이언트에게 부가 정보를 제공하기 위한 자신만의 헤더
    - 협상 헤더 : 서버가 협상 가능한 리소스에 대한 정보를 운반
    - 응답 보안 헤더 : HTTP 인증요구/응답 체계에서 응답 측에 해당
- 엔터티 헤더
    - 엔터티 본문에 대한 헤더
    - 엔터니와 그것의 내용물에 대한, 개체의 타입부터 시작해서 주어진 리소스에 대해 요청할 수 있는 유효한 메서드들까지, 광범위한 정보를 제공
    - 콘텐츠헤더 : 엔터티의 콘텐츠에 대한 구체적인 정보 제공
    - 엔터티 캐싱 헤더 : 일반 캐싱헤더는 언제 어떻게 캐시가 되어야하는지에 대한 지시자를 제공. 엔터티 캐싱헤더는 엔터티 캐싱에 대한 정보 제공.
- 확장 헤더
    - 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더
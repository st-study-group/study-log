# 14장 보안 HTTP

### 14.1 HTTP를 안전하게 만들기

## HTTP 보안 기술의 요구 사항

1. 서버 인증 - 클라이언트가 위조된 서버가 아닌 진짜 서버와 통신 중이라는 것을 알 수 있어야 함
2. 클라이언트 인증 - 서버가 진짜 클라이언트와 통신중임을 알 수 있어야 한다.
3. 무결성 - 데이터가 위조되는것으로 부터 안전해야한다.
4. 암호화 - 도청에 대한 걱정 없이 대화 할 수 있어야한다.
5. 효율 - 저렴한 서버도 사용 가능하도록 알고리즘이 빨라야한다.
6. 편재성 - 프로토콜이 거의 모든 클라이언트/서버에서 지원되야한다.
7. 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야한다.
8. 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
9. 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

## HTTPS 개요

- HTTPS는 HTTP를 안전하게 만드는 방법 중 가장 인기 있는 방법
- 넷스케이프 커뮤니케이션 주식회사에서 개척
- HTTPS는 HTTP 하부에 전송 레벨 암호 보안 계층을 제공하는 것이다.
이 보안 계층을 SSL/TLS라고 부른다.
    
    ![https://velog.velcdn.com/images/ngh/post/900f159c-4dae-4bc0-82fc-66f854c49a4e/image.png](https://velog.velcdn.com/images/ngh/post/900f159c-4dae-4bc0-82fc-66f854c49a4e/image.png)
    

### SSL/TLS

- TLS: 전송 계층 보안 (Transport Layer Security)
- SSL: 보안 소켓 레이어 (Secure Sockets Layer)
- TLS는 SSL 3.0을 기반으로 개발되었다.
SSL의 업그레이드 버전이며 명칭만 변경된 것이기 때문에 SSL과 TLS를 혼용해서 사용한다.

### 14.2 디지털 암호학 (안중요함)

- 암호
    
    암호는 평문을 인코더로 암호문을 만들고 디코더로 암호문을 평문으로 만드는 기법이다.
    
    ![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled.png)
    
    키가 있는 암호는 위와 같다.
    
    각 키에 따라 같은 인코더지만 다른 암호문이 출력된다.
    
    아주 옛날에는 사람이 손으로 암호를 풀었다.
    
    기술이 조금 진보해서 암호 기계를 사용해서 인코딩,디코딩을 수행했다.
    
    현재는 디지털 계산으로 빠른 속도로 인코딩, 디코딩을 수행한다.
    
    디지털 계산이 가능해짐으로 인해 두가지 주요한 발전이 이루어졌다.
    
    1. 속도 및 기능에 대한 기계 장치의 한계를 벗어남으로서 복잡한 인코딩/디코딩 알고리즘 사용 가능
    2. 매우 큰 키를 지원해서 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들 수 있음. 이로 인해 무작위로 추측한 키에 의한 크래킹이 어려워짐
    

### 14.3 대칭키 암호법

- 인코딩/디코딩에 동일한 키를 사용하는 방법
- DES, Triple-DES, RC2, RC4등의 알고리즘이 있다.

### 열거 공격

- 무차별적으로 모든 키 값을 대입해 보는 공격
- 대칭 키 암호에서 열거 공격으로 암호를 깨는데 필요한 시간은 키의 길이가 길수록 늘어난다.
- 1995년 기준 기술과 물가로 공격했을 경우, 아래 표와 같은 시간이 소요된다고 한다.

| 공격 비용 | 40비트 키 | 64 비트 키 | 128 비트 키 |
| --- | --- | --- | --- |
| 100000달러 | 2초 | 1년 | 10^19년 |
| 10000000달러 | 20밀리초 | 4일 | 10^17년 |
| 1000000000달러 | 200마이크로초 | 1시간 | 10^15년 |

### 단점

- 대칭키의 단점은 수신자와 송신자가 둘 다 공유 키를 가져야 한다는 것이다.
각각의 수신/송신 채널마다 비밀 키를 하나씩 생성해야만 한다.
N개의 노드가 N-1개의 노드와 통신하기 위해서는 N^2의 비밀 키를 관리해야 한다.

### 14.4 공개키 암호법

- 두 개의 비대칭 키를 사용한다.

클라이언트는 공개키를 사용하여 평문을 암호문으로 인코딩해서 서버에 전송한다.
서버는 개인키를 사용하여 암호문을 디코딩해서 평문으로 변경한다.

### 장점

- 공개키는 호스트당 하나만 생성되기 때문에 대칭키 처럼 관리해야 하는 키의 개수가 폭발적으로 늘어나지 않는다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%201.png)

### RSA

- 유명한 공개키 암호 체계이다.
- 큰 수의 소인수 분해가 어려움을 이용한 암호화 방식이다.
- 페르마의 소정리를 사용하여 비대칭 키를 생성하는데, 공개키만 가지고 개인키를 추론하는데에는 엄청난 시간이 걸린다.

### 혼성 암호 체계와 세션 키

- 공개키 알고리즘은 계산이 느리다.
이 단점을 해결하기 위해, 대칭키와 비대칭키를 섞어서 사용한다.
1. 공개 키 암호로 통신 채널 수립
2. 수립된 채널로 대칭 키 교환 후, 나머지 암호화는 대칭키 사용

### 14.5 디지털 서명

- 메시지에 붙어있는 특별한 암호 체크섬
- 메시지를 작성한 저자가 누군지 알려준다.
- 저자만이 개인키로 체크섬을 계산할 수 있다.
- 메시지 위조를 방지한다.
- 서버가 평문 메시지를 요약 한 후, 개인키로 암호화 한 것이 서명이다.
클라이언트가 서명을 공개키로 복호화 한 후, 평문 메시지를 요약한 것과 대조하여 메시지가 위조되었는지 확인한다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%202.png)

### 14.6 디지털 인증서

- 주민등록증같은 인터넷 신분증이다.
- 신뢰할 수 있는 기관으로부터 보증받은 사용자/회사의 정보를 담고 있다.
    
    ![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%203.png)
    
- 아래 사진은 구글의 인증서 정보이며, 평문을 개인키로 서명한 지문(디지털 서명)을 가지고 있다.
    
    ![https://velog.velcdn.com/images/ngh/post/db4b9873-a120-4269-8a46-cce52c86b88f/image.png](https://velog.velcdn.com/images/ngh/post/db4b9873-a120-4269-8a46-cce52c86b88f/image.png)
    
- 대부분의 디지털 인증서는 X.509 v3 구조를 따른다.
    
    ![https://velog.velcdn.com/images/ngh/post/ab634e6f-af3f-475a-aa4e-2a1d032280e8/image.png](https://velog.velcdn.com/images/ngh/post/ab634e6f-af3f-475a-aa4e-2a1d032280e8/image.png)
    

### 인증서 확인 절차

1. 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.
2. 인증서를 받으면 서명 기관을 검사한다.
이때, 신뢰할 수 있는 서명기관이면 브라우저는 해당 기관의 공개키를 가지고 있다.
3. 디지털 서명의 무결성을 검증한다.

### 14.7 HTTPS의 세부사항

### 보안 전송 셋업

일단 TCP 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화 (SSL 핸드셰이크)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%204.png)

### SSL 핸드셰이크

핸드셰이크에서는 다음과 같은 일이 일어난다

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%205.png)

## **HTTPS 통신 정리**

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%206.png)

### 브라우저의 인증서 검사 알고리즘

1. 날짜 검사: 인증서가 만료되었거나 활성화 되지 않았는지 확인하기 위해 인증서의 시작 및 종료일을 검사
-> 유효하지 않으면 에러 발생
2. 서명 신뢰도 검사: 인증기관(CA)가 브라우저가 신뢰할 수 있는 기관인지 확인
신뢰할 수 있는 CA가 간접적으로 서명한 인증서도 신뢰할 수 있다고 판단
-> 신뢰할 수 없으면 경고창 생성
3. 서명 검사: 서명으로 인증서의 무결성 검사
4. 사이트 신원 검사: 인증서의 도메인과 대화중인 서버의 도메인이 동일한지 검사
-> 다르다면, 에러 발생

### 가상 호스팅과 인증서

가상 호스팅을 사용하는 서버인 경우, 도메인이 달라서 인증서 오류가 발생할 수있다.

이 경우, 리다이렉트를 사용해서 인증서와 일치하는 도메인으로 보내야한다.

### 14.8 진짜 HTTPS 클라이언트 (안중요함)

- **OpenSSL 은 SSL과 TLS의 가장 인기있는 오픈소스 구현이다.**
- C 언어로 작성되어있다.

### 14.9 프락시를 통한 보안 트래픽 터널링

웹 서버에 대신 접근해주는 웹 프락시 서버를 사용하는 경우, 
클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화 하면
웹 프락시 서버는 암호화된 데이터의 헤더를 읽을 수 없다.

클라이언트는 프락시에게 어디에 접속하려고 하는지를 알려주어야한다.

인기있는 기법은 HTTPS SSL 터널링 프로토콜 이다.

HTTPS 터널링 프로토콜을 사용해서 클라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 평문으로 말해준다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%207.png)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20c22aae28091b4e5a8deec4b2d9baccfd/Untitled%208.png)

위와같이 CONNECT 헤더를 설정해서 어디로 접속할지 알려준 후, SSL 로 암호화된 데이터를 전송한다.
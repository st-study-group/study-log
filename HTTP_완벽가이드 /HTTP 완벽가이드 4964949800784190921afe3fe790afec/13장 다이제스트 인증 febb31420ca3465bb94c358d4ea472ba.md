# 13장 다이제스트 인증

기본 인증은 편하고 유연하지만 안전하지 않다.
인증 정보를 평문으로 보내고 메시지를 위조하지 못하게 하려는 어떠한 시도도 하지않는다.

다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체재로서 개발되었다.

### 13.1 다이제스트 인증의 개선점

- 다이제스트 인증의 특징
    - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
    - 인증 체결을 가로채 재현하려는 악의적인 사람들을 차단한다.
    - 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
- 비밀번호를 안전하게 지키기 위해 요약(Digest) 사용하기
    - 비밀번호를 보내는 대신, 되돌릴 수 없는 상태로 뒤섞은 지문 또는 요약을 보낸다.
    클라이언트와 서버는 둘 다 비밀번호를 알고 있기 때문에
    클라이언트가 보낸 지문이나 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다.
    
    이러한 요약은 제 3자가 알아내기 어렵다는 특징을 갖고있다.
    - 다이제스트 인증의 간단한 동작 방식
        1. 클라이언트가 보호된 정보를 요청한다.
        2. 서버는 클라이언트가 비밀번호를 알고 있음을 증명해
        신원을 인증하기 전까지 정보를 응답하는 것을 거부하고,
        클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구한다.
        3. 클라이언트는 비밀번호의 요약을 전달해 비밀번호를 알고 있음을 증명한다.
        4. 서버는 클라이언트가 전달한 요약과 서버 내부적으로 계산한 요약을 비교하고
        서버가 일치 여부를 확인하면 클라이언트에게 정보를 제공한다.
- 단방향 요약
    - 요약은 정보 본문의 압축이고, 단방향 함수로 동작한다.
    - 대표적인 요약 함수는 MD5고, 임의의 바이트 배열을 128비트 요약으로 변환한다.
        - MD5 는 다이제스트 알고리즘 시리즈 중 하나인 메시지 다이제스트 #5 의 약어이며,
        보안 해시 알고리즘(SHA) 또한 인기 있는 다이제스트 함수다.
    - 요약 함수는 보통 암호 체크섬으로 불리며 단방향 해시 함수 또는 지문함수이다.
- 재전송 방지를 위한 난스(nonce) 사용
    - 단방향 요약은 그저 제 3자가 해독하기 어렵도록 만들 뿐이다.
    요약을 제 3자가 가로채서 몇 번이고 서버에 재전송할 수 있는데
    
    이런 재전송 공격을 방지하기 위해 서버는 클라이언트에게 자주 변경되는 증표인
    난스를 건네주게 된다.
    - 난스를 비밀번호에 섞게 되면 난스가 변경될 때 마다 요약도 변경되게 만들어주고,
    특정 난스 값에 대해서만 요약이 유효해져 재전송 공격을 방지할 수 있게 된다.
    - 난스는 WWW-Authenticate 인증 요구에 담겨 서버에서 클라이언트로 전달된다.
- 다이제스트 인증 핸드셰이크
    - HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는 강화된 버전이고, 선택적 헤더인 Authorization-Info 가 추가 되었다.
    - 아래는 다이제스트 인증 핸드셰이크의 단계를 나타낸다.
        1. 서버에서 난스 값을 계산한다.
        2. 서버가 난스를 WWW-Authenticate 인증 요구 메시지에 담아
        서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.
        3. 클라이언트는 알고리즘 목록에서 알고리즘을 선택하고
        그 외 데이터에 대한 요약을 계산한다.
        4. 클라이언트는 Authorization 메시지에 계산한 요약을 담아 서버에게 돌려준다.
        5. 서버는 요약, 선택한 알고리즘, 그 외 데이터들을 받고 클라이언트가 했던 그대로
        요약을 계산해 서버가 계산한 요약과 네트워크로 전송되어 온 요약이 일치하는지
        확인한다.
        또한 서버는 클라이언트가 미리 다음번 요약을 생성할 수 있도록
        다음번 난스를 미리 계산해서 클라이언트에게 넘겨줄 수도 있다.
        
        ![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%B3%E1%86%BC%20febb31420ca3465bb94c358d4ea472ba/Untitled.png)
        

### 13.2 요약 계산

- 요약 알고리즘 입력 데이터
    - 요약은 아래의 세 요소로부터 계산된다.
        1. 단방향 해시 함수 H(d)와 요약함수 KD(s,d) (d = data, s = secret)
        2. 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리 A1
        3. 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리 A2
    - A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.
- H(d)와 KD(s,d) 알고리즘
    - 다이제스트 인증은 여러가지 요약 알고리즘을 선택할 수 있도록 지원하며,
    RFC 2617에서 제안된 MD5와 MD5-sess(session)이고,
    만약 알고리즘이 정해지지 않았다면 MD5가 기본 알고리즘으로 사용된다.
    - MD5와 MD5-sess 중 어느 것이 사용되더라도 H 함수는 데이터의 MD5를 계산하고,
    KD 요약 함수는 콜론으로 연결된 비밀 데이터와 일반 데이터의 MD5를 계산한다.
        - H(<데이터>) = MD5(<데이터>)
        - KD(<비밀>,<데이터>) = H(연결(<비밀>:<데이터>))
- 보안 관련 데이터 A1
    - A1으로 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은
    비밀 보호 정보로 이루어져 있다.
    - MD5
        - 모든 요청마다 단방향 해시를 실행한다.
        A1은 사용자 이름, 영역, 비밀번호를 콜론으로 연결한 것이다.
        - A1 = <사용자>:<영역>:<비밀번호>
    - MD5-sess
        - 사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스(c난스)를 붙인 것이 A1이 된다.
        CPU 를 많이 사용하는 해시 계산은 처음 WWW-Authenticate 핸드셰이크를 할 때 단 한번만 수행한다.
        - A1 = MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스>
- 메시지 관련 데이터 A2
    - A2로 불리는 데이터 덩어리는 URL, 요청 메서드, 메시지 엔터티 본문과 같은
    메시지 자체의 정보를 나타낸다.
    - A2 는 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.
    - RFC 2617의 선택된 보호 수준(qop)에 따른 사용 방법
        1. 기본값으로 qop=”auth” 일 때 사용되며, HTTP 요청 메서드와 URL만 포함한다.
            - 정의되지 않음, auth = <HTTP 요청 메서드>:<Uri 지시자 값>
        2. qop=”auth-int” 일 때 사용되며, 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가한다.
            - auth-int = <HTTP 요청 메서드>:<uri 지시자 값>:H(<요청 엔터티 본문>)
- 요약 알고리즘 전반
    1. RFC 2069와 호환을 염두에 둔 방법으로 qop 옵션이 빠졌을 때 사용된다.
    비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.
    (Deprecated된 방법이다.)
        - 요약 알고리즘 : KD(H(A1), <난스>:H(A2))
        - 펼쳐진 알고리즘 : MD5(MD5(A1):<난스>:MD5(A2))
    2. 현대적이면서 선호되는 접근법으로 난스 횟수 집계 및 대칭 인증의 지원을 포함한다.
    이 접근법은 qop가 auth 또는 auth-int 일 때 사용되며 난스 횟수, qop, c난스 데이터를 모두 요약에 추가한다.
        - 요약 알고리즘 : KD(H(A1), <난스>:<nc>:<c난스>:<qop>:H2(A2))
        - 펼쳐진 알고리즘 : MD5(MD5(A1):<난스>:<nc>:<c난스>:<qop>:MD5(A2))
- 다이제스트 인증 세션
    - 인증 세션은 클라이언트가 보호 공간의 다른 서버로부터
    또 다른 WWW-Authenticate 인증요구를 받을 때까지 지속된다.
    - 난스가 만료되면 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고
    오래된 Authorization 헤더 정보를 받아들이거나
    클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수 있다.
    
    이때 stale=true 를 명시해 사용자 이름, 비밀번호를 다시 입력받을 필요없이 새 난스값으로 요청을 다시 보내라고 말해줄 수 있다.
- 사전 인가
    - 기본 인증은 각 요청의 트랜잭션이 완료되기 전에 요청/인증요구 사이클을 필요로 한다.
    하지만 다이제스트 인증은 클라이언트가 다음 난스가 무엇이 될 지 알고 있어
    서버가 물어보기 전에 올바른 Authorization 헤더를 생성할 수 있다면
    요청/인증요구 사이클은 생략이 가능하다.
    
    ![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%B3%E1%86%BC%20febb31420ca3465bb94c358d4ea472ba/Untitled%201.png)
    
    - 클라이언트가 새 WWW-Authenticate 인증요구를 기다리지 않고 올바른 난스를 취득하는 방법
        1. 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아 미리 보낸다.
            - 서버는 인증이 성공했을 때 200 응답과 함께 아래 헤더를 보낸다.
            Authentication-Info: nextnonce=”<난스 값>”
            - 사전 인가를 통해 요청/인증요구 사이클에서 벗어날 수 있지만
            서버에 다중 요청을 파이프라이닝하는 능력은 실질적으로 쓸모가 없어진다.
            다음 요청을 보내기 전에 다음 난스 값을 받아야하기 때문에 성능상 불이익이
            더 커진다.
        2. 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
            - 서버는 한 난스를 몇 번 혹은 몇 초간 재사용하도록 허락할 수 있고,
            이 경우 WWW-Authenticate: stale=true 지시어는 아래와 같이 설정된다.
            WWW-Authenticate: Digest realm=”<영역 값>” nonce=”<난스 값>” stale=true
            - 난스를 재사용하면 공격자의 재전송 공격이 성공하기 쉬워지므로
            보안성이 감소한다.
        3. 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다.
            - 제 3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반해
            클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록
            시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능하다.
        - 이 알고리즘들은 다이제스트 인증 명세의 범위를 넘어서는 것이다.
- 난스 선택
    - RFC 2617가 제안한 가상의 난스 공식
        - BASE64(타임스탬프 H(타임스탬프 “:” ETag “:” 개인키))

### 13.3 보호 수준 향상

- qop 필드는 WWW-Authenticate, Authorization, Authentication-Info에 모두 존재할 수 있고,
서버와 클라가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다.
- 서버는 WWW-Authenticate 헤더에 qop 옵션을 쉼표로 구분된 목록 형태로 내보낸다.
그 후 클라이언트는 그 옵션들 중 지원할 수 있으면서 동시에
자신의 요구에도 맞는 것을 선택하고, Authorization 헤더의 qop 필드에 담아 돌려준다.
- qop 사용이 선택사항이긴 하지만 이는 RFC 2069 명세와의 호환성을 유지하기 위함이므로
모든 현재 요약 구현은 qop 옵션을 지원해야 한다.
- RFC 2617은 기본적으로 두 가지 초기 보호수준 값을 정의하고 있는데
인증을 의미하는 auth, 인증 및 메시지 무결성 보호를 의미하는 auth-int 가 있다.
- 메시지 무결성 보호
    - 메시지 무결성 보호가 적용되었을 때 계산된 H는 메시지 본문의 해시가 아닌
    엔터티 본문의 해시이다.
- 다이제스트 인증 헤더
    - 기본 인증과 다이제스트 인증 모두 WWW-Authenticate 헤더에 담겨 전달되는 인증요구와, Authorization 헤더에 담겨 전달되는 인가 응답을 포함한다.
    - 다이제스트 인증은 여기에 선택적인 Authentication-Info 헤더를 추가했다.
    이 헤더는 3단계 핸드셰이크를 완성하고 다음번 사용할 난스를 전달하기 위해 인증 성공 후 전송된다.
    - 기본 및 다이제스트 인증에서 사용되는 헤더 목록
        
        ![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%B3%E1%86%BC%20febb31420ca3465bb94c358d4ea472ba/Untitled%202.png)
        

### 13.4 실제 상황에 대한 고려

- 다중 인증요구
    - 서버는 한 리소스에 대해 여러 인증을 요구할 수 있는데 이때 클라이언트는
    반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 사용해야 한다.
    - 다양한 인증 옵션을 제공하는 경우, 가장 허약한 연결부분에 대한 보안 우려가
    있다는 것은 명확하다.
    서버는 기본 인증을 제한적으로 사용해야 할 것이고,
    관리자는 사용자에게 보안 수준이 다른 여러 시스템에서 같은 비밀번호를
    사용하는 것의 위험성에 대해 경고해야 할 것이다.
- 오류 처리
    - 다이제스트 인증에서 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠진 경우
    알맞은 응답은 400이다.
    - 요청의 요약이 맞지 않으면 로그인이 실패했음을 기록해두는 것이 좋다.
    반복된 실패의 경우 공격자가 비밀번호 추측을 시도하고 있음을 의미한다.
    - 인증 서버는 반드시 uri 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와
    같은지를 확인해야 한다. 만약 다르다면 400을 반환하는 것이 좋다.
- 보호 공간
    - 영역은 서버의 보호된 리소스들을 자신만의 인증 제도와 인가 데이터베이스
    어느 한 쪽 혹은 양쪽 모두를 가진 보호 영역의 집합으로 분할할 수 있도록 해준다.
    - 영역 값은 접근한 서버의 루트 URL과 결합되어 보호 공간을 정의한다.
    - 보호 공간의 구체적인 계산은 인증 메커니즘에 달려있다.
        - 기본 인증에서 클라이언트는 요청 URI와 그 하위의 모든 경로는 같은 보호 공간에
        있는 것으로 가정한다.
        - 다이제스트 인증에서 domain 필드는 작은따옴표로 묶인
        URI의 공백으로 분리된 목록이다. 
        이 목록의 모든 URI 와 논리적으로 그 하위에 위치한
        모든 URI는 같은 보호 공간에 있는 것으로 가정한다.
        
        만약 domain 필드가 없거나 빈 값이라면 인증을 요구하는 서버의 모든 URI는
        그 보호 공간에 있는 것이다.
- URI 다시 쓰기
    - 프락시는 가리키는 리소스의 변경 없이 구문만 고쳐 URI를 다시 작성하기도 한다.
        - 호스트 명은 정규화되거나 IP 주소로 대체될 수 있다.
        - 문자들은 escape 형식으로 대체될 수 있다.
        - 특정 원 서버로부터 가져오는 리소스에 영향을 주지 않는
        타입에 대한 추가 속성이 URI의 끝이나 중간에 삽입 될 수 있다.
    - 프락시가 URI를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하기 때문에 이러한 변경에 의해 다이제스트 인증이 실패할 수 있다.
- 캐시
    - 어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우
    다음 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한
    다른 요청에 대해 그 응답을 반환해서는 안 된다.
        - 만약 원 서버의 응답이 must-revalidate Cache-Control 지시자를 포함한 경우
        캐시는 그 응답의 엔터티를 다음 요청에 대한 응답을 위해 활용할 것 이다.
        그러나 원 서버가 새 요청을 인증할 수 있도록
        우선 그 요청의 헤더를 이용해 재검사를 수행해야 한다.
        - 만약 원 서버의 응답이 public Cache-Control 지시자를 포함한 경우
        응답 엔터티는 그 다음에 오는 임의의 요청에 대한 응답으로 반환될 수 있다.

### 13.5 보안에 대한 고려사항

- 헤더 부당 변경
    - 헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서
    양 종단 암호화나 헤더에 대한 디지털 서명이 필요할 것이다.
    - 다이제스트 인증은 쉽게 조작할 수 없는 인증 제도를 제공하는 것에 초점을
    맞추고 있으나 반드시 그 보호를 데이터에까지 확장하는 것은 아니다.
    보호 수준에 대한 정보는 WWW-Authenticate와 Authorization 헤더에만 담겨있다.
- 재전송 공격
    - 재전송 공격이란 제 3자가 트랜잭션에서 엿들은 인증 자격을 다른 트랜잭션을 위해
    사용하는 것을 말한다.
    해당 문제는 GET 요청에 대한 이슈이긴 하지만 POST 와 PUT 요청에 대한
    재전송 공격에 대해서도 항상 잘 동작하는 예방책을 필수로 가지고 있어야 한다.
    - 이 문제를 완화시키는 방법 중 하나는 클라이언트의 IP 주소, 타임스탬프, 리소스의 ETag,
    개인 서버 키에 대한 요약을 포함하는 난스를 서버가 생성하도록 하는 것이다.
    또는 매 트랜잭션마다 유일한 난스 값을 사용하는 것이다.
- 다중 인증 메커니즘
    - 서버가 다중 인증 제도를 지원할 때 WWW-Authenticate 헤더를 통해 선택지를 제공할 것이다.
    - 클라이언트에게 가장 강력한 인증 메커니즘을 선택해야 할 의무가 있는 것은 아니기에
    인증의 강도는 선택지 중 가장 약한 것과 같다고 보아야 한다.
    - 이 문제를 피하기 위해 클라이언트가 가장 강력한 인증 제도를 선택하는 것이다.
    현실적으로 불가능하다면 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용하는 것이다.
- 사전 공격
    - 사전 공격은 전형적인 비밀번호 추측 공격이다
    - 만약 사용자가 상대적으로 단순한 비밀번호를 사용하고 서버도 단순한 난스를 사용하고 있다면 맞는 것을 찾아낼 확률이 꽤 존재한다.
    - 이 문제는 해결이 불가능하고 크래킹하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하는 것과 괜찮은 비밀번호 만료 정책으로 막는 방법밖에 없다.
- 악의적인 프락시와 중간자 공격
    - 프락시 중 하나가 악의적이거나 보안이 허술하다면 클라이언트는 중간자 공격에 취약한 상태가 될 가능성이 존재한다.
    - 이것을 막는 유일한 방법은 SSL을 활용하는 것이다.
- 선택 평문 공격
    - 클라이언트 보안이 허술하거나 악의적인 프락시가 트래픽 중간에 끼어든다면
    그것은 어렵지 않게 클라이언트가 응답 계산을 하기 위한 난스를 제공할 수 있다.
    - 선택 평문 공격의 변종
        - 미리 계산된 사전 공격
            - 사전 공격과 선택 평문 공격의 조합으로
            공격 서버가 미리 결정된 난스와 자주 사용되는 비밀번호들로
            응답의 집합을 생성하고 사전을 만든다.
            - 꽤 큰 사전이 만들어지면 공격 서버 또는 프락시는 트래픽을 차단하고
            미리 결정된 난스를 클라이언트로 전송하기 시작한다.
            - 클라이언트로부터 응답을 받을 때 공격자는 대응되는 항목을
            생성된 사전에서 찾는다. 만약 대응되는 것이 존재하면
            공격자는 특정 사용자의 비밀번호를 얻은 것이다.
        - 자동화된 무차별 대입 공격
            - 강력한 비밀번호 설정이나 비밀번호 만료 정책으로 위협을 경감시킬 수 있다.
            - 또는 서버에서 제공된 난스 대신 선택적인 c난스 지시자를 사용해 응답을 생성할 수 있도록 설정하는 방법도 있다.
- 비밀번호 저장
    - 다이제스트 인증 메커니즘은 사용자 응답을 서버 내부에 저장된 것과 비교한다.
    - 이 때문에 다이제스트 인증 비밀번호 파일이 유출되면 영역의 모든 문서는 공격자에게 노출된다.
    - 이 문제를 완화하는 방법은 몇 가지가 존재한다.
        - 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다.
        - 영역 이름이 유일함을 보장하며 비밀번호 파일이 유출되더라도 피해를 특정 영역으로 국소화한다.
- 다이제스트 인증이 기본 인증에 비해 훨씬 탄탄하고 안전한 해결책을 제공함에도
여전히 콘텐츠에 대한 보안 측면에서는 어떠한 보호도 제공하지 못한다.
진정한 보안 트랜잭션은 오로지 SSL을 통해서만 가능하다.